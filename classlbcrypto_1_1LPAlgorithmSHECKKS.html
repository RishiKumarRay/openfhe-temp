<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PALISADE Lattice Crypto Library: lbcrypto::LPAlgorithmSHECKKS&lt; Element &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PALISADE Lattice Crypto Library
   &#160;<span id="projectnumber">1.11.5</span>
   </div>
   <div id="projectbrief">A lattice crypto library for software engineers by software engineers.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelbcrypto.html">lbcrypto</a></li><li class="navelem"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html">LPAlgorithmSHECKKS</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classlbcrypto_1_1LPAlgorithmSHECKKS-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">lbcrypto::LPAlgorithmSHECKKS&lt; Element &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="ckks_8h_source.html">ckks.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for lbcrypto::LPAlgorithmSHECKKS&lt; Element &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classlbcrypto_1_1LPAlgorithmSHECKKS__inherit__graph.png" border="0" usemap="#lbcrypto_1_1LPAlgorithmSHECKKS_3_01Element_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="lbcrypto_1_1LPAlgorithmSHECKKS_3_01Element_01_4_inherit__map" id="lbcrypto_1_1LPAlgorithmSHECKKS_3_01Element_01_4_inherit__map">
<area shape="rect" title=" " alt="" coords="5,95,228,136"/>
<area shape="rect" href="classlbcrypto_1_1LPSHEAlgorithm.html" title="Abstract interface class for LBC SHE algorithms." alt="" coords="23,5,211,47"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for lbcrypto::LPAlgorithmSHECKKS&lt; Element &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classlbcrypto_1_1LPAlgorithmSHECKKS__coll__graph.png" border="0" usemap="#lbcrypto_1_1LPAlgorithmSHECKKS_3_01Element_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="lbcrypto_1_1LPAlgorithmSHECKKS_3_01Element_01_4_coll__map" id="lbcrypto_1_1LPAlgorithmSHECKKS_3_01Element_01_4_coll__map">
<area shape="rect" title=" " alt="" coords="5,95,228,136"/>
<area shape="rect" href="classlbcrypto_1_1LPSHEAlgorithm.html" title="Abstract interface class for LBC SHE algorithms." alt="" coords="23,5,211,47"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acf57be95906e1ccd0f9c29a10b981213"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html#acf57be95906e1ccd0f9c29a10b981213">LPAlgorithmSHECKKS</a> ()</td></tr>
<tr class="separator:acf57be95906e1ccd0f9c29a10b981213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2dd71f2b61017403011f7facd6a0638"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html#ac2dd71f2b61017403011f7facd6a0638">~LPAlgorithmSHECKKS</a> ()</td></tr>
<tr class="separator:ac2dd71f2b61017403011f7facd6a0638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7199eaa974de78ef546f62dc748ea0ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html#a7199eaa974de78ef546f62dc748ea0ec">EvalAddInPlace</a> (Ciphertext&lt; Element &gt; &amp;ciphertext1, ConstCiphertext&lt; Element &gt; ciphertext2) const override</td></tr>
<tr class="separator:a7199eaa974de78ef546f62dc748ea0ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b59ca6e30a03093901634136e43b47c"><td class="memItemLeft" align="right" valign="top">Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html#a0b59ca6e30a03093901634136e43b47c">EvalAddMutable</a> (Ciphertext&lt; Element &gt; &amp;ciphertext1, Ciphertext&lt; Element &gt; &amp;ciphertext2) const override</td></tr>
<tr class="separator:a0b59ca6e30a03093901634136e43b47c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d25262c4f0f46110adf5ffb76a7f198"><td class="memItemLeft" align="right" valign="top">Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html#a9d25262c4f0f46110adf5ffb76a7f198">EvalAdd</a> (ConstCiphertext&lt; Element &gt; ciphertext, ConstPlaintext plaintext) const override</td></tr>
<tr class="separator:a9d25262c4f0f46110adf5ffb76a7f198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6126c4a7234b4173c06245bcba0b53b7"><td class="memItemLeft" align="right" valign="top">Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html#a6126c4a7234b4173c06245bcba0b53b7">EvalAddMutable</a> (Ciphertext&lt; Element &gt; &amp;ciphertext, Plaintext plaintext) const override</td></tr>
<tr class="separator:a6126c4a7234b4173c06245bcba0b53b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c3ff33753a7595c82fbf2b7b364d07c"><td class="memItemLeft" align="right" valign="top">Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html#a5c3ff33753a7595c82fbf2b7b364d07c">EvalAdd</a> (ConstCiphertext&lt; Element &gt; ciphertext, double constant) const override</td></tr>
<tr class="separator:a5c3ff33753a7595c82fbf2b7b364d07c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a860226466f01bec59935c116d0f8efd2"><td class="memItemLeft" align="right" valign="top">virtual Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html#a860226466f01bec59935c116d0f8efd2">EvalAddMutable</a> (Ciphertext&lt; Element &gt; &amp;ciphertext, double constant) const</td></tr>
<tr class="separator:a860226466f01bec59935c116d0f8efd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bccdbf873e70aa6f13114c81403f526"><td class="memItemLeft" align="right" valign="top">Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html#a0bccdbf873e70aa6f13114c81403f526">EvalLinearWSum</a> (vector&lt; Ciphertext&lt; Element &gt;&gt; ciphertexts, vector&lt; double &gt; constants) const override</td></tr>
<tr class="separator:a0bccdbf873e70aa6f13114c81403f526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab86bba14cf675f8bdc978134c065b211"><td class="memItemLeft" align="right" valign="top">Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html#ab86bba14cf675f8bdc978134c065b211">EvalLinearWSumMutable</a> (vector&lt; Ciphertext&lt; Element &gt;&gt; ciphertexts, vector&lt; double &gt; constants) const override</td></tr>
<tr class="separator:ab86bba14cf675f8bdc978134c065b211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a521206ba8fa58ae54b2687efe56d9bac"><td class="memItemLeft" align="right" valign="top">Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html#a521206ba8fa58ae54b2687efe56d9bac">EvalSub</a> (ConstCiphertext&lt; Element &gt; ciphertext1, ConstCiphertext&lt; Element &gt; ciphertext2) const override</td></tr>
<tr class="separator:a521206ba8fa58ae54b2687efe56d9bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcf28d1ffc715d2789338f9666dd542f"><td class="memItemLeft" align="right" valign="top">Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html#abcf28d1ffc715d2789338f9666dd542f">EvalSubMutable</a> (Ciphertext&lt; Element &gt; &amp;ciphertext1, Ciphertext&lt; Element &gt; &amp;ciphertext2) const override</td></tr>
<tr class="separator:abcf28d1ffc715d2789338f9666dd542f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81323981d249465bb59d56ce80751ba2"><td class="memItemLeft" align="right" valign="top">Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html#a81323981d249465bb59d56ce80751ba2">EvalSub</a> (ConstCiphertext&lt; Element &gt; ciphertext1, ConstPlaintext plaintext) const override</td></tr>
<tr class="separator:a81323981d249465bb59d56ce80751ba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a857f33870ee1bf72f936ece50621da7a"><td class="memItemLeft" align="right" valign="top">Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html#a857f33870ee1bf72f936ece50621da7a">EvalSubMutable</a> (Ciphertext&lt; Element &gt; &amp;ciphertext1, Plaintext plaintext) const override</td></tr>
<tr class="separator:a857f33870ee1bf72f936ece50621da7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aacccdcfbaf47f4522b3636e2ad3a4f"><td class="memItemLeft" align="right" valign="top">Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html#a2aacccdcfbaf47f4522b3636e2ad3a4f">EvalSub</a> (ConstCiphertext&lt; Element &gt; ciphertext, double constant) const override</td></tr>
<tr class="separator:a2aacccdcfbaf47f4522b3636e2ad3a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3ff339fe511166d5cd848f3eb50dced"><td class="memItemLeft" align="right" valign="top">virtual Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html#aa3ff339fe511166d5cd848f3eb50dced">EvalSubMutable</a> (Ciphertext&lt; Element &gt; &amp;ciphertext, double constant) const</td></tr>
<tr class="separator:aa3ff339fe511166d5cd848f3eb50dced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e84c4d2606c28d80ef29a9b075a367e"><td class="memItemLeft" align="right" valign="top">Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html#a7e84c4d2606c28d80ef29a9b075a367e">EvalMult</a> (ConstCiphertext&lt; Element &gt; ciphertext1, ConstCiphertext&lt; Element &gt; ciphertext2) const override</td></tr>
<tr class="separator:a7e84c4d2606c28d80ef29a9b075a367e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a525ddb495ab8c15ff92d21c8edf6bf23"><td class="memItemLeft" align="right" valign="top">Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html#a525ddb495ab8c15ff92d21c8edf6bf23">EvalMultMutable</a> (Ciphertext&lt; Element &gt; &amp;ciphertext1, Ciphertext&lt; Element &gt; &amp;ciphertext2) const override</td></tr>
<tr class="separator:a525ddb495ab8c15ff92d21c8edf6bf23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd5f61036257d1076449e13ffd0d9dbf"><td class="memItemLeft" align="right" valign="top">Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html#acd5f61036257d1076449e13ffd0d9dbf">EvalMult</a> (ConstCiphertext&lt; Element &gt; ciphertext, ConstPlaintext plaintext) const override</td></tr>
<tr class="separator:acd5f61036257d1076449e13ffd0d9dbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdbde626ed0cc1758f8e011085ebfeb2"><td class="memItemLeft" align="right" valign="top">Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html#afdbde626ed0cc1758f8e011085ebfeb2">EvalMultMutable</a> (Ciphertext&lt; Element &gt; &amp;ciphertext, Plaintext plaintext) const override</td></tr>
<tr class="separator:afdbde626ed0cc1758f8e011085ebfeb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f5a3970ef9acb282c00125acd8ebce6"><td class="memItemLeft" align="right" valign="top">Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html#a0f5a3970ef9acb282c00125acd8ebce6">EvalMult</a> (ConstCiphertext&lt; Element &gt; ciphertext, double constant) const override</td></tr>
<tr class="separator:a0f5a3970ef9acb282c00125acd8ebce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99f708fe6d342983d0fc722a74901d71"><td class="memItemLeft" align="right" valign="top">Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html#a99f708fe6d342983d0fc722a74901d71">EvalMultMutable</a> (Ciphertext&lt; Element &gt; &amp;ciphertext, double constant) const override</td></tr>
<tr class="separator:a99f708fe6d342983d0fc722a74901d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7af7a9efdabd08780b3f2aec49164c5d"><td class="memItemLeft" align="right" valign="top">Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html#a7af7a9efdabd08780b3f2aec49164c5d">EvalMult</a> (ConstCiphertext&lt; Element &gt; ciphertext1, ConstCiphertext&lt; Element &gt; ciphertext2, const LPEvalKey&lt; Element &gt; ek) const override</td></tr>
<tr class="separator:a7af7a9efdabd08780b3f2aec49164c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f72dada39a7f1c72331dfe868047699"><td class="memItemLeft" align="right" valign="top">Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html#a5f72dada39a7f1c72331dfe868047699">EvalMultMutable</a> (Ciphertext&lt; Element &gt; &amp;ciphertext1, Ciphertext&lt; Element &gt; &amp;ciphertext2, const LPEvalKey&lt; Element &gt; ek) const override</td></tr>
<tr class="separator:a5f72dada39a7f1c72331dfe868047699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96496c8636e1f2f14223b564c4de6c54"><td class="memItemLeft" align="right" valign="top">Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html#a96496c8636e1f2f14223b564c4de6c54">EvalMultAndRelinearize</a> (ConstCiphertext&lt; Element &gt; ciphertext1, ConstCiphertext&lt; Element &gt; ciphertext2, const vector&lt; LPEvalKey&lt; Element &gt;&gt; &amp;ek) const override</td></tr>
<tr class="separator:a96496c8636e1f2f14223b564c4de6c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad74d167a7a3523ee78efc3cf9c48cc37"><td class="memItemLeft" align="right" valign="top">Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html#ad74d167a7a3523ee78efc3cf9c48cc37">Relinearize</a> (ConstCiphertext&lt; Element &gt; ciphertext, const vector&lt; LPEvalKey&lt; Element &gt;&gt; &amp;ek) const override</td></tr>
<tr class="separator:ad74d167a7a3523ee78efc3cf9c48cc37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa945686a01ec846b32831583fab2e790"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html#aa945686a01ec846b32831583fab2e790">RelinearizeInPlace</a> (Ciphertext&lt; Element &gt; &amp;ciphertext, const vector&lt; LPEvalKey&lt; Element &gt;&gt; &amp;ek) const override</td></tr>
<tr class="separator:aa945686a01ec846b32831583fab2e790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d6bcdce7784364320fdaf01bdab737a"><td class="memItemLeft" align="right" valign="top">Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html#a4d6bcdce7784364320fdaf01bdab737a">EvalNegate</a> (ConstCiphertext&lt; Element &gt; ct) const override</td></tr>
<tr class="separator:a4d6bcdce7784364320fdaf01bdab737a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf9a99072d2785328ab947c5094c91e8"><td class="memItemLeft" align="right" valign="top">LPEvalKey&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html#aaf9a99072d2785328ab947c5094c91e8">KeySwitchHybridGen</a> (const LPPrivateKey&lt; Element &gt; oldKey, const LPPrivateKey&lt; Element &gt; newKey, const LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ek=nullptr) const</td></tr>
<tr class="separator:aaf9a99072d2785328ab947c5094c91e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a019eb93ac0e2bb99d41c1c3f3927e02f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html#a019eb93ac0e2bb99d41c1c3f3927e02f">KeySwitchHybridInPlace</a> (const LPEvalKey&lt; Element &gt; keySwitchHint, Ciphertext&lt; Element &gt; &amp;ciphertext) const</td></tr>
<tr class="separator:a019eb93ac0e2bb99d41c1c3f3927e02f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60fd5c558fd04921f6067cb81763aa8e"><td class="memItemLeft" align="right" valign="top">LPEvalKey&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html#a60fd5c558fd04921f6067cb81763aa8e">KeySwitchGHSGen</a> (const LPPrivateKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; oldKey, const LPPrivateKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; newKey, const LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ek=nullptr) const</td></tr>
<tr class="separator:a60fd5c558fd04921f6067cb81763aa8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a658367f8d904bb4ef21d74ec2727eb5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html#a658367f8d904bb4ef21d74ec2727eb5a">KeySwitchGHSInPlace</a> (const LPEvalKey&lt; Element &gt; keySwitchHint, Ciphertext&lt; Element &gt; &amp;ciphertext) const</td></tr>
<tr class="separator:a658367f8d904bb4ef21d74ec2727eb5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ec8b42d38197a25523d0e22df276ac6"><td class="memItemLeft" align="right" valign="top">LPEvalKey&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html#a7ec8b42d38197a25523d0e22df276ac6">KeySwitchBVGen</a> (const LPPrivateKey&lt; Element &gt; oldKey, const LPPrivateKey&lt; Element &gt; newKey, const LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ek=nullptr) const</td></tr>
<tr class="separator:a7ec8b42d38197a25523d0e22df276ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3acc8e313e63ac0641acc75502a0f057"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html#a3acc8e313e63ac0641acc75502a0f057">KeySwitchBVInPlace</a> (const LPEvalKey&lt; Element &gt; keySwitchHint, Ciphertext&lt; Element &gt; &amp;ciphertext) const</td></tr>
<tr class="separator:a3acc8e313e63ac0641acc75502a0f057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b99ba4b5173b50118a11be1a1a8bc5"><td class="memItemLeft" align="right" valign="top">LPEvalKey&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html#ae8b99ba4b5173b50118a11be1a1a8bc5">KeySwitchGen</a> (const LPPrivateKey&lt; Element &gt; oldKey, const LPPrivateKey&lt; Element &gt; newKey) const override</td></tr>
<tr class="separator:ae8b99ba4b5173b50118a11be1a1a8bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0284cd94582a0cdc6160a5e889380eea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html#a0284cd94582a0cdc6160a5e889380eea">KeySwitchInPlace</a> (const LPEvalKey&lt; Element &gt; keySwitchHint, Ciphertext&lt; Element &gt; &amp;ciphertext) const override</td></tr>
<tr class="separator:a0284cd94582a0cdc6160a5e889380eea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a959b4624c257eabccc83aca950e24515"><td class="memItemLeft" align="right" valign="top">LPEvalKey&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html#a959b4624c257eabccc83aca950e24515">EvalMultKeyGen</a> (const LPPrivateKey&lt; Element &gt; privateKey) const override</td></tr>
<tr class="separator:a959b4624c257eabccc83aca950e24515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e56bf8b0c4a5c6143ff2038a4563c3c"><td class="memItemLeft" align="right" valign="top">vector&lt; LPEvalKey&lt; Element &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html#a6e56bf8b0c4a5c6143ff2038a4563c3c">EvalMultKeysGen</a> (const LPPrivateKey&lt; Element &gt; privateKey) const override</td></tr>
<tr class="separator:a6e56bf8b0c4a5c6143ff2038a4563c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab347576608143a13fd93315a4974a68b"><td class="memItemLeft" align="right" valign="top">Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html#ab347576608143a13fd93315a4974a68b">EvalAutomorphism</a> (ConstCiphertext&lt; Element &gt; ciphertext, usint i, const std::map&lt; usint, LPEvalKey&lt; Element &gt;&gt; &amp;evalKeys, CALLER_INFO_ARGS_HDR) const override</td></tr>
<tr class="separator:ab347576608143a13fd93315a4974a68b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc46d310f82cdd136649a296c166b774"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; std::map&lt; usint, LPEvalKey&lt; Element &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html#afc46d310f82cdd136649a296c166b774">EvalAutomorphismKeyGen</a> (const LPPrivateKey&lt; Element &gt; privateKey, const std::vector&lt; usint &gt; &amp;indexList) const override</td></tr>
<tr class="separator:afc46d310f82cdd136649a296c166b774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df36c88eb8bbd41bfd41089de83763b"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; std::map&lt; usint, LPEvalKey&lt; Element &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html#a4df36c88eb8bbd41bfd41089de83763b">EvalAutomorphismKeyGen</a> (const LPPublicKey&lt; Element &gt; publicKey, const LPPrivateKey&lt; Element &gt; privateKey, const std::vector&lt; usint &gt; &amp;indexList) const override</td></tr>
<tr class="separator:a4df36c88eb8bbd41bfd41089de83763b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c0169a86c9bdcf42af3e02fb3654a53"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; vector&lt; Element &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html#a4c0169a86c9bdcf42af3e02fb3654a53">EvalFastRotationPrecompute</a> (ConstCiphertext&lt; Element &gt; ciphertext) const override</td></tr>
<tr class="separator:a4c0169a86c9bdcf42af3e02fb3654a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14209690d415e907a9acfba9c4da0e9b"><td class="memItemLeft" align="right" valign="top">Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html#a14209690d415e907a9acfba9c4da0e9b">EvalFastRotation</a> (ConstCiphertext&lt; Element &gt; ciphertext, const usint index, const usint m, const shared_ptr&lt; vector&lt; Element &gt;&gt; precomp) const override</td></tr>
<tr class="separator:a14209690d415e907a9acfba9c4da0e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d1c52136c0e1aa5537007e154b2cecd"><td class="memItemLeft" align="right" valign="top">Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html#a4d1c52136c0e1aa5537007e154b2cecd">AdjustLevelWithRescale</a> (Ciphertext&lt; Element &gt; &amp;ciphertext, uint32_t targetLevel) const override</td></tr>
<tr class="separator:a4d1c52136c0e1aa5537007e154b2cecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac785b87c298c86667c430f7cc5d099a5"><td class="memItemLeft" align="right" valign="top">Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html#ac785b87c298c86667c430f7cc5d099a5">AdjustLevelWithoutRescale</a> (Ciphertext&lt; Element &gt; &amp;ciphertext, uint32_t targetLevel) const</td></tr>
<tr class="separator:ac785b87c298c86667c430f7cc5d099a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae11c45036a464e5f07c61c5b9d50fc04"><td class="memTemplParams" colspan="2"><a id="ae11c45036a464e5f07c61c5b9d50fc04"></a>
template&lt;class Archive &gt; </td></tr>
<tr class="memitem:ae11c45036a464e5f07c61c5b9d50fc04"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>save</b> (Archive &amp;ar) const</td></tr>
<tr class="separator:ae11c45036a464e5f07c61c5b9d50fc04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a691963b0789e35935af6c52d7b0f9d72"><td class="memTemplParams" colspan="2"><a id="a691963b0789e35935af6c52d7b0f9d72"></a>
template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a691963b0789e35935af6c52d7b0f9d72"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>load</b> (Archive &amp;ar)</td></tr>
<tr class="separator:a691963b0789e35935af6c52d7b0f9d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69e45ede322f94622b47bef1b54b5e6d"><td class="memItemLeft" align="right" valign="top"><a id="a69e45ede322f94622b47bef1b54b5e6d"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>SerializedObjectName</b> () const</td></tr>
<tr class="separator:a69e45ede322f94622b47bef1b54b5e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8613a64a5a61b45912ca66bf669ee77a"><td class="memItemLeft" align="right" valign="top"><a id="a8613a64a5a61b45912ca66bf669ee77a"></a>
LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>KeySwitchHybridGen</b> (const LPPrivateKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; oldKey, const LPPrivateKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; newKey, const LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ekPrev) const</td></tr>
<tr class="separator:a8613a64a5a61b45912ca66bf669ee77a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae938a27429086bea8a07c0ad99fd867a"><td class="memItemLeft" align="right" valign="top"><a id="ae938a27429086bea8a07c0ad99fd867a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>KeySwitchHybridInPlace</b> (const LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ek, Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; &amp;ciphertext) const</td></tr>
<tr class="separator:ae938a27429086bea8a07c0ad99fd867a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fb4e5b3b314ff3d569844a77b0a4555"><td class="memItemLeft" align="right" valign="top"><a id="a9fb4e5b3b314ff3d569844a77b0a4555"></a>
LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>KeySwitchGHSGen</b> (const LPPrivateKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; oldKey, const LPPrivateKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; newKey, const LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ekPrev) const</td></tr>
<tr class="separator:a9fb4e5b3b314ff3d569844a77b0a4555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f227412a9b0fdd78e22941d091d6b6f"><td class="memItemLeft" align="right" valign="top"><a id="a0f227412a9b0fdd78e22941d091d6b6f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>KeySwitchGHSInPlace</b> (const LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ek, Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; &amp;ciphertext) const</td></tr>
<tr class="separator:a0f227412a9b0fdd78e22941d091d6b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78fdf1226eb719a48cf5249484f89791"><td class="memItemLeft" align="right" valign="top"><a id="a78fdf1226eb719a48cf5249484f89791"></a>
LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>KeySwitchBVGen</b> (const LPPrivateKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; oldKey, const LPPrivateKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; newKey, const LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ekPrev) const</td></tr>
<tr class="separator:a78fdf1226eb719a48cf5249484f89791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf260294626e9fd352d4ed4768b220e"><td class="memItemLeft" align="right" valign="top"><a id="a2bf260294626e9fd352d4ed4768b220e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>KeySwitchBVInPlace</b> (const LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ek, Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; &amp;ciphertext) const</td></tr>
<tr class="separator:a2bf260294626e9fd352d4ed4768b220e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d0b912d6b10acba4441986868148396"><td class="memItemLeft" align="right" valign="top"><a id="a3d0b912d6b10acba4441986868148396"></a>
LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>KeySwitchGen</b> (const LPPrivateKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; oldKey, const LPPrivateKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; newKey) const</td></tr>
<tr class="separator:a3d0b912d6b10acba4441986868148396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd71a90e17e889854cb557339855513"><td class="memItemLeft" align="right" valign="top"><a id="a6fd71a90e17e889854cb557339855513"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>KeySwitchInPlace</b> (const LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ek, Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; &amp;ciphertext) const</td></tr>
<tr class="separator:a6fd71a90e17e889854cb557339855513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a706e13ae0b884ed98ea64e9164b4bdd4"><td class="memItemLeft" align="right" valign="top"><a id="a706e13ae0b884ed98ea64e9164b4bdd4"></a>
Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalAdd</b> (ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ciphertext, double constant) const</td></tr>
<tr class="separator:a706e13ae0b884ed98ea64e9164b4bdd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c74d35aaca0b2d52087637115e0daa4"><td class="memItemLeft" align="right" valign="top"><a id="a2c74d35aaca0b2d52087637115e0daa4"></a>
Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalSub</b> (ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ciphertext, double constant) const</td></tr>
<tr class="separator:a2c74d35aaca0b2d52087637115e0daa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a230801eacab40fa1ce63e173814a5975"><td class="memItemLeft" align="right" valign="top"><a id="a230801eacab40fa1ce63e173814a5975"></a>
Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalMultMutable</b> (Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; &amp;ciphertext, double constant) const</td></tr>
<tr class="separator:a230801eacab40fa1ce63e173814a5975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a230801eacab40fa1ce63e173814a5975"><td class="memItemLeft" align="right" valign="top"><a id="a230801eacab40fa1ce63e173814a5975"></a>
Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalMultMutable</b> (Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; &amp;ciphertext, double constant) const</td></tr>
<tr class="separator:a230801eacab40fa1ce63e173814a5975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05a92b08d3097ef91aa17f8cdcc10055"><td class="memItemLeft" align="right" valign="top"><a id="a05a92b08d3097ef91aa17f8cdcc10055"></a>
Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalMult</b> (ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ciphertext, double constant) const</td></tr>
<tr class="separator:a05a92b08d3097ef91aa17f8cdcc10055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55c111a96163d8a09cabef6e700e2b51"><td class="memItemLeft" align="right" valign="top"><a id="a55c111a96163d8a09cabef6e700e2b51"></a>
Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>AdjustLevelWithRescale</b> (Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; &amp;ciphertext, uint32_t targetLevel) const</td></tr>
<tr class="separator:a55c111a96163d8a09cabef6e700e2b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af487cd7b11b98256fb27079dc9e19d47"><td class="memItemLeft" align="right" valign="top"><a id="af487cd7b11b98256fb27079dc9e19d47"></a>
Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>AdjustLevelWithoutRescale</b> (Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; &amp;ciphertext, uint32_t targetLevel) const</td></tr>
<tr class="separator:af487cd7b11b98256fb27079dc9e19d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acacf91ac07a37da67cb0acc0ec055929"><td class="memItemLeft" align="right" valign="top"><a id="acacf91ac07a37da67cb0acc0ec055929"></a>
Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalAddMutable</b> (Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; &amp;ciphertext1, Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; &amp;ciphertext2) const</td></tr>
<tr class="separator:acacf91ac07a37da67cb0acc0ec055929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13a0dba0c483719bc93c7cad5cde22ea"><td class="memItemLeft" align="right" valign="top"><a id="a13a0dba0c483719bc93c7cad5cde22ea"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EvalAddInPlace</b> (Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; &amp;ciphertext1, ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ciphertext2) const</td></tr>
<tr class="separator:a13a0dba0c483719bc93c7cad5cde22ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7faf79a1d2b8261939b3bb123a610194"><td class="memItemLeft" align="right" valign="top"><a id="a7faf79a1d2b8261939b3bb123a610194"></a>
Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalAdd</b> (ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ciphertext, ConstPlaintext plaintext) const</td></tr>
<tr class="separator:a7faf79a1d2b8261939b3bb123a610194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e034359f71e516ed730f6e0380bb0f"><td class="memItemLeft" align="right" valign="top"><a id="a73e034359f71e516ed730f6e0380bb0f"></a>
Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalAddMutable</b> (Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; &amp;ciphertext, Plaintext plaintext) const</td></tr>
<tr class="separator:a73e034359f71e516ed730f6e0380bb0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3df2677705659414ff6aa87c81c95c9"><td class="memItemLeft" align="right" valign="top"><a id="af3df2677705659414ff6aa87c81c95c9"></a>
Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalSubMutable</b> (Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; &amp;ciphertext1, Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; &amp;ciphertext2) const</td></tr>
<tr class="separator:af3df2677705659414ff6aa87c81c95c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad10ced32e74f99274ae3517f149872d1"><td class="memItemLeft" align="right" valign="top"><a id="ad10ced32e74f99274ae3517f149872d1"></a>
Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalSub</b> (ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ciphertext1, ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ciphertext2) const</td></tr>
<tr class="separator:ad10ced32e74f99274ae3517f149872d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300e862e58826810d00d5de65ff7a594"><td class="memItemLeft" align="right" valign="top"><a id="a300e862e58826810d00d5de65ff7a594"></a>
Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalSub</b> (ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ciphertext, ConstPlaintext plaintext) const</td></tr>
<tr class="separator:a300e862e58826810d00d5de65ff7a594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a540276ae14b03794597c897898e2d62a"><td class="memItemLeft" align="right" valign="top"><a id="a540276ae14b03794597c897898e2d62a"></a>
Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalSubMutable</b> (Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; &amp;ciphertext, Plaintext plaintext) const</td></tr>
<tr class="separator:a540276ae14b03794597c897898e2d62a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc753291a28dab8247f7bacaec6d9526"><td class="memItemLeft" align="right" valign="top"><a id="afc753291a28dab8247f7bacaec6d9526"></a>
Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalMultMutable</b> (Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; &amp;ciphertext1, Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; &amp;ciphertext2) const</td></tr>
<tr class="separator:afc753291a28dab8247f7bacaec6d9526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ebb7c8585f5836158acc4932f9fb865"><td class="memItemLeft" align="right" valign="top"><a id="a3ebb7c8585f5836158acc4932f9fb865"></a>
Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalMult</b> (ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ciphertext1, ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ciphertext2) const</td></tr>
<tr class="separator:a3ebb7c8585f5836158acc4932f9fb865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adba3c325cfbe2c5166a7b98d6cc7381b"><td class="memItemLeft" align="right" valign="top"><a id="adba3c325cfbe2c5166a7b98d6cc7381b"></a>
Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalMultMutable</b> (Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; &amp;ciphertext, Plaintext plaintext) const</td></tr>
<tr class="separator:adba3c325cfbe2c5166a7b98d6cc7381b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbcadedc10ca7540e52e1e1353a5f3db"><td class="memItemLeft" align="right" valign="top"><a id="adbcadedc10ca7540e52e1e1353a5f3db"></a>
Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalMult</b> (ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ciphertext, ConstPlaintext plaintext) const</td></tr>
<tr class="separator:adbcadedc10ca7540e52e1e1353a5f3db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cb3ed569a1983252068d316dc39314b"><td class="memItemLeft" align="right" valign="top"><a id="a7cb3ed569a1983252068d316dc39314b"></a>
Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalLinearWSumMutable</b> (vector&lt; Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&gt; ciphertexts, vector&lt; double &gt; constants) const</td></tr>
<tr class="separator:a7cb3ed569a1983252068d316dc39314b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbeb3bc0eba674c873cef42f6b5d77c3"><td class="memItemLeft" align="right" valign="top"><a id="abbeb3bc0eba674c873cef42f6b5d77c3"></a>
Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalLinearWSum</b> (vector&lt; Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&gt; ciphertexts, vector&lt; double &gt; constants) const</td></tr>
<tr class="separator:abbeb3bc0eba674c873cef42f6b5d77c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8c6ba2e87d7f4fd37baff37b984960f"><td class="memItemLeft" align="right" valign="top"><a id="ac8c6ba2e87d7f4fd37baff37b984960f"></a>
Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalMultAndRelinearize</b> (ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ciphertext1, ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ciphertext2, const vector&lt; LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&gt; &amp;ek) const</td></tr>
<tr class="separator:ac8c6ba2e87d7f4fd37baff37b984960f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e15714a2136a04048cd5c4b63418f8a"><td class="memItemLeft" align="right" valign="top"><a id="a7e15714a2136a04048cd5c4b63418f8a"></a>
Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Relinearize</b> (ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ciphertext, const vector&lt; LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&gt; &amp;ek) const</td></tr>
<tr class="separator:a7e15714a2136a04048cd5c4b63418f8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a044635956b71dcee080d96c44bee0d57"><td class="memItemLeft" align="right" valign="top"><a id="a044635956b71dcee080d96c44bee0d57"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>RelinearizeInPlace</b> (Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; &amp;ciphertext, const vector&lt; LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&gt; &amp;ek) const</td></tr>
<tr class="separator:a044635956b71dcee080d96c44bee0d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a99df5ce87f7b39bbaa3790b3ee0e3f"><td class="memItemLeft" align="right" valign="top"><a id="a0a99df5ce87f7b39bbaa3790b3ee0e3f"></a>
shared_ptr&lt; vector&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">Poly</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalFastRotationPrecompute</b> (ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">Poly</a> &gt; ciphertext) const</td></tr>
<tr class="separator:a0a99df5ce87f7b39bbaa3790b3ee0e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273dc36c8d2c91f5c68d174830820968"><td class="memItemLeft" align="right" valign="top"><a id="a273dc36c8d2c91f5c68d174830820968"></a>
shared_ptr&lt; vector&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">NativePoly</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalFastRotationPrecompute</b> (ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">NativePoly</a> &gt; ciphertext) const</td></tr>
<tr class="separator:a273dc36c8d2c91f5c68d174830820968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abec7ac9fba43b57c8353a426c366fb2b"><td class="memItemLeft" align="right" valign="top"><a id="abec7ac9fba43b57c8353a426c366fb2b"></a>
shared_ptr&lt; vector&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalFastRotationPrecompute</b> (ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ciphertext) const</td></tr>
<tr class="separator:abec7ac9fba43b57c8353a426c366fb2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa74586947fe2ae9d55863682fb1024a4"><td class="memItemLeft" align="right" valign="top"><a id="aa74586947fe2ae9d55863682fb1024a4"></a>
Ciphertext&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">Poly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalFastRotation</b> (ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">Poly</a> &gt; ciphertext, const usint index, const usint m, const shared_ptr&lt; vector&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">Poly</a> &gt;&gt; digits) const</td></tr>
<tr class="separator:aa74586947fe2ae9d55863682fb1024a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedd4f337932c567673c5942ebbf360a3"><td class="memItemLeft" align="right" valign="top"><a id="aedd4f337932c567673c5942ebbf360a3"></a>
Ciphertext&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">NativePoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalFastRotation</b> (ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">NativePoly</a> &gt; ciphertext, const usint index, const usint m, const shared_ptr&lt; vector&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">NativePoly</a> &gt;&gt; digits) const</td></tr>
<tr class="separator:aedd4f337932c567673c5942ebbf360a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f76dfe84aad7c62c4b5cf0661ce00c"><td class="memItemLeft" align="right" valign="top"><a id="aa3f76dfe84aad7c62c4b5cf0661ce00c"></a>
Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalFastRotation</b> (ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ciphertext, const usint index, const usint m, const shared_ptr&lt; vector&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&gt; precomp) const</td></tr>
<tr class="separator:aa3f76dfe84aad7c62c4b5cf0661ce00c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classlbcrypto_1_1LPSHEAlgorithm')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html">lbcrypto::LPSHEAlgorithm&lt; Element &gt;</a></td></tr>
<tr class="memitem:a4a866542a6a9d06b6a2285aec677ea8e inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memItemLeft" align="right" valign="top">virtual Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a4a866542a6a9d06b6a2285aec677ea8e">EvalAdd</a> (ConstCiphertext&lt; Element &gt; ciphertext1, ConstCiphertext&lt; Element &gt; ciphertext2) const</td></tr>
<tr class="separator:a4a866542a6a9d06b6a2285aec677ea8e inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ceeb9d99a1f4cd10e76ab2757ed4c28 inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memItemLeft" align="right" valign="top">virtual Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a8ceeb9d99a1f4cd10e76ab2757ed4c28">EvalMultMany</a> (const vector&lt; Ciphertext&lt; Element &gt;&gt; &amp;cipherTextList, const vector&lt; LPEvalKey&lt; Element &gt;&gt; &amp;evalKeys) const</td></tr>
<tr class="separator:a8ceeb9d99a1f4cd10e76ab2757ed4c28 inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e810519bc50ed1c9123a19952d54ef inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memItemLeft" align="right" valign="top">virtual Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a43e810519bc50ed1c9123a19952d54ef">EvalAddMany</a> (const vector&lt; Ciphertext&lt; Element &gt;&gt; &amp;ctList) const</td></tr>
<tr class="separator:a43e810519bc50ed1c9123a19952d54ef inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdea40a81c38f194e4c8df12b509e684 inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memItemLeft" align="right" valign="top">virtual Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#afdea40a81c38f194e4c8df12b509e684">EvalAddManyInPlace</a> (vector&lt; Ciphertext&lt; Element &gt;&gt; &amp;ctList) const</td></tr>
<tr class="separator:afdea40a81c38f194e4c8df12b509e684 inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4d52f775cfa969542664b2a225e687b inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memItemLeft" align="right" valign="top">virtual Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#ac4d52f775cfa969542664b2a225e687b">AddRandomNoise</a> (ConstCiphertext&lt; Element &gt; ciphertext) const</td></tr>
<tr class="separator:ac4d52f775cfa969542664b2a225e687b inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ac0c879a96a9c701a70029940342914 inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memItemLeft" align="right" valign="top"><a id="a0ac0c879a96a9c701a70029940342914"></a>
virtual Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>KeySwitch</b> (const LPEvalKey&lt; Element &gt; keySwitchHint, ConstCiphertext&lt; Element &gt; cipherText) const</td></tr>
<tr class="separator:a0ac0c879a96a9c701a70029940342914 inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add44ec08a434ab87a239261b9bc363c5 inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memItemLeft" align="right" valign="top">virtual shared_ptr&lt; std::map&lt; usint, LPEvalKey&lt; Element &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#add44ec08a434ab87a239261b9bc363c5">EvalAtIndexKeyGen</a> (const LPPublicKey&lt; Element &gt; publicKey, const LPPrivateKey&lt; Element &gt; origPrivateKey, const std::vector&lt; int32_t &gt; &amp;indexList) const</td></tr>
<tr class="separator:add44ec08a434ab87a239261b9bc363c5 inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7853f777ce62fcd145cca9ac05eabfab inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memItemLeft" align="right" valign="top">virtual Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a7853f777ce62fcd145cca9ac05eabfab">EvalAtIndex</a> (ConstCiphertext&lt; Element &gt; ciphertext, int32_t index, const std::map&lt; usint, LPEvalKey&lt; Element &gt;&gt; &amp;evalAtIndexKeys) const</td></tr>
<tr class="separator:a7853f777ce62fcd145cca9ac05eabfab inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1588b0268068bd450eecc449026f32c9 inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memItemLeft" align="right" valign="top">virtual shared_ptr&lt; std::map&lt; usint, LPEvalKey&lt; Element &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a1588b0268068bd450eecc449026f32c9">EvalSumKeyGen</a> (const LPPrivateKey&lt; Element &gt; privateKey, const LPPublicKey&lt; Element &gt; publicKey) const</td></tr>
<tr class="separator:a1588b0268068bd450eecc449026f32c9 inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17c4f3e667fb6450121250ea6b731de7 inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memItemLeft" align="right" valign="top">virtual shared_ptr&lt; std::map&lt; usint, LPEvalKey&lt; Element &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a17c4f3e667fb6450121250ea6b731de7">EvalSumRowsKeyGen</a> (const LPPrivateKey&lt; Element &gt; privateKey, const LPPublicKey&lt; Element &gt; publicKey, usint rowSize, usint subringDim=0) const</td></tr>
<tr class="separator:a17c4f3e667fb6450121250ea6b731de7 inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a536f096af43190927ed98f4e29795ab4 inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memItemLeft" align="right" valign="top">virtual shared_ptr&lt; std::map&lt; usint, LPEvalKey&lt; Element &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a536f096af43190927ed98f4e29795ab4">EvalSumColsKeyGen</a> (const LPPrivateKey&lt; Element &gt; privateKey, const LPPublicKey&lt; Element &gt; publicKey) const</td></tr>
<tr class="separator:a536f096af43190927ed98f4e29795ab4 inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bf74e67ff749ee150f67bb9b3ee23c3 inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memItemLeft" align="right" valign="top">virtual Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a0bf74e67ff749ee150f67bb9b3ee23c3">EvalSum</a> (ConstCiphertext&lt; Element &gt; ciphertext, usint batchSize, const std::map&lt; usint, LPEvalKey&lt; Element &gt;&gt; &amp;evalKeys) const</td></tr>
<tr class="separator:a0bf74e67ff749ee150f67bb9b3ee23c3 inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ed0dc4a202110d971e9ddddae234cbb inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memItemLeft" align="right" valign="top">virtual Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a3ed0dc4a202110d971e9ddddae234cbb">EvalSumRows</a> (ConstCiphertext&lt; Element &gt; ciphertext, usint rowSize, const std::map&lt; usint, LPEvalKey&lt; Element &gt;&gt; &amp;evalKeys, usint subringDim=0) const</td></tr>
<tr class="separator:a3ed0dc4a202110d971e9ddddae234cbb inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87075af82796b5eecd647c643f6efd73 inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memItemLeft" align="right" valign="top">virtual Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a87075af82796b5eecd647c643f6efd73">EvalSumCols</a> (ConstCiphertext&lt; Element &gt; ciphertext, usint batchSize, const std::map&lt; usint, LPEvalKey&lt; Element &gt;&gt; &amp;evalKeys, const std::map&lt; usint, LPEvalKey&lt; Element &gt;&gt; &amp;rightEvalKeys) const</td></tr>
<tr class="separator:a87075af82796b5eecd647c643f6efd73 inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20e0f28ffdf6ee1b69d9c353198ca249 inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memItemLeft" align="right" valign="top">virtual Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a20e0f28ffdf6ee1b69d9c353198ca249">EvalInnerProduct</a> (ConstCiphertext&lt; Element &gt; ciphertext1, ConstCiphertext&lt; Element &gt; ciphertext2, usint batchSize, const std::map&lt; usint, LPEvalKey&lt; Element &gt;&gt; &amp;evalSumKeys, const LPEvalKey&lt; Element &gt; evalMultKey) const</td></tr>
<tr class="separator:a20e0f28ffdf6ee1b69d9c353198ca249 inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6958a75718823cea8a5f9f9407fa875f inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memItemLeft" align="right" valign="top">virtual Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a6958a75718823cea8a5f9f9407fa875f">EvalInnerProduct</a> (ConstCiphertext&lt; Element &gt; ciphertext1, ConstPlaintext plaintext, usint batchSize, const std::map&lt; usint, LPEvalKey&lt; Element &gt;&gt; &amp;evalSumKeys) const</td></tr>
<tr class="separator:a6958a75718823cea8a5f9f9407fa875f inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bc33751c5140ccc40c1ad8791ff9fab inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memItemLeft" align="right" valign="top">virtual Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a1bc33751c5140ccc40c1ad8791ff9fab">EvalMerge</a> (const vector&lt; Ciphertext&lt; Element &gt;&gt; &amp;ciphertextVector, const std::map&lt; usint, LPEvalKey&lt; Element &gt;&gt; &amp;evalKeys) const</td></tr>
<tr class="separator:a1bc33751c5140ccc40c1ad8791ff9fab inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ae5b028a2ef2e5f7da57c7c37802da66f"><td class="memItemLeft" align="right" valign="top">virtual Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html#ae5b028a2ef2e5f7da57c7c37802da66f">EvalMultApprox</a> (ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ciphertext, ConstPlaintext plaintext) const</td></tr>
<tr class="separator:ae5b028a2ef2e5f7da57c7c37802da66f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa895c19e8fd86ee5875a7ce2520c5ab9"><td class="memItemLeft" align="right" valign="top">Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html#aa895c19e8fd86ee5875a7ce2520c5ab9">EvalAddCorePlaintext</a> (ConstCiphertext&lt; Element &gt; ciphertext, Element ptElement, usint ptDepth) const</td></tr>
<tr class="separator:aa895c19e8fd86ee5875a7ce2520c5ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac073fb7fc63fb84033fa8ff8c0c5df07"><td class="memItemLeft" align="right" valign="top">Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html#ac073fb7fc63fb84033fa8ff8c0c5df07">EvalSubCorePlaintext</a> (ConstCiphertext&lt; Element &gt; ciphertext, Element ptElement, usint ptDepth) const</td></tr>
<tr class="separator:ac073fb7fc63fb84033fa8ff8c0c5df07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9996aff2b82e87d8b9c93869aa58ce47"><td class="memItemLeft" align="right" valign="top">std::pair&lt; shared_ptr&lt; ConstCiphertext&lt; Element &gt; &gt;, Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html#a9996aff2b82e87d8b9c93869aa58ce47">AutomaticLevelReduce</a> (ConstCiphertext&lt; Element &gt; ciphertext, ConstPlaintext plaintext) const</td></tr>
<tr class="separator:a9996aff2b82e87d8b9c93869aa58ce47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a728533046a53019f3b0fba0d92e40e93"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; vector&lt; Element &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html#a728533046a53019f3b0fba0d92e40e93">EvalFastRotationPrecomputeBV</a> (ConstCiphertext&lt; Element &gt; ciphertext) const</td></tr>
<tr class="separator:a728533046a53019f3b0fba0d92e40e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3748ffe2ec0a6faf6ba88c841a343c1f"><td class="memItemLeft" align="right" valign="top">Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html#a3748ffe2ec0a6faf6ba88c841a343c1f">EvalFastRotationBV</a> (ConstCiphertext&lt; Element &gt; ciphertext, const usint index, const usint m, const shared_ptr&lt; vector&lt; Element &gt;&gt; digits, LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; evalKey) const</td></tr>
<tr class="separator:a3748ffe2ec0a6faf6ba88c841a343c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a0254e7e41d03584fc68fd0d496c5a"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; vector&lt; Element &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html#ab5a0254e7e41d03584fc68fd0d496c5a">EvalFastRotationPrecomputeGHS</a> (ConstCiphertext&lt; Element &gt; ciphertext) const</td></tr>
<tr class="separator:ab5a0254e7e41d03584fc68fd0d496c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41973b00e0da06b39136e399a65b094a"><td class="memItemLeft" align="right" valign="top">Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html#a41973b00e0da06b39136e399a65b094a">EvalFastRotationGHS</a> (ConstCiphertext&lt; Element &gt; ciphertext, const usint index, const usint m, const shared_ptr&lt; vector&lt; Element &gt;&gt; expandedCiphertext, LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; evalKey) const</td></tr>
<tr class="separator:a41973b00e0da06b39136e399a65b094a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac083102de2ef153fce9ade404f48c04f"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; vector&lt; Element &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html#ac083102de2ef153fce9ade404f48c04f">EvalFastRotationPrecomputeHybrid</a> (ConstCiphertext&lt; Element &gt; ciphertext) const</td></tr>
<tr class="separator:ac083102de2ef153fce9ade404f48c04f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34a0526942a1af6c168bff8d46ec6dae"><td class="memItemLeft" align="right" valign="top">Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html#a34a0526942a1af6c168bff8d46ec6dae">EvalFastRotationHybrid</a> (ConstCiphertext&lt; Element &gt; ciphertext, const usint index, const usint m, const shared_ptr&lt; vector&lt; Element &gt;&gt; expandedCiphertext, LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; evalKey) const</td></tr>
<tr class="separator:a34a0526942a1af6c168bff8d46ec6dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0261342629ff2abeb287392ef1e382ab"><td class="memItemLeft" align="right" valign="top"><a id="a0261342629ff2abeb287392ef1e382ab"></a>
Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalMultApprox</b> (ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ciphertext, double constant) const</td></tr>
<tr class="separator:a0261342629ff2abeb287392ef1e382ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0261342629ff2abeb287392ef1e382ab"><td class="memItemLeft" align="right" valign="top"><a id="a0261342629ff2abeb287392ef1e382ab"></a>
Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalMultApprox</b> (ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ciphertext, double constant) const</td></tr>
<tr class="separator:a0261342629ff2abeb287392ef1e382ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af129f196e519db272eaf1003580dc1ef"><td class="memItemLeft" align="right" valign="top"><a id="af129f196e519db272eaf1003580dc1ef"></a>
Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalAddCorePlaintext</b> (ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ciphertext, <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> ptxt, usint ptxtDepth) const</td></tr>
<tr class="separator:af129f196e519db272eaf1003580dc1ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c93a1da169d9706ac90f67ddc0cf939"><td class="memItemLeft" align="right" valign="top"><a id="a6c93a1da169d9706ac90f67ddc0cf939"></a>
Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalSubCorePlaintext</b> (ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ciphertext, <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> ptxt, usint ptxtDepth) const</td></tr>
<tr class="separator:a6c93a1da169d9706ac90f67ddc0cf939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b8ff3d889a4a42fb0305f2cae93fd7f"><td class="memItemLeft" align="right" valign="top"><a id="a4b8ff3d889a4a42fb0305f2cae93fd7f"></a>
vector&lt; shared_ptr&lt; ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>AutomaticLevelReduce</b> (ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ciphertext1, ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ciphertext2) const</td></tr>
<tr class="separator:a4b8ff3d889a4a42fb0305f2cae93fd7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc7ea17737c058d0be8ac69990bda1a7"><td class="memItemLeft" align="right" valign="top"><a id="abc7ea17737c058d0be8ac69990bda1a7"></a>
std::pair&lt; shared_ptr&lt; ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; &gt;, <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>AutomaticLevelReduce</b> (ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ciphertext, ConstPlaintext plaintext) const</td></tr>
<tr class="separator:abc7ea17737c058d0be8ac69990bda1a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a284b09492a90665ebb23a7c221a19e2c"><td class="memItemLeft" align="right" valign="top"><a id="a284b09492a90665ebb23a7c221a19e2c"></a>
Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalMultApprox</b> (ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ciphertext1, ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ciphertext2) const</td></tr>
<tr class="separator:a284b09492a90665ebb23a7c221a19e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac65e15ecdfaf6be53c4a0fa3187ff284"><td class="memItemLeft" align="right" valign="top"><a id="ac65e15ecdfaf6be53c4a0fa3187ff284"></a>
Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalMultApprox</b> (ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ciphertext, ConstPlaintext plaintext) const</td></tr>
<tr class="separator:ac65e15ecdfaf6be53c4a0fa3187ff284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bddc34ebbb086aa22f812bfb2a98333"><td class="memItemLeft" align="right" valign="top"><a id="a6bddc34ebbb086aa22f812bfb2a98333"></a>
shared_ptr&lt; vector&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalFastRotationPrecomputeBV</b> (ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ciphertext) const</td></tr>
<tr class="separator:a6bddc34ebbb086aa22f812bfb2a98333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2743ce0a5b1490c5d4b0b172893a8811"><td class="memItemLeft" align="right" valign="top"><a id="a2743ce0a5b1490c5d4b0b172893a8811"></a>
shared_ptr&lt; vector&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalFastRotationPrecomputeGHS</b> (ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ciphertext) const</td></tr>
<tr class="separator:a2743ce0a5b1490c5d4b0b172893a8811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea1eac5b0b9f77cafdc814c882ed064"><td class="memItemLeft" align="right" valign="top"><a id="acea1eac5b0b9f77cafdc814c882ed064"></a>
shared_ptr&lt; vector&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalFastRotationPrecomputeHybrid</b> (ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ciphertext) const</td></tr>
<tr class="separator:acea1eac5b0b9f77cafdc814c882ed064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b0179e2dc9409a5de8ab6f4001dfa61"><td class="memItemLeft" align="right" valign="top"><a id="a4b0179e2dc9409a5de8ab6f4001dfa61"></a>
Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalFastRotationHybrid</b> (ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ciphertext, const usint index, const usint m, const shared_ptr&lt; vector&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&gt; expandedCiphertext, LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; evalKey) const</td></tr>
<tr class="separator:a4b0179e2dc9409a5de8ab6f4001dfa61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc91141fdf185278952f85dabb194675"><td class="memItemLeft" align="right" valign="top"><a id="adc91141fdf185278952f85dabb194675"></a>
Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalFastRotationGHS</b> (ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ciphertext, const usint index, const usint m, const shared_ptr&lt; vector&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&gt; expandedCiphertext, LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; evalKey) const</td></tr>
<tr class="separator:adc91141fdf185278952f85dabb194675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3560a144d1b46129fa2a93799ed17c6a"><td class="memItemLeft" align="right" valign="top"><a id="a3560a144d1b46129fa2a93799ed17c6a"></a>
Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalFastRotationBV</b> (ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ciphertext, const usint index, const usint m, const shared_ptr&lt; vector&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&gt; digits, LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; evalKey) const</td></tr>
<tr class="separator:a3560a144d1b46129fa2a93799ed17c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class Element&gt;<br />
class lbcrypto::LPAlgorithmSHECKKS&lt; Element &gt;</h3>

<p>Class for evaluation of somewhat homomorphic operations.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Element</td><td>a ring element. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="acf57be95906e1ccd0f9c29a10b981213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf57be95906e1ccd0f9c29a10b981213">&#9670;&nbsp;</a></span>LPAlgorithmSHECKKS()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html">lbcrypto::LPAlgorithmSHECKKS</a>&lt; Element &gt;::<a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html">LPAlgorithmSHECKKS</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default constructor </p>

</div>
</div>
<a id="ac2dd71f2b61017403011f7facd6a0638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2dd71f2b61017403011f7facd6a0638">&#9670;&nbsp;</a></span>~LPAlgorithmSHECKKS()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html">lbcrypto::LPAlgorithmSHECKKS</a>&lt; Element &gt;::~<a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html">LPAlgorithmSHECKKS</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac785b87c298c86667c430f7cc5d099a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac785b87c298c86667c430f7cc5d099a5">&#9670;&nbsp;</a></span>AdjustLevelWithoutRescale()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ciphertext&lt;Element&gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html">lbcrypto::LPAlgorithmSHECKKS</a>&lt; Element &gt;::AdjustLevelWithoutRescale </td>
          <td>(</td>
          <td class="paramtype">Ciphertext&lt; Element &gt; &amp;&#160;</td>
          <td class="paramname"><em>ciphertext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>targetLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function used in EXACTRESCALE to change the level of a ciphertext, while at the same time adjusting the scaling factor of the target level. AdjustLevelWithoutRescale assumes input is of depth 1 and output of depth</p><ol type="1">
<li>It performs a rescaling (ModReduce) operation, and is used in addition/subtraction in EXACTRESCALE.</li>
</ol>
<p>Please refer to the AdjustLevelWithRescale documentation to see how EXACTRESCALE works in CKKS.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext</td><td>input ciphertext. </td></tr>
    <tr><td class="paramname">targetLevel</td><td>The number of the level we want to take this ciphertext to. Levels are numbered from 0 (all towers) to GetNumberOfTowers()-1 (one remaining tower). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A ciphertext containing the same value as c1, but at level targetLevel. </dd></dl>

</div>
</div>
<a id="a4d1c52136c0e1aa5537007e154b2cecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d1c52136c0e1aa5537007e154b2cecd">&#9670;&nbsp;</a></span>AdjustLevelWithRescale()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ciphertext&lt;Element&gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html">lbcrypto::LPAlgorithmSHECKKS</a>&lt; Element &gt;::AdjustLevelWithRescale </td>
          <td>(</td>
          <td class="paramtype">Ciphertext&lt; Element &gt; &amp;&#160;</td>
          <td class="paramname"><em>ciphertext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>targetLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function used in EXACTRESCALE to change the level of a ciphertext, while at the same time adjusting the scaling factor of the target level. AdjustLevelWithRescale assumes input is of depth 1 and output of depth 1 too. It performs a rescale (ModReduce) operation to bring the output to the desired depth.</p>
<p>A description of how the EXACTRESCALE version of CKKS works:</p>
<p>Each ciphertext/plaintext is at a given level and depth. Levels correspond to the number of rescaling operations previously performed on the ciphertext (i.e., fresh ciphertexts are of level 0, after one rescale they become level 1 and so on). Plaintexts can be created at any chosen valid level, and ciphertexts inherit the level and depth of the plaintexts they were created with. Depth corresponds to the number of multiplications without rescaling that have been performed. E.g., the product of two ciphertexts of depth 1 is of depth 2, and it becomes depth 1 after we apply a rescaling (mod reduce) operation.</p>
<p>One can think of rescaling in CKKS as dropping a tower and dividing with the modulus corresponding to that tower. For that reason, the rescaling operation slightly changes the scaling factor with which the plaintext is scaled to support real number arithmetic. There are two ways to deal with this: (1) ignore the change in scaling factor and incur an approximation error in the value of the ciphertext, or (2) adjust the value of the scaling factor by performing an EvalMult operation with a double operand. Solution (1) is implemented in the APPROXRESCALE variant of CKKS, and approach (2) in EXACTRESCALE.</p>
<p>In EXACTRESCALE, each level has a particular scaling factor SF_i: Level 0: SF_0 = q_L Level 1: SF_1 = SF_0^2 / q_L = 2^2p / q_L Level 2: SF_2 = SF_1^2 / q_{L-1} = 2^4p / q_L^2 * q_{L-1} ... The scaling factor of level i at depth j is (SF_i)^j.</p>
<p>The selection of scaling factors follows the natural way scaling factors are changed with every multiplication and rescale operation (squared scaling factor divided by tower modulus). However, this is true only if we always multiply ciphertexts that are of depth 1, otherwise we may get scaling factors that do not exactly match the chosen values above. Since this is a good practice anyway, we decided to make this the default behavior in EXACTRESCALE, and therefore we do not allow the user to manually perform rescaling - it is automatically performed whenever the user tries to multiply ciphertexts that are not of depth 1. A side effect of this is that all ciphertexts in CKKS/EXACTRESCALE will be depth 1 or 2 only.</p>
<p>Since levels have different scaling factors, we need to make sure that ciphertexts/plaintexts are adjusted to the correct scaling factor whenever we have an operation between ciphertexts of different levels. This is in general achieved with a multiplication by a double value called an adjustment factor. There are many cases that need to be covered</p><ul>
<li>EvalAdd/Sub/Mult for all possible combinations of valid ciphertexts in the CKKS scheme (i.e., fresh L:i/D:1, or L:i/D:2). This logic is implemented in EvalAdd/Sub/MultMutable and the AdjustLevelWithRescale and AdjustLevelWithoutRescale methods.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext</td><td>input ciphertext. </td></tr>
    <tr><td class="paramname">targetLevel</td><td>The number of the level we want to take this ciphertext to. Levels are numbered from 0 (all towers) to GetNumberOfTowers()-1 (one remaining tower). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A ciphertext containing the same value as c1, but at level targetLevel. </dd></dl>

<p>Reimplemented from <a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html">lbcrypto::LPSHEAlgorithm&lt; Element &gt;</a>.</p>

</div>
</div>
<a id="a9996aff2b82e87d8b9c93869aa58ce47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9996aff2b82e87d8b9c93869aa58ce47">&#9670;&nbsp;</a></span>AutomaticLevelReduce()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;shared_ptr&lt;ConstCiphertext&lt;Element&gt; &gt;, Element&gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html">lbcrypto::LPAlgorithmSHECKKS</a>&lt; Element &gt;::AutomaticLevelReduce </td>
          <td>(</td>
          <td class="paramtype">ConstCiphertext&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>ciphertext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstPlaintext&#160;</td>
          <td class="paramname"><em>plaintext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Internal function to automatically level-reduce a ciphertext and a plaintext.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext1</td><td>input ciphertext. </td></tr>
    <tr><td class="paramname">plaintext</td><td>input plaintext. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector containing two ciphertexts of the same level. </dd></dl>

</div>
</div>
<a id="a9d25262c4f0f46110adf5ffb76a7f198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d25262c4f0f46110adf5ffb76a7f198">&#9670;&nbsp;</a></span>EvalAdd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ciphertext&lt; Element &gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html">lbcrypto::LPAlgorithmSHECKKS</a>&lt; Element &gt;::EvalAdd </td>
          <td>(</td>
          <td class="paramtype">ConstCiphertext&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>ciphertext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstPlaintext&#160;</td>
          <td class="paramname"><em>plaintext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function for homomorphic addition of ciphertexts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext</td><td>input ciphertext. </td></tr>
    <tr><td class="paramname">plaintext</td><td>input plaintext. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result of homomorphic addition of input ciphertexts. </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a521645ed0ef899672cef94a600fbeb00">lbcrypto::LPSHEAlgorithm&lt; Element &gt;</a>.</p>

</div>
</div>
<a id="a5c3ff33753a7595c82fbf2b7b364d07c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c3ff33753a7595c82fbf2b7b364d07c">&#9670;&nbsp;</a></span>EvalAdd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ciphertext&lt; Element &gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html">lbcrypto::LPAlgorithmSHECKKS</a>&lt; Element &gt;::EvalAdd </td>
          <td>(</td>
          <td class="paramtype">ConstCiphertext&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>ciphertext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>constant</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function for adding a constant to a ciphertext.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext</td><td>input ciphertext. </td></tr>
    <tr><td class="paramname">constant</td><td>input constant. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>encrypted result of addition. </dd></dl>

<p>Reimplemented from <a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a1c7df21f729e892880fb63ef8fbfe47b">lbcrypto::LPSHEAlgorithm&lt; Element &gt;</a>.</p>

</div>
</div>
<a id="aa895c19e8fd86ee5875a7ce2520c5ab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa895c19e8fd86ee5875a7ce2520c5ab9">&#9670;&nbsp;</a></span>EvalAddCorePlaintext()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ciphertext&lt;Element&gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html">lbcrypto::LPAlgorithmSHECKKS</a>&lt; Element &gt;::EvalAddCorePlaintext </td>
          <td>(</td>
          <td class="paramtype">ConstCiphertext&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>ciphertext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Element&#160;</td>
          <td class="paramname"><em>ptElement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">usint&#160;</td>
          <td class="paramname"><em>ptDepth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Internal function for homomorphic addition of ciphertext and plaintext. This method does not check whether input ciphertexts are at the same level.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext</td><td>input ciphertext. </td></tr>
    <tr><td class="paramname">ptElement</td><td>the Element corresponding to the input plaintext. </td></tr>
    <tr><td class="paramname">ptDepth</td><td>the scaling factor (depth) of the input plaintext. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result of homomorphic addition of inputs. </dd></dl>

</div>
</div>
<a id="a7199eaa974de78ef546f62dc748ea0ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7199eaa974de78ef546f62dc748ea0ec">&#9670;&nbsp;</a></span>EvalAddInPlace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html">lbcrypto::LPAlgorithmSHECKKS</a>&lt; Element &gt;::EvalAddInPlace </td>
          <td>(</td>
          <td class="paramtype">Ciphertext&lt; Element &gt; &amp;&#160;</td>
          <td class="paramname"><em>ciphertext1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstCiphertext&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>ciphertext2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function for in-place homomorphic addition of ciphertexts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext1</td><td>first input/output ciphertext. </td></tr>
    <tr><td class="paramname">ciphertext2</td><td>second input ciphertext.</td></tr>
  </table>
  </dd>
</dl>
<p><code>ciphertext1</code> stores the result of <code>ciphertext1</code> + <code>ciphertext2</code> </p>

<p>Implements <a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#af37df4903e293cbfa6296ea523b4cfed">lbcrypto::LPSHEAlgorithm&lt; Element &gt;</a>.</p>

</div>
</div>
<a id="a860226466f01bec59935c116d0f8efd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a860226466f01bec59935c116d0f8efd2">&#9670;&nbsp;</a></span>EvalAddMutable() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Ciphertext&lt;Element&gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html">lbcrypto::LPAlgorithmSHECKKS</a>&lt; Element &gt;::EvalAddMutable </td>
          <td>(</td>
          <td class="paramtype">Ciphertext&lt; Element &gt; &amp;&#160;</td>
          <td class="paramname"><em>ciphertext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>constant</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function for adding a constant to a ciphertext. Mutable version - input ciphertexts may get rescaled/level-reduced.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext</td><td>input ciphertext. </td></tr>
    <tr><td class="paramname">constant</td><td>input constant. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>encrypted result of addition. </dd></dl>

</div>
</div>
<a id="a6126c4a7234b4173c06245bcba0b53b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6126c4a7234b4173c06245bcba0b53b7">&#9670;&nbsp;</a></span>EvalAddMutable() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ciphertext&lt;Element&gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html">lbcrypto::LPAlgorithmSHECKKS</a>&lt; Element &gt;::EvalAddMutable </td>
          <td>(</td>
          <td class="paramtype">Ciphertext&lt; Element &gt; &amp;&#160;</td>
          <td class="paramname"><em>ciphertext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Plaintext&#160;</td>
          <td class="paramname"><em>plaintext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function for homomorphic addition of ciphertexts. Mutable version - input ciphertexts may get rescaled/level-reduced.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext</td><td>input ciphertext. </td></tr>
    <tr><td class="paramname">plaintext</td><td>input plaintext. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result of homomorphic addition of input ciphertexts. </dd></dl>

<p>Reimplemented from <a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a97da21c25a0ba8c0c25ffaa3436f9cde">lbcrypto::LPSHEAlgorithm&lt; Element &gt;</a>.</p>

</div>
</div>
<a id="a0b59ca6e30a03093901634136e43b47c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b59ca6e30a03093901634136e43b47c">&#9670;&nbsp;</a></span>EvalAddMutable() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ciphertext&lt;Element&gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html">lbcrypto::LPAlgorithmSHECKKS</a>&lt; Element &gt;::EvalAddMutable </td>
          <td>(</td>
          <td class="paramtype">Ciphertext&lt; Element &gt; &amp;&#160;</td>
          <td class="paramname"><em>ciphertext1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ciphertext&lt; Element &gt; &amp;&#160;</td>
          <td class="paramname"><em>ciphertext2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function for homomorphic addition of ciphertexts. Mutable version - input ciphertexts may get rescaled/level-reduced.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext1</td><td>first input ciphertext. </td></tr>
    <tr><td class="paramname">ciphertext2</td><td>second input ciphertext. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result of homomorphic addition of input ciphertexts. </dd></dl>

<p>Reimplemented from <a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a148a8b5015277696e1a3648dcc60d609">lbcrypto::LPSHEAlgorithm&lt; Element &gt;</a>.</p>

</div>
</div>
<a id="ab347576608143a13fd93315a4974a68b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab347576608143a13fd93315a4974a68b">&#9670;&nbsp;</a></span>EvalAutomorphism()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ciphertext&lt; Element &gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html">lbcrypto::LPAlgorithmSHECKKS</a>&lt; Element &gt;::EvalAutomorphism </td>
          <td>(</td>
          <td class="paramtype">ConstCiphertext&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>ciphertext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">usint&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; usint, LPEvalKey&lt; Element &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>evalKeys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CALLER_INFO_ARGS_HDR&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function for evaluating automorphism of ciphertext at index i</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext</td><td>the input ciphertext. </td></tr>
    <tr><td class="paramname">i</td><td>automorphism index </td></tr>
    <tr><td class="paramname">&amp;evalKeys</td><td>- reference to the map of evaluation keys generated by EvalAutomorphismKeyGen. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>resulting ciphertext </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a82407b88e94e1e64b2f3a915f71e1097">lbcrypto::LPSHEAlgorithm&lt; Element &gt;</a>.</p>

</div>
</div>
<a id="afc46d310f82cdd136649a296c166b774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc46d310f82cdd136649a296c166b774">&#9670;&nbsp;</a></span>EvalAutomorphismKeyGen() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt; std::map&lt; usint, LPEvalKey&lt; Element &gt; &gt; &gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html">lbcrypto::LPAlgorithmSHECKKS</a>&lt; Element &gt;::EvalAutomorphismKeyGen </td>
          <td>(</td>
          <td class="paramtype">const LPPrivateKey&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>privateKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; usint &gt; &amp;&#160;</td>
          <td class="paramname"><em>indexList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generate automophism keys for a given private key; Uses the private key for encryption</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">privateKey</td><td>private key. </td></tr>
    <tr><td class="paramname">indexList</td><td>list of automorphism indices to be computed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns the evaluation keys </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#afd0444d50a9343ac6b15297533b442fa">lbcrypto::LPSHEAlgorithm&lt; Element &gt;</a>.</p>

</div>
</div>
<a id="a4df36c88eb8bbd41bfd41089de83763b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4df36c88eb8bbd41bfd41089de83763b">&#9670;&nbsp;</a></span>EvalAutomorphismKeyGen() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;std::map&lt;usint, LPEvalKey&lt;Element&gt; &gt; &gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html">lbcrypto::LPAlgorithmSHECKKS</a>&lt; Element &gt;::EvalAutomorphismKeyGen </td>
          <td>(</td>
          <td class="paramtype">const LPPublicKey&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>publicKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LPPrivateKey&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>privateKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; usint &gt; &amp;&#160;</td>
          <td class="paramname"><em>indexList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generate automophism keys for a given private key; Uses the public key for encryption</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">publicKey</td><td>public key. </td></tr>
    <tr><td class="paramname">privateKey</td><td>private key. </td></tr>
    <tr><td class="paramname">indexList</td><td>list of automorphism indices to be computed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns the evaluation keys </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a0932abb72f5cdde6bbbb2ce97c3d12e0">lbcrypto::LPSHEAlgorithm&lt; Element &gt;</a>.</p>

</div>
</div>
<a id="a14209690d415e907a9acfba9c4da0e9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14209690d415e907a9acfba9c4da0e9b">&#9670;&nbsp;</a></span>EvalFastRotation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ciphertext&lt;Element&gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html">lbcrypto::LPAlgorithmSHECKKS</a>&lt; Element &gt;::EvalFastRotation </td>
          <td>(</td>
          <td class="paramtype">ConstCiphertext&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>ciphertext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const usint&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const usint&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; vector&lt; Element &gt;&gt;&#160;</td>
          <td class="paramname"><em>precomp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>EvalFastRotation is a wrapper for hoisted automorphism. It decides what version of EvalFastRotation to perform, based on the key switching technique currently used (e.g., BV or GHS key switching).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext</td><td>the input ciphertext to perform the automorphism on </td></tr>
    <tr><td class="paramname">index</td><td>the index of the rotation. Positive indices correspond to left rotations and negative indices correspond to right rotations. </td></tr>
    <tr><td class="paramname">m</td><td>is the cyclotomic order </td></tr>
    <tr><td class="paramname">precomp</td><td>In BV, this is the digit decomposition created by EvalFastRotationPrecomputeBV. In GHS, this is the expanded part of the ciphertext. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a02b3d3037492c7bc5d6102b03e9cc345">lbcrypto::LPSHEAlgorithm&lt; Element &gt;</a>.</p>

</div>
</div>
<a id="a3748ffe2ec0a6faf6ba88c841a343c1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3748ffe2ec0a6faf6ba88c841a343c1f">&#9670;&nbsp;</a></span>EvalFastRotationBV()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ciphertext&lt; Element &gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html">lbcrypto::LPAlgorithmSHECKKS</a>&lt; Element &gt;::EvalFastRotationBV </td>
          <td>(</td>
          <td class="paramtype">ConstCiphertext&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>ciphertext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const usint&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const usint&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; vector&lt; Element &gt;&gt;&#160;</td>
          <td class="paramname"><em>digits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td>
          <td class="paramname"><em>evalKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>EvalFastRotationBV implements the automorphism and key switching step of hoisted automorphisms in the BV key switching scheme.</p>
<p>Please refer to Section 5 of Halevi and Shoup, "Faster Homomorphic
linear transformations in HELib." for more details, link: <a href="https://eprint.iacr.org/2018/244">https://eprint.iacr.org/2018/244</a>.</p>
<p>Generally, automorphisms are performed with three steps: (1) the automorphism is applied on the ciphertext, (2) the automorphed values are decomposed into digits, and (3) key switching is applied to make it possible to further compute on the ciphertext.</p>
<p>Hoisted automorphisms is a technique that performs the digit decomposition for the original ciphertext first, and then performs the automorphism and the key switching on the decomposed digits. The benefit of this is that the digit decomposition is independent of the automorphism rotation index, so it can be reused for multiple different indices. This can greatly improve performance when we have to compute many automorphisms on the same ciphertext. This routinely happens when we do permutations (EvalPermute).</p>
<p>EvalFastRotation implements the automorphism and key swithcing step of hoisted automorphisms.</p>
<p>This method assumes that all required rotation keys exist. This may not be true if we are using baby-step/giant-step key switching. Please refer to Section 5.1 of the above reference and EvalPermuteBGStepHoisted to see how to deal with this issue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext</td><td>the input ciphertext to perform the automorphism on </td></tr>
    <tr><td class="paramname">index</td><td>the index of the rotation. Positive indices correspond to left rotations and negative indices correspond to right rotations. </td></tr>
    <tr><td class="paramname">m</td><td>is the cyclotomic order </td></tr>
    <tr><td class="paramname">digits</td><td>the digit decomposition created by EvalFastRotationPrecompute at the precomputation step. </td></tr>
    <tr><td class="paramname">evalKey</td><td>is the rotation key that corresponds to the index (computed in wrapper EvalFastRotation) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a41973b00e0da06b39136e399a65b094a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41973b00e0da06b39136e399a65b094a">&#9670;&nbsp;</a></span>EvalFastRotationGHS()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ciphertext&lt; Element &gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html">lbcrypto::LPAlgorithmSHECKKS</a>&lt; Element &gt;::EvalFastRotationGHS </td>
          <td>(</td>
          <td class="paramtype">ConstCiphertext&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>ciphertext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const usint&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const usint&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; vector&lt; Element &gt;&gt;&#160;</td>
          <td class="paramname"><em>expandedCiphertext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td>
          <td class="paramname"><em>evalKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>EvalFastRotationGHS implements the automorphism and key switching step of hoisted automorphisms in the GHS key switching scheme.</p>
<p>You can find more information about the GHS key switching technique in "Homomorphic evaluation of the AES circuit (Updated
implementation)" and in "A full RNS variant of approximate
homomorphic encryption" (RNS CKKS paper).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext</td><td>the input ciphertext to perform the automorphism on </td></tr>
    <tr><td class="paramname">index</td><td>the index of the rotation. Positive indices correspond to left rotations and negative indices correspond to right rotations. </td></tr>
    <tr><td class="paramname">m</td><td>is the cyclotomic order </td></tr>
    <tr><td class="paramname">expandedCiphertext</td><td>the result of ModUp on one of the ciphertext parts, which is generated by EvalFastRotationPrecomputeGHS at the precomputation step. </td></tr>
    <tr><td class="paramname">evalKey</td><td>is the rotation key that corresponds to the index (computed in wrapper EvalFastRotation) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a34a0526942a1af6c168bff8d46ec6dae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34a0526942a1af6c168bff8d46ec6dae">&#9670;&nbsp;</a></span>EvalFastRotationHybrid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ciphertext&lt;Element&gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html">lbcrypto::LPAlgorithmSHECKKS</a>&lt; Element &gt;::EvalFastRotationHybrid </td>
          <td>(</td>
          <td class="paramtype">ConstCiphertext&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>ciphertext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const usint&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const usint&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; vector&lt; Element &gt;&gt;&#160;</td>
          <td class="paramname"><em>expandedCiphertext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td>
          <td class="paramname"><em>evalKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>EvalFastRotationHybrid implements the automorphism and key switching step of hoisted automorphisms in the HYBRID key switching scheme.</p>
<p>You can find more information about the HYBRID key switching technique in "Better bootstrapping for approximate homomorphic encryption".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext</td><td>the input ciphertext to perform the automorphism on </td></tr>
    <tr><td class="paramname">index</td><td>the index of the rotation. Positive indices correspond to left rotations and negative indices correspond to right rotations. </td></tr>
    <tr><td class="paramname">m</td><td>is the cyclotomic order </td></tr>
    <tr><td class="paramname">expandedCiphertext</td><td>the result of ModUp and RNS digit decomposition on one of the ciphertext parts, which is generated by EvalFastRotationPrecomputeHybrid at the precomputation step. </td></tr>
    <tr><td class="paramname">evalKey</td><td>is the rotation key that corresponds to the index (computed in wrapper EvalFastRotation) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c0169a86c9bdcf42af3e02fb3654a53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c0169a86c9bdcf42af3e02fb3654a53">&#9670;&nbsp;</a></span>EvalFastRotationPrecompute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;vector&lt;Element&gt; &gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html">lbcrypto::LPAlgorithmSHECKKS</a>&lt; Element &gt;::EvalFastRotationPrecompute </td>
          <td>(</td>
          <td class="paramtype">ConstCiphertext&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>ciphertext</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>EvalFastRotationPrecompute is a wrapper for the hoisted automorphism pre-computation step, in schemes BV, GHS, and Hybrid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext</td><td>the input ciphertext on which to do the precomputation (digit decomposition) </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a726e5f4d7c4d1d41cfa5a9b4762ff6d8">lbcrypto::LPSHEAlgorithm&lt; Element &gt;</a>.</p>

</div>
</div>
<a id="a728533046a53019f3b0fba0d92e40e93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a728533046a53019f3b0fba0d92e40e93">&#9670;&nbsp;</a></span>EvalFastRotationPrecomputeBV()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt; vector&lt; Element &gt; &gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html">lbcrypto::LPAlgorithmSHECKKS</a>&lt; Element &gt;::EvalFastRotationPrecomputeBV </td>
          <td>(</td>
          <td class="paramtype">ConstCiphertext&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>ciphertext</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>EvalFastRotationPrecomputeBV implements the precomputation step of hoisted automorphisms for the BV key switching scheme.</p>
<p>Please refer to Section 5 of Halevi and Shoup, "Faster Homomorphic
linear transformations in HELib." for more details, link: <a href="https://eprint.iacr.org/2018/244">https://eprint.iacr.org/2018/244</a>.</p>
<p>Generally, automorphisms are performed with three steps: (1) the automorphism is applied on the ciphertext, (2) the automorphed values are decomposed into digits, and (3) key switching is applied to make it possible to further compute on the ciphertext.</p>
<p>Hoisted automorphisms is a technique that performs the digit decomposition for the original ciphertext first, and then performs the automorphism and the key switching on the decomposed digits. The benefit of this is that the digit decomposition is independent of the automorphism rotation index, so it can be reused for multiple different indices. This can greatly improve performance when we have to compute many automorphisms on the same ciphertext. This routinely happens when we do permutations (EvalPermute).</p>
<p>EvalFastRotationPrecompute implements the digit decomposition step of hoisted automorphisms.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext</td><td>the input ciphertext on which to do the precomputation (digit decomposition) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab5a0254e7e41d03584fc68fd0d496c5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5a0254e7e41d03584fc68fd0d496c5a">&#9670;&nbsp;</a></span>EvalFastRotationPrecomputeGHS()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt; vector&lt; Element &gt; &gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html">lbcrypto::LPAlgorithmSHECKKS</a>&lt; Element &gt;::EvalFastRotationPrecomputeGHS </td>
          <td>(</td>
          <td class="paramtype">ConstCiphertext&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>ciphertext</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>EvalFastRotationPrecomputeGHS implements the precomputation step of hoisted automorphisms for the GHS key switching scheme.</p>
<p>You can find more information about the GHS key switching technique in "Homomorphic evaluation of the AES circuit (Updated
implementation)" and in "A full RNS variant of approximate
homomorphic encryption" (RNS CKKS paper).</p>
<p>Here, we hoist the first part of key switching (ModUp), and only repeat the remaining steps (multiplication with eval key and ModDown's) for subsequent automorphisms.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext</td><td>the input ciphertext on which to do the precomputation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac083102de2ef153fce9ade404f48c04f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac083102de2ef153fce9ade404f48c04f">&#9670;&nbsp;</a></span>EvalFastRotationPrecomputeHybrid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;vector&lt;Element&gt; &gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html">lbcrypto::LPAlgorithmSHECKKS</a>&lt; Element &gt;::EvalFastRotationPrecomputeHybrid </td>
          <td>(</td>
          <td class="paramtype">ConstCiphertext&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>ciphertext</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>EvalFastRotationPrecomputeHybrid implements the precomputation step of hoisted automorphisms for the HYBRID key switching scheme.</p>
<p>You can find more information about the HYBRID key switching technique in "Better bootstrapping for approximate homomorphic encryption".</p>
<p>Here, we hoist the first part of key switching (ModUp), and the RNS digit decomposition. We repeat the remaining steps for subsequent automorphisms.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext</td><td>the input ciphertext on which to do the precomputation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0bccdbf873e70aa6f13114c81403f526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bccdbf873e70aa6f13114c81403f526">&#9670;&nbsp;</a></span>EvalLinearWSum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ciphertext&lt;Element&gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html">lbcrypto::LPAlgorithmSHECKKS</a>&lt; Element &gt;::EvalLinearWSum </td>
          <td>(</td>
          <td class="paramtype">vector&lt; Ciphertext&lt; Element &gt;&gt;&#160;</td>
          <td class="paramname"><em>ciphertexts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>constants</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function for computing the linear weighted sum of a vector of ciphertexts. It is implemented as a wrapper to EvalLinearWSumMutable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertexts</td><td>vector of input ciphertexts. </td></tr>
    <tr><td class="paramname">constants</td><td>vector containing double weights. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A ciphertext containing the linear weighted sum. </dd></dl>

<p>Reimplemented from <a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#aa75fdb1b75ea93c1122de6a14c8a6d6a">lbcrypto::LPSHEAlgorithm&lt; Element &gt;</a>.</p>

</div>
</div>
<a id="ab86bba14cf675f8bdc978134c065b211"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab86bba14cf675f8bdc978134c065b211">&#9670;&nbsp;</a></span>EvalLinearWSumMutable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ciphertext&lt;Element&gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html">lbcrypto::LPAlgorithmSHECKKS</a>&lt; Element &gt;::EvalLinearWSumMutable </td>
          <td>(</td>
          <td class="paramtype">vector&lt; Ciphertext&lt; Element &gt;&gt;&#160;</td>
          <td class="paramname"><em>ciphertexts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>constants</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function for computing the linear weighted sum of a vector of ciphertexts. This is a mutable method, meaning that the level/depth of input ciphertexts may change.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertexts</td><td>vector of input ciphertexts. </td></tr>
    <tr><td class="paramname">constants</td><td>vector containing double weights. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A ciphertext containing the linear weighted sum. </dd></dl>

<p>Reimplemented from <a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a6f31c48c4930e31db2b4f5e282584b08">lbcrypto::LPSHEAlgorithm&lt; Element &gt;</a>.</p>

</div>
</div>
<a id="acd5f61036257d1076449e13ffd0d9dbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd5f61036257d1076449e13ffd0d9dbf">&#9670;&nbsp;</a></span>EvalMult() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ciphertext&lt; Element &gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html">lbcrypto::LPAlgorithmSHECKKS</a>&lt; Element &gt;::EvalMult </td>
          <td>(</td>
          <td class="paramtype">ConstCiphertext&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>ciphertext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstPlaintext&#160;</td>
          <td class="paramname"><em>plaintext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function for multiplying ciphertext by plaintext.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext</td><td>input ciphertext. </td></tr>
    <tr><td class="paramname">plaintext</td><td>input plaintext embedded in the cryptocontext. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result of the multiplication. </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a21718c52f7f42b8e9655d932fa99ff4b">lbcrypto::LPSHEAlgorithm&lt; Element &gt;</a>.</p>

</div>
</div>
<a id="a0f5a3970ef9acb282c00125acd8ebce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f5a3970ef9acb282c00125acd8ebce6">&#9670;&nbsp;</a></span>EvalMult() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ciphertext&lt; Element &gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html">lbcrypto::LPAlgorithmSHECKKS</a>&lt; Element &gt;::EvalMult </td>
          <td>(</td>
          <td class="paramtype">ConstCiphertext&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>ciphertext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>constant</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function for multiplying a ciphertext by a constant.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext</td><td>input ciphertext. </td></tr>
    <tr><td class="paramname">constant</td><td>input constant. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>encrypted result of multiplication. </dd></dl>

<p>Reimplemented from <a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a0350070067a4e946aeef13e4319c4a5f">lbcrypto::LPSHEAlgorithm&lt; Element &gt;</a>.</p>

</div>
</div>
<a id="a7e84c4d2606c28d80ef29a9b075a367e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e84c4d2606c28d80ef29a9b075a367e">&#9670;&nbsp;</a></span>EvalMult() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ciphertext&lt; Element &gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html">lbcrypto::LPAlgorithmSHECKKS</a>&lt; Element &gt;::EvalMult </td>
          <td>(</td>
          <td class="paramtype">ConstCiphertext&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>ciphertext1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstCiphertext&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>ciphertext2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function for homomorphic multiplication of ciphertexts without key switching. Currently it assumes that the input arguments are fresh ciphertexts (of depth 1). Support for the input ciphertexts of higher depths will be added later.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext1</td><td>first input ciphertext. </td></tr>
    <tr><td class="paramname">ciphertext2</td><td>second input ciphertext. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result of homomorphic multiplication of input ciphertexts. </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a9b97098eb1ca1546361184260cc8795f">lbcrypto::LPSHEAlgorithm&lt; Element &gt;</a>.</p>

</div>
</div>
<a id="a7af7a9efdabd08780b3f2aec49164c5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7af7a9efdabd08780b3f2aec49164c5d">&#9670;&nbsp;</a></span>EvalMult() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ciphertext&lt; Element &gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html">lbcrypto::LPAlgorithmSHECKKS</a>&lt; Element &gt;::EvalMult </td>
          <td>(</td>
          <td class="paramtype">ConstCiphertext&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>ciphertext1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstCiphertext&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>ciphertext2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LPEvalKey&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>ek</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function for homomorphic multiplication of ciphertexts followed by key switching operation. Currently it assumes that the input arguments are fresh ciphertexts (of depth 1). Support for the input ciphertexts of higher depths will be added later.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext1</td><td>first input ciphertext. </td></tr>
    <tr><td class="paramname">ciphertext2</td><td>second input ciphertext. </td></tr>
    <tr><td class="paramname">ek</td><td>is the evaluation key to make the newCiphertext decryptable by the same secret key as that of ciphertext1 and ciphertext2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result of homomorphic multiplication of input ciphertexts. </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a8add5c666b7d85b9c64446fc86bfd74d">lbcrypto::LPSHEAlgorithm&lt; Element &gt;</a>.</p>

</div>
</div>
<a id="a96496c8636e1f2f14223b564c4de6c54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96496c8636e1f2f14223b564c4de6c54">&#9670;&nbsp;</a></span>EvalMultAndRelinearize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ciphertext&lt;Element&gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html">lbcrypto::LPAlgorithmSHECKKS</a>&lt; Element &gt;::EvalMultAndRelinearize </td>
          <td>(</td>
          <td class="paramtype">ConstCiphertext&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>ciphertext1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstCiphertext&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>ciphertext2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; LPEvalKey&lt; Element &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>ek</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unimplemented function to support a multiplication with depth larger than 2 for the CKKS scheme.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext1</td><td>The first input ciphertext. </td></tr>
    <tr><td class="paramname">ciphertext2</td><td>The second input ciphertext. </td></tr>
    <tr><td class="paramname">ek</td><td>The evaluation key input. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to the ciphertext which is the EvalMult of the two inputs. </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a3b498d9706dba8d30109d3286500cb66">lbcrypto::LPSHEAlgorithm&lt; Element &gt;</a>.</p>

</div>
</div>
<a id="ae5b028a2ef2e5f7da57c7c37802da66f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5b028a2ef2e5f7da57c7c37802da66f">&#9670;&nbsp;</a></span>EvalMultApprox()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Ciphertext&lt;<a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a>&gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html">lbcrypto::LPAlgorithmSHECKKS</a>&lt; Element &gt;::EvalMultApprox </td>
          <td>(</td>
          <td class="paramtype">ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td>
          <td class="paramname"><em>ciphertext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstPlaintext&#160;</td>
          <td class="paramname"><em>plaintext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Internal function for multiplying a ciphertext by a plaintext in the APPROXRESCALE variant.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext</td><td>input ciphertext. </td></tr>
    <tr><td class="paramname">constant</td><td>input constant. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>encrypted result of multiplication. </dd></dl>

</div>
</div>
<a id="a959b4624c257eabccc83aca950e24515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a959b4624c257eabccc83aca950e24515">&#9670;&nbsp;</a></span>EvalMultKeyGen()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LPEvalKey&lt; Element &gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html">lbcrypto::LPAlgorithmSHECKKS</a>&lt; Element &gt;::EvalMultKeyGen </td>
          <td>(</td>
          <td class="paramtype">const LPPrivateKey&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>privateKey</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function to generate key switch hint on a ciphertext for depth 2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">privateKey</td><td>is the original private key used for generating ciphertext. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>keySwitchHint generated to switch the ciphertext. </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#aae7b86cdc3fe5d8314ddecea43c4151a">lbcrypto::LPSHEAlgorithm&lt; Element &gt;</a>.</p>

</div>
</div>
<a id="a6e56bf8b0c4a5c6143ff2038a4563c3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e56bf8b0c4a5c6143ff2038a4563c3c">&#9670;&nbsp;</a></span>EvalMultKeysGen()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; LPEvalKey&lt; Element &gt; &gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html">lbcrypto::LPAlgorithmSHECKKS</a>&lt; Element &gt;::EvalMultKeysGen </td>
          <td>(</td>
          <td class="paramtype">const LPPrivateKey&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>privateKey</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function to generate key switch hint on a ciphertext for depth more than 2. Currently this method is not supported for CKKS.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">privateKey</td><td>is the original private key used for generating ciphertext. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>keySwitchHint generated to switch the ciphertext. </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a93e53f262a9425036ad20b6dc51f19f1">lbcrypto::LPSHEAlgorithm&lt; Element &gt;</a>.</p>

</div>
</div>
<a id="a99f708fe6d342983d0fc722a74901d71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99f708fe6d342983d0fc722a74901d71">&#9670;&nbsp;</a></span>EvalMultMutable() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ciphertext&lt;Element&gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html">lbcrypto::LPAlgorithmSHECKKS</a>&lt; Element &gt;::EvalMultMutable </td>
          <td>(</td>
          <td class="paramtype">Ciphertext&lt; Element &gt; &amp;&#160;</td>
          <td class="paramname"><em>ciphertext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>constant</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function for multiplying a ciphertext by a constant. Mutable version - input ciphertexts may get rescaled/level-reduced.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext</td><td>input ciphertext. </td></tr>
    <tr><td class="paramname">constant</td><td>input constant. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>encrypted result of multiplication. </dd></dl>

<p>Reimplemented from <a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#ab1f131758ff8c65224c81e271be9b322">lbcrypto::LPSHEAlgorithm&lt; Element &gt;</a>.</p>

</div>
</div>
<a id="afdbde626ed0cc1758f8e011085ebfeb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdbde626ed0cc1758f8e011085ebfeb2">&#9670;&nbsp;</a></span>EvalMultMutable() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ciphertext&lt;Element&gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html">lbcrypto::LPAlgorithmSHECKKS</a>&lt; Element &gt;::EvalMultMutable </td>
          <td>(</td>
          <td class="paramtype">Ciphertext&lt; Element &gt; &amp;&#160;</td>
          <td class="paramname"><em>ciphertext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Plaintext&#160;</td>
          <td class="paramname"><em>plaintext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function for multiplying ciphertext by plaintext. Mutable version - input ciphertexts may get rescaled/level-reduced.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext</td><td>input ciphertext. </td></tr>
    <tr><td class="paramname">plaintext</td><td>input plaintext embedded in the cryptocontext. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result of the multiplication. </dd></dl>

<p>Reimplemented from <a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a07a3b2a149d88352528688002a9e41f2">lbcrypto::LPSHEAlgorithm&lt; Element &gt;</a>.</p>

</div>
</div>
<a id="a525ddb495ab8c15ff92d21c8edf6bf23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a525ddb495ab8c15ff92d21c8edf6bf23">&#9670;&nbsp;</a></span>EvalMultMutable() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ciphertext&lt;Element&gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html">lbcrypto::LPAlgorithmSHECKKS</a>&lt; Element &gt;::EvalMultMutable </td>
          <td>(</td>
          <td class="paramtype">Ciphertext&lt; Element &gt; &amp;&#160;</td>
          <td class="paramname"><em>ciphertext1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ciphertext&lt; Element &gt; &amp;&#160;</td>
          <td class="paramname"><em>ciphertext2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function for homomorphic multiplication of ciphertexts without key switching. Mutable version - input ciphertexts may get rescaled/level-reduced.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext1</td><td>first input ciphertext. </td></tr>
    <tr><td class="paramname">ciphertext2</td><td>second input ciphertext. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result of homomorphic multiplication of input ciphertexts. </dd></dl>

<p>Reimplemented from <a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#aded587cc01ebe2a4871d1cbe55c0cfca">lbcrypto::LPSHEAlgorithm&lt; Element &gt;</a>.</p>

</div>
</div>
<a id="a5f72dada39a7f1c72331dfe868047699"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f72dada39a7f1c72331dfe868047699">&#9670;&nbsp;</a></span>EvalMultMutable() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ciphertext&lt; Element &gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html">lbcrypto::LPAlgorithmSHECKKS</a>&lt; Element &gt;::EvalMultMutable </td>
          <td>(</td>
          <td class="paramtype">Ciphertext&lt; Element &gt; &amp;&#160;</td>
          <td class="paramname"><em>ciphertext1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ciphertext&lt; Element &gt; &amp;&#160;</td>
          <td class="paramname"><em>ciphertext2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LPEvalKey&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>ek</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function for homomorphic multiplication of ciphertexts followed by key switching operation. Mutable version - input ciphertexts may get rescaled/level-reduced.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext1</td><td>first input ciphertext. </td></tr>
    <tr><td class="paramname">ciphertext2</td><td>second input ciphertext. </td></tr>
    <tr><td class="paramname">ek</td><td>is the evaluation key to make the newCiphertext decryptable by the same secret key as that of ciphertext1 and ciphertext2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result of homomorphic multiplication of input ciphertexts. </dd></dl>

<p>Reimplemented from <a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#ab57887f3c759a5ffdb8a2db397b95703">lbcrypto::LPSHEAlgorithm&lt; Element &gt;</a>.</p>

</div>
</div>
<a id="a4d6bcdce7784364320fdaf01bdab737a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d6bcdce7784364320fdaf01bdab737a">&#9670;&nbsp;</a></span>EvalNegate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ciphertext&lt; Element &gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html">lbcrypto::LPAlgorithmSHECKKS</a>&lt; Element &gt;::EvalNegate </td>
          <td>(</td>
          <td class="paramtype">ConstCiphertext&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>ct</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function for homomorphic negation of ciphertexts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ct</td><td>first input ciphertext. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new ciphertext. </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a474e102a7dd4dbe3cf62b9231e0528e2">lbcrypto::LPSHEAlgorithm&lt; Element &gt;</a>.</p>

</div>
</div>
<a id="a2aacccdcfbaf47f4522b3636e2ad3a4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aacccdcfbaf47f4522b3636e2ad3a4f">&#9670;&nbsp;</a></span>EvalSub() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ciphertext&lt; Element &gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html">lbcrypto::LPAlgorithmSHECKKS</a>&lt; Element &gt;::EvalSub </td>
          <td>(</td>
          <td class="paramtype">ConstCiphertext&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>ciphertext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>constant</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function for subtracting a constant from a ciphertext.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext</td><td>input ciphertext. </td></tr>
    <tr><td class="paramname">constant</td><td>input constant. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>encrypted result of substraction. </dd></dl>

<p>Reimplemented from <a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#af8e724b97c7b847ea070b384ee89ee2d">lbcrypto::LPSHEAlgorithm&lt; Element &gt;</a>.</p>

</div>
</div>
<a id="a521206ba8fa58ae54b2687efe56d9bac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a521206ba8fa58ae54b2687efe56d9bac">&#9670;&nbsp;</a></span>EvalSub() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ciphertext&lt; Element &gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html">lbcrypto::LPAlgorithmSHECKKS</a>&lt; Element &gt;::EvalSub </td>
          <td>(</td>
          <td class="paramtype">ConstCiphertext&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>ciphertext1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstCiphertext&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>ciphertext2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function for homomorphic subtraction of ciphertexts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext1</td><td>the input ciphertext. </td></tr>
    <tr><td class="paramname">ciphertext2</td><td>the input ciphertext. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result of homomorphic subtraction of input ciphertexts. </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a9a0a68edacc9a85ae5e8316dd888e4c0">lbcrypto::LPSHEAlgorithm&lt; Element &gt;</a>.</p>

</div>
</div>
<a id="a81323981d249465bb59d56ce80751ba2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81323981d249465bb59d56ce80751ba2">&#9670;&nbsp;</a></span>EvalSub() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ciphertext&lt; Element &gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html">lbcrypto::LPAlgorithmSHECKKS</a>&lt; Element &gt;::EvalSub </td>
          <td>(</td>
          <td class="paramtype">ConstCiphertext&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>ciphertext1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstPlaintext&#160;</td>
          <td class="paramname"><em>plaintext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function for homomorphic subtraction of ciphertexts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext1</td><td>the input ciphertext. </td></tr>
    <tr><td class="paramname">plaintext</td><td>the input plaintext. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result of homomorphic subtraction of input ciphertexts. </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#aad4813fd23d4c2f63a73e4addda5b4a4">lbcrypto::LPSHEAlgorithm&lt; Element &gt;</a>.</p>

</div>
</div>
<a id="ac073fb7fc63fb84033fa8ff8c0c5df07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac073fb7fc63fb84033fa8ff8c0c5df07">&#9670;&nbsp;</a></span>EvalSubCorePlaintext()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ciphertext&lt;Element&gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html">lbcrypto::LPAlgorithmSHECKKS</a>&lt; Element &gt;::EvalSubCorePlaintext </td>
          <td>(</td>
          <td class="paramtype">ConstCiphertext&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>ciphertext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Element&#160;</td>
          <td class="paramname"><em>ptElement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">usint&#160;</td>
          <td class="paramname"><em>ptDepth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Internal function for homomorphic subtraction of ciphertext and plaintext. This method does not check whether input ciphertexts are at the same level.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext</td><td>input ciphertext. </td></tr>
    <tr><td class="paramname">ptElement</td><td>the Element corresponding to the input plaintext. </td></tr>
    <tr><td class="paramname">ptDepth</td><td>the scaling factor (depth) of the input plaintext. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result of homomorphic subtraction of inputs. </dd></dl>

</div>
</div>
<a id="aa3ff339fe511166d5cd848f3eb50dced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3ff339fe511166d5cd848f3eb50dced">&#9670;&nbsp;</a></span>EvalSubMutable() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Ciphertext&lt;Element&gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html">lbcrypto::LPAlgorithmSHECKKS</a>&lt; Element &gt;::EvalSubMutable </td>
          <td>(</td>
          <td class="paramtype">Ciphertext&lt; Element &gt; &amp;&#160;</td>
          <td class="paramname"><em>ciphertext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>constant</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function for subtracting a constant from a ciphertext. Mutable version - input ciphertexts may get rescaled/level-reduced.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext</td><td>input ciphertext. </td></tr>
    <tr><td class="paramname">constant</td><td>input constant. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>encrypted result of substraction. </dd></dl>

</div>
</div>
<a id="abcf28d1ffc715d2789338f9666dd542f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcf28d1ffc715d2789338f9666dd542f">&#9670;&nbsp;</a></span>EvalSubMutable() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ciphertext&lt;Element&gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html">lbcrypto::LPAlgorithmSHECKKS</a>&lt; Element &gt;::EvalSubMutable </td>
          <td>(</td>
          <td class="paramtype">Ciphertext&lt; Element &gt; &amp;&#160;</td>
          <td class="paramname"><em>ciphertext1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ciphertext&lt; Element &gt; &amp;&#160;</td>
          <td class="paramname"><em>ciphertext2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function for homomorphic subtraction of ciphertexts. Mutable version - input ciphertexts may get rescaled/level-reduced.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext1</td><td>the input ciphertext. </td></tr>
    <tr><td class="paramname">ciphertext2</td><td>the input ciphertext. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result of homomorphic subtraction of input ciphertexts. </dd></dl>

<p>Reimplemented from <a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#add2d781c7631781d0e8c10e9a4abeee1">lbcrypto::LPSHEAlgorithm&lt; Element &gt;</a>.</p>

</div>
</div>
<a id="a857f33870ee1bf72f936ece50621da7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a857f33870ee1bf72f936ece50621da7a">&#9670;&nbsp;</a></span>EvalSubMutable() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ciphertext&lt;Element&gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html">lbcrypto::LPAlgorithmSHECKKS</a>&lt; Element &gt;::EvalSubMutable </td>
          <td>(</td>
          <td class="paramtype">Ciphertext&lt; Element &gt; &amp;&#160;</td>
          <td class="paramname"><em>ciphertext1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Plaintext&#160;</td>
          <td class="paramname"><em>plaintext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function for homomorphic subtraction of ciphertexts. Mutable version - input ciphertexts may get rescaled/level-reduced.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext1</td><td>the input ciphertext. </td></tr>
    <tr><td class="paramname">plaintext</td><td>the input plaintext. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result of homomorphic subtraction of input ciphertexts. </dd></dl>

<p>Reimplemented from <a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a927bf565210960bf3e782cb8a8dabfce">lbcrypto::LPSHEAlgorithm&lt; Element &gt;</a>.</p>

</div>
</div>
<a id="a7ec8b42d38197a25523d0e22df276ac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ec8b42d38197a25523d0e22df276ac6">&#9670;&nbsp;</a></span>KeySwitchBVGen()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">LPEvalKey&lt;Element&gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html">lbcrypto::LPAlgorithmSHECKKS</a>&lt; Element &gt;::KeySwitchBVGen </td>
          <td>(</td>
          <td class="paramtype">const LPPrivateKey&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>oldKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LPPrivateKey&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>newKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td>
          <td class="paramname"><em>ek</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Method for generating a key switch matrix for BV key switching. BV key switching was introduced in Brakerski, et. al., "Efficient
full homomorphic encryption from (standard) LWE". Here, we follow Section 3.2 of "(Leveled) fully homomorphic encryption without
bootstrapping" (BGV paper).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oldKey</td><td>Original private key used for encryption. </td></tr>
    <tr><td class="paramname">newKey</td><td>New private key to generate the keyswitch hint. </td></tr>
    <tr><td class="paramname">ek</td><td>The evaluation key input. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>resulting keySwitchHint. </dd></dl>

</div>
</div>
<a id="a3acc8e313e63ac0641acc75502a0f057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3acc8e313e63ac0641acc75502a0f057">&#9670;&nbsp;</a></span>KeySwitchBVInPlace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html">lbcrypto::LPAlgorithmSHECKKS</a>&lt; Element &gt;::KeySwitchBVInPlace </td>
          <td>(</td>
          <td class="paramtype">const LPEvalKey&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>keySwitchHint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ciphertext&lt; Element &gt; &amp;&#160;</td>
          <td class="paramname"><em>ciphertext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Method for in-place key switching using the BV method introduced in Brakerski, et. al., "Efficient full homomorphic encryption from (standard)
LWE". Here, we follow Section 3.2 of "(Leveled) fully homomorphic
encryption without bootstrapping" (BGV paper).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keySwitchHint</td><td>Hint required to perform the ciphertext switching. </td></tr>
    <tr><td class="paramname">ciphertext</td><td>Original ciphertext to perform in-place key switching on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae8b99ba4b5173b50118a11be1a1a8bc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8b99ba4b5173b50118a11be1a1a8bc5">&#9670;&nbsp;</a></span>KeySwitchGen()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LPEvalKey&lt; Element &gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html">lbcrypto::LPAlgorithmSHECKKS</a>&lt; Element &gt;::KeySwitchGen </td>
          <td>(</td>
          <td class="paramtype">const LPPrivateKey&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>oldKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LPPrivateKey&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>newKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Method for generating a KeySwitchHint using RLWE relinearization</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oldKey</td><td>Original private key used for encryption. </td></tr>
    <tr><td class="paramname">newKey</td><td>New private key to generate the keyswitch hint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>resulting keySwitchHint. </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a959c7121202113e5cdd7a76599ca2560">lbcrypto::LPSHEAlgorithm&lt; Element &gt;</a>.</p>

</div>
</div>
<a id="a60fd5c558fd04921f6067cb81763aa8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60fd5c558fd04921f6067cb81763aa8e">&#9670;&nbsp;</a></span>KeySwitchGHSGen()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">LPEvalKey&lt; Element &gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html">lbcrypto::LPAlgorithmSHECKKS</a>&lt; Element &gt;::KeySwitchGHSGen </td>
          <td>(</td>
          <td class="paramtype">const LPPrivateKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td>
          <td class="paramname"><em>oldKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LPPrivateKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td>
          <td class="paramname"><em>newKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td>
          <td class="paramname"><em>ek</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Method for generating a key switch matrix for GHS key switching. GHS key switching was introduced in Gentry, et. al., "Homomorphic
evaluation of the AES circuit (Updated implementation)". Here, we follow the notation of Section 3.2 of "A full RNS variant of
approximate homomorphic encryption" (RNS CKKS paper).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oldKey</td><td>Original private key used for encryption. </td></tr>
    <tr><td class="paramname">newKey</td><td>New private key to generate the keyswitch hint. </td></tr>
    <tr><td class="paramname">ek</td><td>The evaluation key input. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>resulting keySwitchHint. </dd></dl>

</div>
</div>
<a id="a658367f8d904bb4ef21d74ec2727eb5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a658367f8d904bb4ef21d74ec2727eb5a">&#9670;&nbsp;</a></span>KeySwitchGHSInPlace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html">lbcrypto::LPAlgorithmSHECKKS</a>&lt; Element &gt;::KeySwitchGHSInPlace </td>
          <td>(</td>
          <td class="paramtype">const LPEvalKey&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>keySwitchHint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ciphertext&lt; Element &gt; &amp;&#160;</td>
          <td class="paramname"><em>ciphertext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Method for in-place key switching using the GHS method introduced in Gentry, et. al., "Homomorphic evaluation of the AES circuit (Updated
implementation)". Here, we follow the notation of Section 3.2 of "A full RNS variant of approximate homomorphic encryption" (RNS CKKS paper).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keySwitchHint</td><td>Hint required to perform the ciphertext switching. </td></tr>
    <tr><td class="paramname">ciphertext</td><td>Original ciphertext to perform switching on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf9a99072d2785328ab947c5094c91e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf9a99072d2785328ab947c5094c91e8">&#9670;&nbsp;</a></span>KeySwitchHybridGen()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LPEvalKey&lt;Element&gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html">lbcrypto::LPAlgorithmSHECKKS</a>&lt; Element &gt;::KeySwitchHybridGen </td>
          <td>(</td>
          <td class="paramtype">const LPPrivateKey&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>oldKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LPPrivateKey&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>newKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td>
          <td class="paramname"><em>ek</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Method for generating a key switch matrix for HYBRID key switching. HYBRID key switching is described in Section 3 of Han, et. al., "Better bootstrapping for approximate homomorphic encryption".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oldKey</td><td>Original private key used for encryption. </td></tr>
    <tr><td class="paramname">newKey</td><td>New private key to generate the keyswitch hint. </td></tr>
    <tr><td class="paramname">ek</td><td>The evaluation key input. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>resulting keySwitchHint. </dd></dl>

</div>
</div>
<a id="a019eb93ac0e2bb99d41c1c3f3927e02f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a019eb93ac0e2bb99d41c1c3f3927e02f">&#9670;&nbsp;</a></span>KeySwitchHybridInPlace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html">lbcrypto::LPAlgorithmSHECKKS</a>&lt; Element &gt;::KeySwitchHybridInPlace </td>
          <td>(</td>
          <td class="paramtype">const LPEvalKey&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>keySwitchHint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ciphertext&lt; Element &gt; &amp;&#160;</td>
          <td class="paramname"><em>ciphertext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Method for in-place key switching using the HYBRID method. HYBRID key switching is described in Section 3 of Han, et. al., "Better bootstrapping
for approximate homomorphic encryption". </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keySwitchHint</td><td>Hint required to perform the ciphertext switching. </td></tr>
    <tr><td class="paramname">ciphertext</td><td>Original ciphertext to perform in-place key switching on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0284cd94582a0cdc6160a5e889380eea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0284cd94582a0cdc6160a5e889380eea">&#9670;&nbsp;</a></span>KeySwitchInPlace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html">lbcrypto::LPAlgorithmSHECKKS</a>&lt; Element &gt;::KeySwitchInPlace </td>
          <td>(</td>
          <td class="paramtype">const LPEvalKey&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>keySwitchHint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ciphertext&lt; Element &gt; &amp;&#160;</td>
          <td class="paramname"><em>ciphertext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Method for KeySwitching based on a KeySwitchHint - uses the RLWE relinearization</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keySwitchHint</td><td>Hint required to perform the ciphertext switching. </td></tr>
    <tr><td class="paramname">ciphertext</td><td>Original ciphertext to perform switching on. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#ac167477b1ce06546209a93c3579302b6">lbcrypto::LPSHEAlgorithm&lt; Element &gt;</a>.</p>

</div>
</div>
<a id="ad74d167a7a3523ee78efc3cf9c48cc37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad74d167a7a3523ee78efc3cf9c48cc37">&#9670;&nbsp;</a></span>Relinearize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ciphertext&lt;Element&gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html">lbcrypto::LPAlgorithmSHECKKS</a>&lt; Element &gt;::Relinearize </td>
          <td>(</td>
          <td class="paramtype">ConstCiphertext&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>ciphertext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; LPEvalKey&lt; Element &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>ek</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Virtual function to do relinearization</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext</td><td>input ciphertext. </td></tr>
    <tr><td class="paramname">ek</td><td>are the evaluation keys to make the newCiphertext decryptable by the same secret key as that of ciphertext1 and ciphertext2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new resulting ciphertext. </dd></dl>

<p>Reimplemented from <a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#ac627acbd61ff31b65faa3894315e49b2">lbcrypto::LPSHEAlgorithm&lt; Element &gt;</a>.</p>

</div>
</div>
<a id="aa945686a01ec846b32831583fab2e790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa945686a01ec846b32831583fab2e790">&#9670;&nbsp;</a></span>RelinearizeInPlace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlbcrypto_1_1LPAlgorithmSHECKKS.html">lbcrypto::LPAlgorithmSHECKKS</a>&lt; Element &gt;::RelinearizeInPlace </td>
          <td>(</td>
          <td class="paramtype">Ciphertext&lt; Element &gt; &amp;&#160;</td>
          <td class="paramname"><em>ciphertext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; LPEvalKey&lt; Element &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>ek</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Virtual function to do in-place relinearization</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;ciphertext</td><td>input ciphertext. </td></tr>
    <tr><td class="paramname">ek</td><td>are the evaluation keys </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new resulting ciphertext. </dd></dl>

<p>Reimplemented from <a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a25753c8e6d9cf8598b91e38e9aca7e97">lbcrypto::LPSHEAlgorithm&lt; Element &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/pke/include/scheme/ckks/<a class="el" href="ckks_8h_source.html">ckks.h</a></li>
<li>src/pke/lib/scheme/ckks/ckks.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jan 19 2022 20:29:14 for PALISADE Lattice Crypto Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
