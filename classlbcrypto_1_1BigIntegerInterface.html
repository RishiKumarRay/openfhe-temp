<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PALISADE Lattice Crypto Library: lbcrypto::BigIntegerInterface&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PALISADE Lattice Crypto Library
   &#160;<span id="projectnumber">1.11.5</span>
   </div>
   <div id="projectbrief">A lattice crypto library for software engineers by software engineers.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelbcrypto.html">lbcrypto</a></li><li class="navelem"><a class="el" href="classlbcrypto_1_1BigIntegerInterface.html">BigIntegerInterface</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classlbcrypto_1_1BigIntegerInterface-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">lbcrypto::BigIntegerInterface&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac686469a67d7f7701a0db722d3eddc26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BigIntegerInterface.html#ac686469a67d7f7701a0db722d3eddc26">SetValue</a> (const std::string &amp;str)</td></tr>
<tr class="separator:ac686469a67d7f7701a0db722d3eddc26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab76a0e51bc149cd015966cafae795049"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BigIntegerInterface.html#ab76a0e51bc149cd015966cafae795049">Add</a> (const T &amp;b) const</td></tr>
<tr class="separator:ab76a0e51bc149cd015966cafae795049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1627063142ed4a1339468ad77ca85b77"><td class="memItemLeft" align="right" valign="top"><a id="a1627063142ed4a1339468ad77ca85b77"></a>
const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>AddEq</b> (const T &amp;b)</td></tr>
<tr class="separator:a1627063142ed4a1339468ad77ca85b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9529e7dcd8e388a35a8fb1fedde2bc4e"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BigIntegerInterface.html#a9529e7dcd8e388a35a8fb1fedde2bc4e">Sub</a> (const T &amp;b) const</td></tr>
<tr class="separator:a9529e7dcd8e388a35a8fb1fedde2bc4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0841ac581c0868d3a50edf7c3684a685"><td class="memItemLeft" align="right" valign="top"><a id="a0841ac581c0868d3a50edf7c3684a685"></a>
const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>SubEq</b> (const T &amp;b)</td></tr>
<tr class="separator:a0841ac581c0868d3a50edf7c3684a685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab236c8df53d0e55a5355141d7337114a"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BigIntegerInterface.html#ab236c8df53d0e55a5355141d7337114a">Mul</a> (const T &amp;b) const</td></tr>
<tr class="separator:ab236c8df53d0e55a5355141d7337114a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab53ab3f588b580c347904be71e63be1b"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BigIntegerInterface.html#ab53ab3f588b580c347904be71e63be1b">MulEq</a> (const T &amp;b)</td></tr>
<tr class="separator:ab53ab3f588b580c347904be71e63be1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a603f690f7c38db320672bdb9e33d8176"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BigIntegerInterface.html#a603f690f7c38db320672bdb9e33d8176">DividedBy</a> (const T &amp;b) const</td></tr>
<tr class="separator:a603f690f7c38db320672bdb9e33d8176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79c0f8010cc77d5857da0c9f00eef281"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BigIntegerInterface.html#a79c0f8010cc77d5857da0c9f00eef281">DividedByEq</a> (const T &amp;b)</td></tr>
<tr class="separator:a79c0f8010cc77d5857da0c9f00eef281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13dfdff4a20a00de2a41fdddfe16331c"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BigIntegerInterface.html#a13dfdff4a20a00de2a41fdddfe16331c">MultiplyAndRound</a> (const T &amp;p, const T &amp;q) const</td></tr>
<tr class="separator:a13dfdff4a20a00de2a41fdddfe16331c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85e357ef1829369bac414c9f82315711"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BigIntegerInterface.html#a85e357ef1829369bac414c9f82315711">MultiplyAndRoundEq</a> (const T &amp;p, const T &amp;q)</td></tr>
<tr class="separator:a85e357ef1829369bac414c9f82315711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab20035cb96cdc1de82d7b9d22c2737c"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BigIntegerInterface.html#aab20035cb96cdc1de82d7b9d22c2737c">DivideAndRound</a> (const T &amp;q) const</td></tr>
<tr class="separator:aab20035cb96cdc1de82d7b9d22c2737c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe00410bfd2c4813d53d2554eb97c75e"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BigIntegerInterface.html#abe00410bfd2c4813d53d2554eb97c75e">DivideAndRoundEq</a> (const T &amp;q)</td></tr>
<tr class="separator:abe00410bfd2c4813d53d2554eb97c75e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb58ae9f6a05d700b36e074cf5732f08"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BigIntegerInterface.html#afb58ae9f6a05d700b36e074cf5732f08">Mod</a> (const T &amp;modulus) const</td></tr>
<tr class="separator:afb58ae9f6a05d700b36e074cf5732f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24110e7418f39c6c94beee20bfda186a"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BigIntegerInterface.html#a24110e7418f39c6c94beee20bfda186a">ModEq</a> (const T &amp;modulus)</td></tr>
<tr class="separator:a24110e7418f39c6c94beee20bfda186a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78051e7aec15b9a4cd838b636747be5b"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BigIntegerInterface.html#a78051e7aec15b9a4cd838b636747be5b">ComputeMu</a> () const</td></tr>
<tr class="separator:a78051e7aec15b9a4cd838b636747be5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57d366c1b038ffe060c6d655736b8f6e"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BigIntegerInterface.html#a57d366c1b038ffe060c6d655736b8f6e">Mod</a> (const T &amp;modulus, const T &amp;mu) const</td></tr>
<tr class="separator:a57d366c1b038ffe060c6d655736b8f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54812a10413d7ec7ff643bfc0e679c79"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BigIntegerInterface.html#a54812a10413d7ec7ff643bfc0e679c79">ModEq</a> (const T &amp;modulus, const T &amp;mu)</td></tr>
<tr class="separator:a54812a10413d7ec7ff643bfc0e679c79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c49aa1f06cf4d2f357d5fa6b4d14168"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BigIntegerInterface.html#a9c49aa1f06cf4d2f357d5fa6b4d14168">ModAdd</a> (const T &amp;b, const T &amp;modulus) const</td></tr>
<tr class="separator:a9c49aa1f06cf4d2f357d5fa6b4d14168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40e7f2c6d65c0256ec024383e563868d"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BigIntegerInterface.html#a40e7f2c6d65c0256ec024383e563868d">ModAddEq</a> (const T &amp;b, const T &amp;modulus)</td></tr>
<tr class="separator:a40e7f2c6d65c0256ec024383e563868d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acee35bc432f4e2769d4a031de1a963fe"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BigIntegerInterface.html#acee35bc432f4e2769d4a031de1a963fe">ModAddFast</a> (const T &amp;b, const T &amp;modulus) const</td></tr>
<tr class="separator:acee35bc432f4e2769d4a031de1a963fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a568981b28fb2800bdd9a8d09d66d1d40"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BigIntegerInterface.html#a568981b28fb2800bdd9a8d09d66d1d40">ModAddFastEq</a> (const T &amp;b, const T &amp;modulus)</td></tr>
<tr class="separator:a568981b28fb2800bdd9a8d09d66d1d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a278df99880db354e61f6aac9b6e91d16"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BigIntegerInterface.html#a278df99880db354e61f6aac9b6e91d16">ModAdd</a> (const T &amp;b, const T &amp;modulus, const T &amp;mu) const</td></tr>
<tr class="separator:a278df99880db354e61f6aac9b6e91d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16dff04ca645daf4e3602cf932115b91"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BigIntegerInterface.html#a16dff04ca645daf4e3602cf932115b91">ModAddEq</a> (const T &amp;b, const T &amp;modulus, const T &amp;mu)</td></tr>
<tr class="separator:a16dff04ca645daf4e3602cf932115b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a695dc0d8d7beeb8acd0ed638403858e7"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BigIntegerInterface.html#a695dc0d8d7beeb8acd0ed638403858e7">ModSub</a> (const T &amp;b, const T &amp;modulus) const</td></tr>
<tr class="separator:a695dc0d8d7beeb8acd0ed638403858e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaab27669080755ce2119a4375aa362bf"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BigIntegerInterface.html#aaab27669080755ce2119a4375aa362bf">ModSubEq</a> (const T &amp;b, const T &amp;modulus)</td></tr>
<tr class="separator:aaab27669080755ce2119a4375aa362bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad724bef1ab77561e4cd17efb3f51c2ba"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BigIntegerInterface.html#ad724bef1ab77561e4cd17efb3f51c2ba">ModSubFast</a> (const T &amp;b, const T &amp;modulus) const</td></tr>
<tr class="separator:ad724bef1ab77561e4cd17efb3f51c2ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb68a7eb06060dd25ad49933e83334cb"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BigIntegerInterface.html#afb68a7eb06060dd25ad49933e83334cb">ModSubFastEq</a> (const T &amp;b, const T &amp;modulus)</td></tr>
<tr class="separator:afb68a7eb06060dd25ad49933e83334cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9db6a9b9fdf6b6b483171f62e111bc9"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BigIntegerInterface.html#ab9db6a9b9fdf6b6b483171f62e111bc9">ModSub</a> (const T &amp;b, const T &amp;modulus, const T &amp;mu) const</td></tr>
<tr class="separator:ab9db6a9b9fdf6b6b483171f62e111bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e1913e4fcfcce33b33cc5a3a70ed49d"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BigIntegerInterface.html#a8e1913e4fcfcce33b33cc5a3a70ed49d">ModSubEq</a> (const T &amp;b, const T &amp;modulus, const T &amp;mu)</td></tr>
<tr class="separator:a8e1913e4fcfcce33b33cc5a3a70ed49d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ac1a391e15aece4503d1d036dd8b1b0"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BigIntegerInterface.html#a1ac1a391e15aece4503d1d036dd8b1b0">ModMul</a> (const T &amp;b, const T &amp;modulus) const</td></tr>
<tr class="separator:a1ac1a391e15aece4503d1d036dd8b1b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedbe235a47147ee70686037b74c9188a"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BigIntegerInterface.html#aedbe235a47147ee70686037b74c9188a">ModMulEq</a> (const T &amp;b, const T &amp;modulus)</td></tr>
<tr class="separator:aedbe235a47147ee70686037b74c9188a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d692981f17744d5ff88e0acacf2c42f"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BigIntegerInterface.html#a2d692981f17744d5ff88e0acacf2c42f">ModMul</a> (const T &amp;b, const T &amp;modulus, const T &amp;mu) const</td></tr>
<tr class="separator:a2d692981f17744d5ff88e0acacf2c42f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81fabfba42bc82a07263e07417267788"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BigIntegerInterface.html#a81fabfba42bc82a07263e07417267788">ModMulEq</a> (const T &amp;b, const T &amp;modulus, const T &amp;mu)</td></tr>
<tr class="separator:a81fabfba42bc82a07263e07417267788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a564450fa7687d18a1c8ce71eb084f6a3"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BigIntegerInterface.html#a564450fa7687d18a1c8ce71eb084f6a3">ModMulFast</a> (const T &amp;b, const T &amp;modulus) const</td></tr>
<tr class="separator:a564450fa7687d18a1c8ce71eb084f6a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae791b168a21c0ec6cec09980cb39cab1"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BigIntegerInterface.html#ae791b168a21c0ec6cec09980cb39cab1">ModMulFastEq</a> (const T &amp;b, const T &amp;modulus)</td></tr>
<tr class="separator:ae791b168a21c0ec6cec09980cb39cab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46bfb1d0a3a32093d9cb8cf585ce90b9"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BigIntegerInterface.html#a46bfb1d0a3a32093d9cb8cf585ce90b9">ModMulFast</a> (const T &amp;b, const T &amp;modulus, const T &amp;mu) const</td></tr>
<tr class="separator:a46bfb1d0a3a32093d9cb8cf585ce90b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5da7684a394735a4c872e2ce100d5ccd"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BigIntegerInterface.html#a5da7684a394735a4c872e2ce100d5ccd">ModMulFastEq</a> (const T &amp;b, const T &amp;modulus, const T &amp;mu)</td></tr>
<tr class="separator:a5da7684a394735a4c872e2ce100d5ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02cf86090e22e5d35789ec2c572259c2"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BigIntegerInterface.html#a02cf86090e22e5d35789ec2c572259c2">ModMulFastConst</a> (const T &amp;b, const T &amp;modulus, const T &amp;bInv) const</td></tr>
<tr class="separator:a02cf86090e22e5d35789ec2c572259c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6f85348f60c8f383eddf644dd76535f"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BigIntegerInterface.html#ab6f85348f60c8f383eddf644dd76535f">ModMulFastConstEq</a> (const T &amp;b, const T &amp;modulus, const T &amp;bInv)</td></tr>
<tr class="separator:ab6f85348f60c8f383eddf644dd76535f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a91851bc8a24f7a15d491f2197693d0"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BigIntegerInterface.html#a8a91851bc8a24f7a15d491f2197693d0">ModExp</a> (const T &amp;b, const T &amp;modulus) const</td></tr>
<tr class="separator:a8a91851bc8a24f7a15d491f2197693d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6712ad7932b4473af58a6ef4b8b2c7e1"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BigIntegerInterface.html#a6712ad7932b4473af58a6ef4b8b2c7e1">ModExpEq</a> (const T &amp;b, const T &amp;modulus)</td></tr>
<tr class="separator:a6712ad7932b4473af58a6ef4b8b2c7e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b5e5e8c1238a0b1dcf73ce1df9cc421"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BigIntegerInterface.html#a8b5e5e8c1238a0b1dcf73ce1df9cc421">ModInverse</a> (const T &amp;modulus) const</td></tr>
<tr class="separator:a8b5e5e8c1238a0b1dcf73ce1df9cc421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6712cf45bfa5316c94b756916ff041cd"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BigIntegerInterface.html#a6712cf45bfa5316c94b756916ff041cd">ModInverseEq</a> (const T &amp;modulus)</td></tr>
<tr class="separator:a6712cf45bfa5316c94b756916ff041cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebac479a00fd79d2fbddb6dca22edfee"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BigIntegerInterface.html#aebac479a00fd79d2fbddb6dca22edfee">LShift</a> (usshort shift) const</td></tr>
<tr class="separator:aebac479a00fd79d2fbddb6dca22edfee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f33768c99fefa140ac76736b152b5a7"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BigIntegerInterface.html#a2f33768c99fefa140ac76736b152b5a7">LShiftEq</a> (usshort shift)</td></tr>
<tr class="separator:a2f33768c99fefa140ac76736b152b5a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6831bcc3f1daa3a7ddb624e1d292f67b"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BigIntegerInterface.html#a6831bcc3f1daa3a7ddb624e1d292f67b">RShift</a> (usshort shift) const</td></tr>
<tr class="separator:a6831bcc3f1daa3a7ddb624e1d292f67b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf43a9d6bf43f529d242d6239887b8c"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BigIntegerInterface.html#a9cf43a9d6bf43f529d242d6239887b8c">RShiftEq</a> (usshort shift)</td></tr>
<tr class="separator:a9cf43a9d6bf43f529d242d6239887b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c6a2a095b9ec6256f91376df53daaa6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BigIntegerInterface.html#a1c6a2a095b9ec6256f91376df53daaa6">Compare</a> (const T &amp;a) const</td></tr>
<tr class="separator:a1c6a2a095b9ec6256f91376df53daaa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a931e40b492d237a3cb18a4558340c861"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BigIntegerInterface.html#a931e40b492d237a3cb18a4558340c861">ConvertToInt</a> () const</td></tr>
<tr class="separator:a931e40b492d237a3cb18a4558340c861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a727f9575ca4c9d0bd630502f40209bdc"><td class="memItemLeft" align="right" valign="top">usint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BigIntegerInterface.html#a727f9575ca4c9d0bd630502f40209bdc">GetMSB</a> () const</td></tr>
<tr class="separator:a727f9575ca4c9d0bd630502f40209bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a483ee5dcad965a0c9dbf931b30633b07"><td class="memItemLeft" align="right" valign="top">usint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BigIntegerInterface.html#a483ee5dcad965a0c9dbf931b30633b07">GetLengthForBase</a> (usint base) const</td></tr>
<tr class="separator:a483ee5dcad965a0c9dbf931b30633b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c11950669ff285f28148d45ad091620"><td class="memItemLeft" align="right" valign="top">usint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BigIntegerInterface.html#a5c11950669ff285f28148d45ad091620">GetDigitAtIndexForBase</a> (usint index, usint base) const</td></tr>
<tr class="separator:a5c11950669ff285f28148d45ad091620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae320c99a05694a914d7ae9a9a0ca8fc0"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BigIntegerInterface.html#ae320c99a05694a914d7ae9a9a0ca8fc0">ToString</a> () const</td></tr>
<tr class="separator:ae320c99a05694a914d7ae9a9a0ca8fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ac721a6f5d83ce205baf14441d3fcb432"><td class="memItemLeft" align="right" valign="top"><a id="ac721a6f5d83ce205baf14441d3fcb432"></a>
T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BigIntegerInterface.html#ac721a6f5d83ce205baf14441d3fcb432">operator+</a> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="memdesc:ac721a6f5d83ce205baf14441d3fcb432"><td class="mdescLeft">&#160;</td><td class="mdescRight">inline operators for the addition operation. <br /></td></tr>
<tr class="separator:ac721a6f5d83ce205baf14441d3fcb432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab80bb4bf012fe200421fc309c117621e"><td class="memItemLeft" align="right" valign="top"><a id="ab80bb4bf012fe200421fc309c117621e"></a>
const friend T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator+=</b> (T &amp;a, const T &amp;b)</td></tr>
<tr class="separator:ab80bb4bf012fe200421fc309c117621e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae625968fd76d48d00aff12eaf0bbde85"><td class="memItemLeft" align="right" valign="top"><a id="ae625968fd76d48d00aff12eaf0bbde85"></a>
T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BigIntegerInterface.html#ae625968fd76d48d00aff12eaf0bbde85">operator-</a> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="memdesc:ae625968fd76d48d00aff12eaf0bbde85"><td class="mdescLeft">&#160;</td><td class="mdescRight">inline operators for the subtraction operation. <br /></td></tr>
<tr class="separator:ae625968fd76d48d00aff12eaf0bbde85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9abe8fc5a4625266e801a6ed7eaa8701"><td class="memItemLeft" align="right" valign="top"><a id="a9abe8fc5a4625266e801a6ed7eaa8701"></a>
const friend T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator-=</b> (T &amp;a, const T &amp;b)</td></tr>
<tr class="separator:a9abe8fc5a4625266e801a6ed7eaa8701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfd712118ece326eb3959a4d9654f617"><td class="memItemLeft" align="right" valign="top"><a id="adfd712118ece326eb3959a4d9654f617"></a>
T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BigIntegerInterface.html#adfd712118ece326eb3959a4d9654f617">operator*</a> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="memdesc:adfd712118ece326eb3959a4d9654f617"><td class="mdescLeft">&#160;</td><td class="mdescRight">inline operators for the multiplication operation. <br /></td></tr>
<tr class="separator:adfd712118ece326eb3959a4d9654f617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad62e25b11ec0b920324581a5f1973a74"><td class="memItemLeft" align="right" valign="top"><a id="ad62e25b11ec0b920324581a5f1973a74"></a>
const friend T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (T &amp;a, const T &amp;b)</td></tr>
<tr class="separator:ad62e25b11ec0b920324581a5f1973a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd8d133ff7cdbf73b5dad185c3916160"><td class="memItemLeft" align="right" valign="top"><a id="abd8d133ff7cdbf73b5dad185c3916160"></a>
T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BigIntegerInterface.html#abd8d133ff7cdbf73b5dad185c3916160">operator/</a> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="memdesc:abd8d133ff7cdbf73b5dad185c3916160"><td class="mdescLeft">&#160;</td><td class="mdescRight">inline operators for the division operation. <br /></td></tr>
<tr class="separator:abd8d133ff7cdbf73b5dad185c3916160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a392913783f011051bd49bfe433f8997e"><td class="memItemLeft" align="right" valign="top"><a id="a392913783f011051bd49bfe433f8997e"></a>
const friend T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator/=</b> (T &amp;a, const T &amp;b)</td></tr>
<tr class="separator:a392913783f011051bd49bfe433f8997e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b0725c0c98145d1a15658ad2f31c95"><td class="memItemLeft" align="right" valign="top"><a id="a01b0725c0c98145d1a15658ad2f31c95"></a>
T&#160;</td><td class="memItemRight" valign="bottom"><b>operator%</b> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="separator:a01b0725c0c98145d1a15658ad2f31c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e7a40ca1012f1e3c397f28e5b2ef75"><td class="memItemLeft" align="right" valign="top"><a id="af0e7a40ca1012f1e3c397f28e5b2ef75"></a>
const friend T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator%=</b> (T &amp;a, const T &amp;b)</td></tr>
<tr class="separator:af0e7a40ca1012f1e3c397f28e5b2ef75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24dc8f96a20f72573fd2a6c0dfe24108"><td class="memItemLeft" align="right" valign="top"><a id="a24dc8f96a20f72573fd2a6c0dfe24108"></a>
T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BigIntegerInterface.html#a24dc8f96a20f72573fd2a6c0dfe24108">operator&lt;&lt;</a> (const T &amp;a, usshort shift)</td></tr>
<tr class="memdesc:a24dc8f96a20f72573fd2a6c0dfe24108"><td class="mdescLeft">&#160;</td><td class="mdescRight">inline operators for the left shift operations. <br /></td></tr>
<tr class="separator:a24dc8f96a20f72573fd2a6c0dfe24108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0104cbe4f4cc891bde82d338e9dc9f2e"><td class="memItemLeft" align="right" valign="top"><a id="a0104cbe4f4cc891bde82d338e9dc9f2e"></a>
const friend T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;=</b> (T &amp;a, usshort shift)</td></tr>
<tr class="separator:a0104cbe4f4cc891bde82d338e9dc9f2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc629b9e7a7df9fb7c6f78f5f20248b5"><td class="memItemLeft" align="right" valign="top"><a id="afc629b9e7a7df9fb7c6f78f5f20248b5"></a>
T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BigIntegerInterface.html#afc629b9e7a7df9fb7c6f78f5f20248b5">operator&gt;&gt;</a> (const T &amp;a, usshort shift)</td></tr>
<tr class="memdesc:afc629b9e7a7df9fb7c6f78f5f20248b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">inline operators for the right shift operations. <br /></td></tr>
<tr class="separator:afc629b9e7a7df9fb7c6f78f5f20248b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d108da96e4d3dd3b083747fb91af581"><td class="memItemLeft" align="right" valign="top"><a id="a7d108da96e4d3dd3b083747fb91af581"></a>
const friend T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;&gt;=</b> (T &amp;a, usshort shift)</td></tr>
<tr class="separator:a7d108da96e4d3dd3b083747fb91af581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ee6295f3b0ab78023aa000f397127c0"><td class="memItemLeft" align="right" valign="top"><a id="a2ee6295f3b0ab78023aa000f397127c0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="separator:a2ee6295f3b0ab78023aa000f397127c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13159133fb4b9bb38696013b61be3621"><td class="memItemLeft" align="right" valign="top"><a id="a13159133fb4b9bb38696013b61be3621"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="separator:a13159133fb4b9bb38696013b61be3621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a404e6cea4e28d4227d3467174fbe7a06"><td class="memItemLeft" align="right" valign="top"><a id="a404e6cea4e28d4227d3467174fbe7a06"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;</b> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="separator:a404e6cea4e28d4227d3467174fbe7a06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace62e19eb9cfc7d40ba4ef84d8fbd526"><td class="memItemLeft" align="right" valign="top"><a id="ace62e19eb9cfc7d40ba4ef84d8fbd526"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;=</b> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="separator:ace62e19eb9cfc7d40ba4ef84d8fbd526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b215923ddfb56215eb0278fc30d4985"><td class="memItemLeft" align="right" valign="top"><a id="a3b215923ddfb56215eb0278fc30d4985"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="separator:a3b215923ddfb56215eb0278fc30d4985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71a26ea935a19f365a0990c384a153d8"><td class="memItemLeft" align="right" valign="top"><a id="a71a26ea935a19f365a0990c384a153d8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;=</b> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="separator:a71a26ea935a19f365a0990c384a153d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab76a0e51bc149cd015966cafae795049"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab76a0e51bc149cd015966cafae795049">&#9670;&nbsp;</a></span>Add()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classlbcrypto_1_1BigIntegerInterface.html">lbcrypto::BigIntegerInterface</a>&lt; T &gt;::Add </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Addition operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;b</td><td>is the value to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result of the addition operation. </dd></dl>

</div>
</div>
<a id="a1c6a2a095b9ec6256f91376df53daaa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c6a2a095b9ec6256f91376df53daaa6">&#9670;&nbsp;</a></span>Compare()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classlbcrypto_1_1BigIntegerInterface.html">lbcrypto::BigIntegerInterface</a>&lt; T &gt;::Compare </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compares the current BigInteger to BigInteger a.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>is the BigInteger to be compared with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 for strictly less than, 0 for equal to and 1 for strictly greater than conditons. </dd></dl>

</div>
</div>
<a id="a78051e7aec15b9a4cd838b636747be5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78051e7aec15b9a4cd838b636747be5b">&#9670;&nbsp;</a></span>ComputeMu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classlbcrypto_1_1BigIntegerInterface.html">lbcrypto::BigIntegerInterface</a>&lt; T &gt;::ComputeMu </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Precomputes a parameter mu for Barrett modular reduction.</p>
<dl class="section return"><dt>Returns</dt><dd>the precomputed parameter mu. </dd></dl>

</div>
</div>
<a id="a931e40b492d237a3cb18a4558340c861"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a931e40b492d237a3cb18a4558340c861">&#9670;&nbsp;</a></span>ConvertToInt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint64_t <a class="el" href="classlbcrypto_1_1BigIntegerInterface.html">lbcrypto::BigIntegerInterface</a>&lt; T &gt;::ConvertToInt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert the value to an int.</p>
<dl class="section return"><dt>Returns</dt><dd>the int representation of the value. </dd></dl>

</div>
</div>
<a id="aab20035cb96cdc1de82d7b9d22c2737c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab20035cb96cdc1de82d7b9d22c2737c">&#9670;&nbsp;</a></span>DivideAndRound()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classlbcrypto_1_1BigIntegerInterface.html">lbcrypto::BigIntegerInterface</a>&lt; T &gt;::DivideAndRound </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Divide and Rounding operation. Returns [x/q] where [] is the rounding operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;q</td><td>is the denominator to be divided. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of divide and round operation. </dd></dl>

</div>
</div>
<a id="abe00410bfd2c4813d53d2554eb97c75e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe00410bfd2c4813d53d2554eb97c75e">&#9670;&nbsp;</a></span>DivideAndRoundEq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classlbcrypto_1_1BigIntegerInterface.html">lbcrypto::BigIntegerInterface</a>&lt; T &gt;::DivideAndRoundEq </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Divide and Rounding operation. Returns [x/q] where [] is the rounding operation. In-place variant.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;q</td><td>is the denominator to be divided. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of divide and round operation. </dd></dl>

</div>
</div>
<a id="a603f690f7c38db320672bdb9e33d8176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a603f690f7c38db320672bdb9e33d8176">&#9670;&nbsp;</a></span>DividedBy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classlbcrypto_1_1BigIntegerInterface.html">lbcrypto::BigIntegerInterface</a>&lt; T &gt;::DividedBy </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Division operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;b</td><td>is the value to divide by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the division operation. </dd></dl>

</div>
</div>
<a id="a79c0f8010cc77d5857da0c9f00eef281"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79c0f8010cc77d5857da0c9f00eef281">&#9670;&nbsp;</a></span>DividedByEq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classlbcrypto_1_1BigIntegerInterface.html">lbcrypto::BigIntegerInterface</a>&lt; T &gt;::DividedByEq </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Division operation. In-place variant.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;b</td><td>is the value to divide by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the division operation. </dd></dl>

</div>
</div>
<a id="a5c11950669ff285f28148d45ad091620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c11950669ff285f28148d45ad091620">&#9670;&nbsp;</a></span>GetDigitAtIndexForBase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">usint <a class="el" href="classlbcrypto_1_1BigIntegerInterface.html">lbcrypto::BigIntegerInterface</a>&lt; T &gt;::GetDigitAtIndexForBase </td>
          <td>(</td>
          <td class="paramtype">usint&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">usint&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of digits using a specific base - support for arbitrary base may be needed. Example: for number 83, index 2 and base 4 we have: </p><pre class="fragment">                    index:0,1,2,3
</pre><p> 83 &ndash;base 4 decomposition--&gt; (3,0,1,1) &ndash;at index 2--&gt; 1</p>
<p>The return number is 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>is the location to return value from in the specific base. </td></tr>
    <tr><td class="paramname">base</td><td>is the base with which to determine length in. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length of the representation in a specific base. </dd></dl>

</div>
</div>
<a id="a483ee5dcad965a0c9dbf931b30633b07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a483ee5dcad965a0c9dbf931b30633b07">&#9670;&nbsp;</a></span>GetLengthForBase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">usint <a class="el" href="classlbcrypto_1_1BigIntegerInterface.html">lbcrypto::BigIntegerInterface</a>&lt; T &gt;::GetLengthForBase </td>
          <td>(</td>
          <td class="paramtype">usint&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of digits using a specific base - support for arbitrary base may be needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base with which to determine length in. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length of the representation in a specific base. </dd></dl>

</div>
</div>
<a id="a727f9575ca4c9d0bd630502f40209bdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a727f9575ca4c9d0bd630502f40209bdc">&#9670;&nbsp;</a></span>GetMSB()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">usint <a class="el" href="classlbcrypto_1_1BigIntegerInterface.html">lbcrypto::BigIntegerInterface</a>&lt; T &gt;::GetMSB </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the MSB location of the value.</p>
<dl class="section return"><dt>Returns</dt><dd>the index of the most significant bit. </dd></dl>

</div>
</div>
<a id="aebac479a00fd79d2fbddb6dca22edfee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebac479a00fd79d2fbddb6dca22edfee">&#9670;&nbsp;</a></span>LShift()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classlbcrypto_1_1BigIntegerInterface.html">lbcrypto::BigIntegerInterface</a>&lt; T &gt;::LShift </td>
          <td>(</td>
          <td class="paramtype">usshort&#160;</td>
          <td class="paramname"><em>shift</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Left shift operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shift</td><td># of bits. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result of the shift operation. </dd></dl>

</div>
</div>
<a id="a2f33768c99fefa140ac76736b152b5a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f33768c99fefa140ac76736b152b5a7">&#9670;&nbsp;</a></span>LShiftEq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classlbcrypto_1_1BigIntegerInterface.html">lbcrypto::BigIntegerInterface</a>&lt; T &gt;::LShiftEq </td>
          <td>(</td>
          <td class="paramtype">usshort&#160;</td>
          <td class="paramname"><em>shift</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Left shift operation. In-place variant.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shift</td><td># of bits. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result of the shift operation. </dd></dl>

</div>
</div>
<a id="afb58ae9f6a05d700b36e074cf5732f08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb58ae9f6a05d700b36e074cf5732f08">&#9670;&nbsp;</a></span>Mod() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classlbcrypto_1_1BigIntegerInterface.html">lbcrypto::BigIntegerInterface</a>&lt; T &gt;::Mod </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>modulus</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Naive modulus operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;modulus</td><td>is the modulus to perform. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the modulus operation. </dd></dl>

</div>
</div>
<a id="a57d366c1b038ffe060c6d655736b8f6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57d366c1b038ffe060c6d655736b8f6e">&#9670;&nbsp;</a></span>Mod() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classlbcrypto_1_1BigIntegerInterface.html">lbcrypto::BigIntegerInterface</a>&lt; T &gt;::Mod </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>modulus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>mu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Barrett modulus operation. Implements generalized Barrett modular reduction algorithm. Uses one precomputed value of mu.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;modulus</td><td>is the modulus to perform. </td></tr>
    <tr><td class="paramname">&amp;mu</td><td>is the Barrett value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the modulus operation. </dd></dl>

</div>
</div>
<a id="a9c49aa1f06cf4d2f357d5fa6b4d14168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c49aa1f06cf4d2f357d5fa6b4d14168">&#9670;&nbsp;</a></span>ModAdd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classlbcrypto_1_1BigIntegerInterface.html">lbcrypto::BigIntegerInterface</a>&lt; T &gt;::ModAdd </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>modulus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Modulus addition operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;b</td><td>is the scalar to add. </td></tr>
    <tr><td class="paramname">&amp;modulus</td><td>is the modulus to perform operations with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the modulus addition operation. </dd></dl>

</div>
</div>
<a id="a278df99880db354e61f6aac9b6e91d16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a278df99880db354e61f6aac9b6e91d16">&#9670;&nbsp;</a></span>ModAdd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classlbcrypto_1_1BigIntegerInterface.html">lbcrypto::BigIntegerInterface</a>&lt; T &gt;::ModAdd </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>modulus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>mu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Barrett modulus addition operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;b</td><td>is the scalar to add. </td></tr>
    <tr><td class="paramname">&amp;modulus</td><td>is the modulus to perform operations with. </td></tr>
    <tr><td class="paramname">&amp;mu</td><td>is the Barrett value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the modulus addition operation. </dd></dl>

</div>
</div>
<a id="a40e7f2c6d65c0256ec024383e563868d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40e7f2c6d65c0256ec024383e563868d">&#9670;&nbsp;</a></span>ModAddEq() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classlbcrypto_1_1BigIntegerInterface.html">lbcrypto::BigIntegerInterface</a>&lt; T &gt;::ModAddEq </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>modulus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Modulus addition operation. In-place variant.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;b</td><td>is the scalar to add. </td></tr>
    <tr><td class="paramname">&amp;modulus</td><td>is the modulus to perform operations with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the modulus addition operation. </dd></dl>

</div>
</div>
<a id="a16dff04ca645daf4e3602cf932115b91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16dff04ca645daf4e3602cf932115b91">&#9670;&nbsp;</a></span>ModAddEq() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classlbcrypto_1_1BigIntegerInterface.html">lbcrypto::BigIntegerInterface</a>&lt; T &gt;::ModAddEq </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>modulus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>mu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Barrett modulus addition operation. In-place variant.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;b</td><td>is the scalar to add. </td></tr>
    <tr><td class="paramname">&amp;modulus</td><td>is the modulus to perform operations with. </td></tr>
    <tr><td class="paramname">&amp;mu</td><td>is the Barrett value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the modulus addition operation. </dd></dl>

</div>
</div>
<a id="acee35bc432f4e2769d4a031de1a963fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acee35bc432f4e2769d4a031de1a963fe">&#9670;&nbsp;</a></span>ModAddFast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classlbcrypto_1_1BigIntegerInterface.html">lbcrypto::BigIntegerInterface</a>&lt; T &gt;::ModAddFast </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>modulus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Modulus addition where operands are &lt; modulus.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;b</td><td>is the scalar to add. </td></tr>
    <tr><td class="paramname">&amp;modulus</td><td>is the modulus to perform operations with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the modulus addition operation. </dd></dl>

</div>
</div>
<a id="a568981b28fb2800bdd9a8d09d66d1d40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a568981b28fb2800bdd9a8d09d66d1d40">&#9670;&nbsp;</a></span>ModAddFastEq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classlbcrypto_1_1BigIntegerInterface.html">lbcrypto::BigIntegerInterface</a>&lt; T &gt;::ModAddFastEq </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>modulus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Modulus addition where operands are &lt; modulus. In-place variant.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;b</td><td>is the scalar to add. </td></tr>
    <tr><td class="paramname">&amp;modulus</td><td>is the modulus to perform operations with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the modulus addition operation. </dd></dl>

</div>
</div>
<a id="a24110e7418f39c6c94beee20bfda186a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24110e7418f39c6c94beee20bfda186a">&#9670;&nbsp;</a></span>ModEq() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classlbcrypto_1_1BigIntegerInterface.html">lbcrypto::BigIntegerInterface</a>&lt; T &gt;::ModEq </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>modulus</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Naive modulus operation. In-place variant.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;modulus</td><td>is the modulus to perform. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the modulus operation. </dd></dl>

</div>
</div>
<a id="a54812a10413d7ec7ff643bfc0e679c79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54812a10413d7ec7ff643bfc0e679c79">&#9670;&nbsp;</a></span>ModEq() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classlbcrypto_1_1BigIntegerInterface.html">lbcrypto::BigIntegerInterface</a>&lt; T &gt;::ModEq </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>modulus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>mu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Barrett modulus operation. In-place variant. Implements generalized Barrett modular reduction algorithm. Uses one precomputed value of mu.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;modulus</td><td>is the modulus to perform. </td></tr>
    <tr><td class="paramname">&amp;mu</td><td>is the Barrett value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the modulus operation. </dd></dl>

</div>
</div>
<a id="a8a91851bc8a24f7a15d491f2197693d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a91851bc8a24f7a15d491f2197693d0">&#9670;&nbsp;</a></span>ModExp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classlbcrypto_1_1BigIntegerInterface.html">lbcrypto::BigIntegerInterface</a>&lt; T &gt;::ModExp </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>modulus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Modulus exponentiation operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;b</td><td>is the scalar to exponentiate at all locations. </td></tr>
    <tr><td class="paramname">&amp;modulus</td><td>is the modulus to perform operations with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the modulus exponentiation operation. </dd></dl>

</div>
</div>
<a id="a6712ad7932b4473af58a6ef4b8b2c7e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6712ad7932b4473af58a6ef4b8b2c7e1">&#9670;&nbsp;</a></span>ModExpEq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classlbcrypto_1_1BigIntegerInterface.html">lbcrypto::BigIntegerInterface</a>&lt; T &gt;::ModExpEq </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>modulus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Modulus exponentiation operation. In-place variant.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;b</td><td>is the scalar to exponentiate at all locations. </td></tr>
    <tr><td class="paramname">&amp;modulus</td><td>is the modulus to perform operations with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the modulus exponentiation operation. </dd></dl>

</div>
</div>
<a id="a8b5e5e8c1238a0b1dcf73ce1df9cc421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b5e5e8c1238a0b1dcf73ce1df9cc421">&#9670;&nbsp;</a></span>ModInverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classlbcrypto_1_1BigIntegerInterface.html">lbcrypto::BigIntegerInterface</a>&lt; T &gt;::ModInverse </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>modulus</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Modulus inverse operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;modulus</td><td>is the modulus to perform. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the modulus inverse operation. </dd></dl>

</div>
</div>
<a id="a6712cf45bfa5316c94b756916ff041cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6712cf45bfa5316c94b756916ff041cd">&#9670;&nbsp;</a></span>ModInverseEq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classlbcrypto_1_1BigIntegerInterface.html">lbcrypto::BigIntegerInterface</a>&lt; T &gt;::ModInverseEq </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>modulus</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Modulus inverse operation. In-place variant.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;modulus</td><td>is the modulus to perform. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the modulus inverse operation. </dd></dl>

</div>
</div>
<a id="a1ac1a391e15aece4503d1d036dd8b1b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ac1a391e15aece4503d1d036dd8b1b0">&#9670;&nbsp;</a></span>ModMul() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classlbcrypto_1_1BigIntegerInterface.html">lbcrypto::BigIntegerInterface</a>&lt; T &gt;::ModMul </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>modulus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Modulus multiplication operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;b</td><td>is the scalar to multiply. </td></tr>
    <tr><td class="paramname">&amp;modulus</td><td>is the modulus to perform operations with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the modulus multiplication operation. </dd></dl>

</div>
</div>
<a id="a2d692981f17744d5ff88e0acacf2c42f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d692981f17744d5ff88e0acacf2c42f">&#9670;&nbsp;</a></span>ModMul() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classlbcrypto_1_1BigIntegerInterface.html">lbcrypto::BigIntegerInterface</a>&lt; T &gt;::ModMul </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>modulus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>mu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Barrett modulus multiplication.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;b</td><td>is the scalar to multiply. </td></tr>
    <tr><td class="paramname">&amp;modulus</td><td>is the modulus to perform operations with. </td></tr>
    <tr><td class="paramname">&amp;mu</td><td>is the Barrett value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the modulus multiplication operation. </dd></dl>

</div>
</div>
<a id="aedbe235a47147ee70686037b74c9188a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedbe235a47147ee70686037b74c9188a">&#9670;&nbsp;</a></span>ModMulEq() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classlbcrypto_1_1BigIntegerInterface.html">lbcrypto::BigIntegerInterface</a>&lt; T &gt;::ModMulEq </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>modulus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Modulus multiplication operation. In-place variant.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;b</td><td>is the scalar to multiply. </td></tr>
    <tr><td class="paramname">&amp;modulus</td><td>is the modulus to perform operations with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the modulus multiplication operation. </dd></dl>

</div>
</div>
<a id="a81fabfba42bc82a07263e07417267788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81fabfba42bc82a07263e07417267788">&#9670;&nbsp;</a></span>ModMulEq() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classlbcrypto_1_1BigIntegerInterface.html">lbcrypto::BigIntegerInterface</a>&lt; T &gt;::ModMulEq </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>modulus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>mu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Barrett modulus multiplication. In-place variant.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;b</td><td>is the scalar to multiply. </td></tr>
    <tr><td class="paramname">&amp;modulus</td><td>is the modulus to perform operations with. </td></tr>
    <tr><td class="paramname">&amp;mu</td><td>is the Barrett value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the modulus multiplication operation. </dd></dl>

</div>
</div>
<a id="a564450fa7687d18a1c8ce71eb084f6a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a564450fa7687d18a1c8ce71eb084f6a3">&#9670;&nbsp;</a></span>ModMulFast() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classlbcrypto_1_1BigIntegerInterface.html">lbcrypto::BigIntegerInterface</a>&lt; T &gt;::ModMulFast </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>modulus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Modulus multiplication that assumes the operands are &lt; modulus.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;b</td><td>is the scalar to multiply. </td></tr>
    <tr><td class="paramname">&amp;modulus</td><td>is the modulus to perform operations with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the modulus multiplication operation. </dd></dl>

</div>
</div>
<a id="a46bfb1d0a3a32093d9cb8cf585ce90b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46bfb1d0a3a32093d9cb8cf585ce90b9">&#9670;&nbsp;</a></span>ModMulFast() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classlbcrypto_1_1BigIntegerInterface.html">lbcrypto::BigIntegerInterface</a>&lt; T &gt;::ModMulFast </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>modulus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>mu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Barrett modulus multiplication that assumes the operands are &lt; modulus.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;b</td><td>is the scalar to multiply. </td></tr>
    <tr><td class="paramname">&amp;modulus</td><td>is the modulus to perform operations with. </td></tr>
    <tr><td class="paramname">&amp;mu</td><td>is the Barrett value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the modulus multiplication operation. </dd></dl>

</div>
</div>
<a id="a02cf86090e22e5d35789ec2c572259c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02cf86090e22e5d35789ec2c572259c2">&#9670;&nbsp;</a></span>ModMulFastConst()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classlbcrypto_1_1BigIntegerInterface.html">lbcrypto::BigIntegerInterface</a>&lt; T &gt;::ModMulFastConst </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>modulus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>bInv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>NTL-optimized modular multiplication using a precomputation for the multiplicand. Assumes operands are &lt; modulus.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;b</td><td>is the scalar to multiply. </td></tr>
    <tr><td class="paramname">&amp;modulus</td><td>is the modulus to perform operations with. </td></tr>
    <tr><td class="paramname">&amp;bInv</td><td><a class="el" href="namespaceNTL.html">NTL</a> precomputation for b. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the modulus multiplication operation. </dd></dl>

</div>
</div>
<a id="ab6f85348f60c8f383eddf644dd76535f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6f85348f60c8f383eddf644dd76535f">&#9670;&nbsp;</a></span>ModMulFastConstEq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classlbcrypto_1_1BigIntegerInterface.html">lbcrypto::BigIntegerInterface</a>&lt; T &gt;::ModMulFastConstEq </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>modulus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>bInv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>NTL-optimized modular multiplication using a precomputation for the multiplicand. Assumes operands are &lt; modulus. In-place variant.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;b</td><td>is the scalar to multiply. </td></tr>
    <tr><td class="paramname">&amp;modulus</td><td>is the modulus to perform operations with. </td></tr>
    <tr><td class="paramname">&amp;bInv</td><td><a class="el" href="namespaceNTL.html">NTL</a> precomputation for b. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the modulus multiplication operation. </dd></dl>

</div>
</div>
<a id="ae791b168a21c0ec6cec09980cb39cab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae791b168a21c0ec6cec09980cb39cab1">&#9670;&nbsp;</a></span>ModMulFastEq() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classlbcrypto_1_1BigIntegerInterface.html">lbcrypto::BigIntegerInterface</a>&lt; T &gt;::ModMulFastEq </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>modulus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Modulus multiplication that assumes the operands are &lt; modulus. In-place variant.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;b</td><td>is the scalar to multiply. </td></tr>
    <tr><td class="paramname">&amp;modulus</td><td>is the modulus to perform operations with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the modulus multiplication operation. </dd></dl>

</div>
</div>
<a id="a5da7684a394735a4c872e2ce100d5ccd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5da7684a394735a4c872e2ce100d5ccd">&#9670;&nbsp;</a></span>ModMulFastEq() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classlbcrypto_1_1BigIntegerInterface.html">lbcrypto::BigIntegerInterface</a>&lt; T &gt;::ModMulFastEq </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>modulus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>mu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Barrett modulus multiplication that assumes the operands are &lt; modulus. In-place variant.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;b</td><td>is the scalar to multiply. </td></tr>
    <tr><td class="paramname">&amp;modulus</td><td>is the modulus to perform operations with. </td></tr>
    <tr><td class="paramname">&amp;mu</td><td>is the Barrett value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the modulus multiplication operation. </dd></dl>

</div>
</div>
<a id="a695dc0d8d7beeb8acd0ed638403858e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a695dc0d8d7beeb8acd0ed638403858e7">&#9670;&nbsp;</a></span>ModSub() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classlbcrypto_1_1BigIntegerInterface.html">lbcrypto::BigIntegerInterface</a>&lt; T &gt;::ModSub </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>modulus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Modulus subtraction operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;b</td><td>is the scalar to subtract. </td></tr>
    <tr><td class="paramname">&amp;modulus</td><td>is the modulus to perform operations with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the modulus subtraction operation. </dd></dl>

</div>
</div>
<a id="ab9db6a9b9fdf6b6b483171f62e111bc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9db6a9b9fdf6b6b483171f62e111bc9">&#9670;&nbsp;</a></span>ModSub() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classlbcrypto_1_1BigIntegerInterface.html">lbcrypto::BigIntegerInterface</a>&lt; T &gt;::ModSub </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>modulus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>mu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Barrett modulus subtraction operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;b</td><td>is the scalar to subtract. </td></tr>
    <tr><td class="paramname">&amp;modulus</td><td>is the modulus to perform operations with. </td></tr>
    <tr><td class="paramname">&amp;mu</td><td>is the Barrett value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the modulus subtraction operation. </dd></dl>

</div>
</div>
<a id="aaab27669080755ce2119a4375aa362bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaab27669080755ce2119a4375aa362bf">&#9670;&nbsp;</a></span>ModSubEq() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classlbcrypto_1_1BigIntegerInterface.html">lbcrypto::BigIntegerInterface</a>&lt; T &gt;::ModSubEq </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>modulus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Modulus subtraction operation. In-place variant.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;b</td><td>is the scalar to subtract. </td></tr>
    <tr><td class="paramname">&amp;modulus</td><td>is the modulus to perform operations with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the modulus subtraction operation. </dd></dl>

</div>
</div>
<a id="a8e1913e4fcfcce33b33cc5a3a70ed49d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e1913e4fcfcce33b33cc5a3a70ed49d">&#9670;&nbsp;</a></span>ModSubEq() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classlbcrypto_1_1BigIntegerInterface.html">lbcrypto::BigIntegerInterface</a>&lt; T &gt;::ModSubEq </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>modulus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>mu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Barrett modulus subtraction operation. In-place variant.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;b</td><td>is the scalar to subtract. </td></tr>
    <tr><td class="paramname">&amp;modulus</td><td>is the modulus to perform operations with. </td></tr>
    <tr><td class="paramname">&amp;mu</td><td>is the Barrett value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the modulus subtraction operation. </dd></dl>

</div>
</div>
<a id="ad724bef1ab77561e4cd17efb3f51c2ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad724bef1ab77561e4cd17efb3f51c2ba">&#9670;&nbsp;</a></span>ModSubFast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classlbcrypto_1_1BigIntegerInterface.html">lbcrypto::BigIntegerInterface</a>&lt; T &gt;::ModSubFast </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>modulus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Modulus subtraction where operands are &lt; modulus.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;b</td><td>is the scalar to subtract. </td></tr>
    <tr><td class="paramname">&amp;modulus</td><td>is the modulus to perform operations with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the modulus subtraction operation. </dd></dl>

</div>
</div>
<a id="afb68a7eb06060dd25ad49933e83334cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb68a7eb06060dd25ad49933e83334cb">&#9670;&nbsp;</a></span>ModSubFastEq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classlbcrypto_1_1BigIntegerInterface.html">lbcrypto::BigIntegerInterface</a>&lt; T &gt;::ModSubFastEq </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>modulus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Modulus subtraction where operands are &lt; modulus. In-place variant.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;b</td><td>is the scalar to subtract. </td></tr>
    <tr><td class="paramname">&amp;modulus</td><td>is the modulus to perform operations with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the modulus subtraction operation. </dd></dl>

</div>
</div>
<a id="ab236c8df53d0e55a5355141d7337114a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab236c8df53d0e55a5355141d7337114a">&#9670;&nbsp;</a></span>Mul()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classlbcrypto_1_1BigIntegerInterface.html">lbcrypto::BigIntegerInterface</a>&lt; T &gt;::Mul </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiplication operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;b</td><td>is the value to multiply with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the multiplication operation. </dd></dl>

</div>
</div>
<a id="ab53ab3f588b580c347904be71e63be1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab53ab3f588b580c347904be71e63be1b">&#9670;&nbsp;</a></span>MulEq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classlbcrypto_1_1BigIntegerInterface.html">lbcrypto::BigIntegerInterface</a>&lt; T &gt;::MulEq </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiplication operation. In-place variant.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;b</td><td>is the value to multiply with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the multiplication operation. </dd></dl>

</div>
</div>
<a id="a13dfdff4a20a00de2a41fdddfe16331c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13dfdff4a20a00de2a41fdddfe16331c">&#9670;&nbsp;</a></span>MultiplyAndRound()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classlbcrypto_1_1BigIntegerInterface.html">lbcrypto::BigIntegerInterface</a>&lt; T &gt;::MultiplyAndRound </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiply and Rounding operation. Returns [x*p/q] where [] is the rounding operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;p</td><td>is the numerator to be multiplied. </td></tr>
    <tr><td class="paramname">&amp;q</td><td>is the denominator to be divided. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of multiply and round operation. </dd></dl>

</div>
</div>
<a id="a85e357ef1829369bac414c9f82315711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85e357ef1829369bac414c9f82315711">&#9670;&nbsp;</a></span>MultiplyAndRoundEq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classlbcrypto_1_1BigIntegerInterface.html">lbcrypto::BigIntegerInterface</a>&lt; T &gt;::MultiplyAndRoundEq </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiply and Rounding operation. Returns [x*p/q] where [] is the rounding operation. In-place variant.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;p</td><td>is the numerator to be multiplied. </td></tr>
    <tr><td class="paramname">&amp;q</td><td>is the denominator to be divided. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of multiply and round operation. </dd></dl>

</div>
</div>
<a id="a6831bcc3f1daa3a7ddb624e1d292f67b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6831bcc3f1daa3a7ddb624e1d292f67b">&#9670;&nbsp;</a></span>RShift()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classlbcrypto_1_1BigIntegerInterface.html">lbcrypto::BigIntegerInterface</a>&lt; T &gt;::RShift </td>
          <td>(</td>
          <td class="paramtype">usshort&#160;</td>
          <td class="paramname"><em>shift</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Right shift operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shift</td><td># of bits. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result of the shift operation. </dd></dl>

</div>
</div>
<a id="a9cf43a9d6bf43f529d242d6239887b8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cf43a9d6bf43f529d242d6239887b8c">&#9670;&nbsp;</a></span>RShiftEq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classlbcrypto_1_1BigIntegerInterface.html">lbcrypto::BigIntegerInterface</a>&lt; T &gt;::RShiftEq </td>
          <td>(</td>
          <td class="paramtype">usshort&#160;</td>
          <td class="paramname"><em>shift</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Right shift operation. In-place variant.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shift</td><td># of bits. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result of the shift operation. </dd></dl>

</div>
</div>
<a id="ac686469a67d7f7701a0db722d3eddc26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac686469a67d7f7701a0db722d3eddc26">&#9670;&nbsp;</a></span>SetValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlbcrypto_1_1BigIntegerInterface.html">lbcrypto::BigIntegerInterface</a>&lt; T &gt;::SetValue </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set from a string</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>is the string representation of the value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9529e7dcd8e388a35a8fb1fedde2bc4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9529e7dcd8e388a35a8fb1fedde2bc4e">&#9670;&nbsp;</a></span>Sub()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classlbcrypto_1_1BigIntegerInterface.html">lbcrypto::BigIntegerInterface</a>&lt; T &gt;::Sub </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Subtraction operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;b</td><td>is the value to subtract. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the subtraction operation. </dd></dl>

</div>
</div>
<a id="ae320c99a05694a914d7ae9a9a0ca8fc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae320c99a05694a914d7ae9a9a0ca8fc0">&#9670;&nbsp;</a></span>ToString()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::string <a class="el" href="classlbcrypto_1_1BigIntegerInterface.html">lbcrypto::BigIntegerInterface</a>&lt; T &gt;::ToString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert this integer into a std::string, for serialization</p>
<dl class="section return"><dt>Returns</dt><dd>the value of this T as a string. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/core/include/math/<a class="el" href="interface_8h_source.html">interface.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Dec 15 2021 18:59:47 for PALISADE Lattice Crypto Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
