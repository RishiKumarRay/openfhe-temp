<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PALISADE Lattice Crypto Library: Sampling in PALISADE</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PALISADE Lattice Crypto Library
   &#160;<span id="projectnumber">1.11.5</span>
   </div>
   <div id="projectbrief">A lattice crypto library for software engineers by software engineers.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Sampling in PALISADE </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>PALISADE library offers various methods for sampling from discrete Gaussian distribution. The methods are implemented in both <a href="./discretegaussiangenerator.h">DiscreteGaussianGenerator</a> and <a href="./discretegaussiangeneratorgeneric.h">DiscreteGaussianGeneratorGeneric</a> classes, which have their specific uses. All of the samplers discussed have been tested in <a href="https://eprint.iacr.org/2017/438.pdf">GLITCH Discrete Gaussian Testing Suite</a> and no problems/abnormalities have been found.</p>
<h1><a class="anchor" id="autotoc_md8"></a>
Samplers in DiscreteGaussianGenerator</h1>
<p>The class <a href="./discretegaussiangenerator.h">DiscreteGaussianGenerator</a> is the main class for homomorphic encryption and includes the implementations of rejection sampling, Karney's method and Peikert's inversion method.</p>
<ul>
<li><b>Rejection Sampling:</b> Rejection sampling is defined in section 4.1 of the paper <a href="https://eprint.iacr.org/2007/432.pdf">Trapdoors for Hard Lattices and New Cryptographic Constructions</a>. It is used in the methods GenerateInteger(double mean, double stddev, size_t n, const IntType &amp;modulus) and GenerateInteger(double mean, double stddev, size_t n). Rejection sampling can be used for any arbitrary center and distribution parameter without any precomputations. However, it has high rejection rate and is vulnerable to timing attacks. It is currently not used by any cryptographic protocols in PALISADE.</li>
<li><b>Karney's Method:</b> Karney's method is defined as Algorithm D in the paper <a href="https://arxiv.org/pdf/1303.6257.pdf">Sampling exactly from the normal distribution</a>, which is an improved sampling method, based on rejection sampling. It is used in the method GenerateIntegerKarney. Like the rejection sampling, it can be used for arbitrary center and distribution parameter without any precomputations. It has a smaller rejection rate than the traditional sampling but it may still be prone to timing attacks.</li>
<li><b>Peikert's Inversion Method:</b> Peikert's inversion method discussed in section 4.1 of the paper <a href="https://eprint.iacr.org/2010/088.pdf">An Efficient and Parallel Gaussian Sampler for Lattices</a> and summarized in section 3.2.2 of <a href="https://link.springer.com/content/pdf/10.1007%2Fs00200-014-0218-3.pdf">Sampling from discrete Gaussians for lattice-based cryptography on a constrained device</a>. It requires CDF tables of probabilities centered around single center to be kept in memory, which are pre calculated in the constructor. Peikert's inversion algorithm is used in the methods GenerateInt, GenerateIntVector, GenerateVector and GenerateInteger(const IntType&amp; modulus). These methods are not prone to timing attacks but they are usable for single center, single deviation only. It should be also noted that the memory requirement grows with the distribution parameter, therefore it is advised to use it with smaller deviations.</li>
</ul>
<p>Since DiscreteGaussianGenerator contains both rejection based &amp; precomputation-based sampling algorithms, a different constructor must be called based on the desired algorithm to be used. If Peikert's method is desired, then the object must be constructed with a distribution parameter whereas using rejection or Karney's method does not require such constraint. (Refer to <a href="#how-to-use-sampling-methods">How to Use Sampling Methods</a> section for example code) The std parameter in the constructor is only used by Peikert's method.</p>
<h1><a class="anchor" id="autotoc_md9"></a>
Samplers in DiscreteGaussianGeneratorGeneric</h1>
<p>The class <a href="./discretegaussiangeneratorgeneric.h">DiscreteGaussianGeneratorGeneric</a> is the constant-time generic sampler developed by UCSD, and it contains the definitions for this new sampling method and base samplers required for it.</p>
<ul>
<li><b>Peikert's Inversion Method:</b> Peikert's inversion method is the same one defined in <a href="./discretegaussiangenerator.h">DiscreteGaussianGenerator</a>, and it's used in base samplers only. It is called from a BaseSampler object created with "PEIKERT" parameter by invoking GenerateInteger method.</li>
<li><b>Knuth-Yao Sampling:</b> Knuth-Yao's method for sampling integers was summarized in section 5 of <a href="https://link.springer.com/content/pdf/10.1007%2Fs00200-014-0218-3.pdf">Sampling from discrete Gaussians for lattice-based cryptography on a constrained device</a>. It requires the calculation of probability matrix and then the Discrete Distribution Generating trees, which is handled in constructor. In order to use this method, it is required to call it from a BaseSampler object created with "KNUTH_YAO" parameter by invoking GenerateInteger method. Just like Peikert's inversion method, it is usable for single center, single deviation only while having a memory requirement proportional to distribution parameter.</li>
<li><b>Generic Constant Time Sampling:</b> The new generic sampler developed by UCSD was discussed in the paper <a href="https://eprint.iacr.org/2017/259">Gaussian Sampling over the Integers: Efficient, Generic, Constant-Time</a>. It combines a set of base samplers centered around various means and a single distribution parameter to sample from arbitrary centers and distribution parameters. The parameter selection is discussed in detail in header file, but in general the sampler requires a set of base samplers given as parameters and few precomputations, which are handled in construction phase. This method can be called by creating a DiscreteGaussianGeneratorGeneric object and invoking GenerateInteger method. It is not vulnerable to timing attacks.</li>
</ul>
<h1><a class="anchor" id="autotoc_md10"></a>
How to Use Sampling Methods</h1>
<h2><a class="anchor" id="autotoc_md11"></a>
Rejection Sampling</h2>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">/*Create the generator object, std is not important as we choose it arbitrarily during sampling*/</div>
<div class="line">DiscreteGaussianGenerator dggRejection;</div>
<div class="line">/*First parameter is the mean, second one is the distribution parameter and third one is the ring dimension.*/</div>
<div class="line">int64_t number = dggRejection.GenerateInteger(0,4,1024);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md12"></a>
Karney's Method</h2>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">/*Create the generator object, std is not important as we choose it arbitrarily during sampling*/</div>
<div class="line">DiscreteGaussianGenerator dggKarney;</div>
<div class="line">/*First parameter is the mean, second one is the distribution parameter*/</div>
<div class="line">int64_t number = dggKarney.GenerateIntegerKarney(0,4);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md13"></a>
Peikert's Inversion Method (As defined in DiscreteGaussianGenerator)</h2>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">/*Create the generator object, the parameter is the distribution parameter*/</div>
<div class="line">DiscreteGaussianGenerator dggPeikert(4);</div>
<div class="line">/*This will create a single number*/</div>
<div class="line">int64_t number = dggPeikert.GenerateInt();</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md14"></a>
Peikert's Inversion Method (As defined in DiscreteGaussianGeneratorGeneric)</h2>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">/*Create a bit generator that will feed the random bits*/</div>
<div class="line">BitGenerator* bg = new BitGenerator();</div>
<div class="line"> </div>
<div class="line">/*Mean and distribution parameter*/</div>
<div class="line">double std= 4;</div>
<div class="line">double mean = 0;</div>
<div class="line"> </div>
<div class="line">/*Create the sampler object*/</div>
<div class="line">BaseSampler peikert_sampler(mean,std,bg,PEIKERT);</div>
<div class="line"> </div>
<div class="line">/*Generate Integer */</div>
<div class="line">int64_t number = peikert_sampler.GenerateInteger();</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md15"></a>
Knuth-Yao's Method (As defined in DiscreteGaussianGeneratorGeneric)</h2>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">/*Create a bit generator that will feed the random bits*/</div>
<div class="line">BitGenerator* bg = new BitGenerator();</div>
<div class="line"> </div>
<div class="line">/*Mean and distribution parameter*/</div>
<div class="line">double std= 4;</div>
<div class="line">double mean = 0;</div>
<div class="line"> </div>
<div class="line">/*Create the sampler object*/</div>
<div class="line">BaseSampler ky_sampler(mean,std,bg,KNUTH_YAO);</div>
<div class="line"> </div>
<div class="line">/*Generate Integer */</div>
<div class="line">int64_t number = ky_sampler.GenerateInteger();</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md16"></a>
Generic Sampler</h2>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line"> </div>
<div class="line">/*Create a bit generator that will feed the random bits*/</div>
<div class="line">BitGenerator* bg = new BitGenerator();</div>
<div class="line"> </div>
<div class="line">/*Distribution parameter of the base samplers, distribution parameter of the actual distribution, number of base samplers, mean of the actual distribution*/</div>
<div class="line">double stdBase = 34;</div>
<div class="line">double std = (1&lt;&lt;22);</div>
<div class="line">int CENTER_COUNT = 1024</div>
<div class="line">double mean = 0;</div>
<div class="line"> </div>
<div class="line">/*Initialize base samplers*/</div>
<div class="line">BaseSampler **peikert_samplers;</div>
<div class="line">for(int i=0;i&lt;CENTER_COUNT;i++){</div>
<div class="line">    double center = ((double)i/(double)CENTER_COUNT);</div>
<div class="line">    peikert_samplers[i]=new BaseSampler((double)center,stdBase,bg,PEIKERT);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">/*Create the sampler object*/</div>
<div class="line">int base = std::log(CENTER_COUNT)/std::log(2);</div>
<div class="line">DiscreteGaussianGeneratorGeneric dggGeneric(peikert_samplers,stdBase,base,SMOOTHING_PARAMETER);</div>
<div class="line"> </div>
<div class="line">/*Generate Integer */</div>
<div class="line">int64_t number = dggGeneric.GenerateInteger(mean,std);</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jan 19 2022 00:47:57 for PALISADE Lattice Crypto Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
