<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PALISADE Lattice Crypto Library: lbcrypto Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PALISADE Lattice Crypto Library
   &#160;<span id="projectnumber">1.11.6</span>
   </div>
   <div id="projectbrief">A lattice crypto library for software engineers by software engineers.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">lbcrypto Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1AdvancedSHEBase.html">AdvancedSHEBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for derived HE algorithms.  <a href="classlbcrypto_1_1AdvancedSHEBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1AdvancedSHEBFVRNS.html">AdvancedSHEBFVRNS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1AdvancedSHEBGVRNS.html">AdvancedSHEBGVRNS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1AdvancedSHECKKSRNS.html">AdvancedSHECKKSRNS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1AdvancedSHERNS.html">AdvancedSHERNS</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for derived HE algorithms.  <a href="classlbcrypto_1_1AdvancedSHERNS.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BaseSampler.html">BaseSampler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BFVRNSParams.html">BFVRNSParams</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BigIntegerInterface.html">BigIntegerInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BigMatrixInterface.html">BigMatrixInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BigVectorInterface.html">BigVectorInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BinaryUniformGeneratorImpl.html">BinaryUniformGeneratorImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generator of the Binary Uniform Distribution.  <a href="classlbcrypto_1_1BinaryUniformGeneratorImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BinFHEContext.html">BinFHEContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classlbcrypto_1_1BinFHEContext.html" title="BinFHEContext.">BinFHEContext</a>.  <a href="classlbcrypto_1_1BinFHEContext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1BitGenerator.html">BitGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1Blake2Engine.html">Blake2Engine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the PRNG engine used by PALISADE. It is based on BLAKE2. Use this as a template for adding other PRNG engines to PALISADE.  <a href="classlbcrypto_1_1Blake2Engine.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1CCParams.html">CCParams</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1CCParams_3_01CryptoContextBFVRNS_01_4.html">CCParams&lt; CryptoContextBFVRNS &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1CCParams_3_01CryptoContextBGVRNS_01_4.html">CCParams&lt; CryptoContextBGVRNS &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1CCParams_3_01CryptoContextCKKSRNS_01_4.html">CCParams&lt; CryptoContextCKKSRNS &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ChineseRemainderTransformArbInterface.html">ChineseRemainderTransformArbInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chinese Remainder Transform for arbitrary cyclotomics.  <a href="classlbcrypto_1_1ChineseRemainderTransformArbInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ChineseRemainderTransformFTTInterface.html">ChineseRemainderTransformFTTInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Golden Chinese Remainder Transform FFT implementation.  <a href="classlbcrypto_1_1ChineseRemainderTransformFTTInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1CiphertextImpl.html">CiphertextImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classlbcrypto_1_1CiphertextImpl.html" title="CiphertextImpl.">CiphertextImpl</a>.  <a href="classlbcrypto_1_1CiphertextImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1CKKSPackedEncoding.html">CKKSPackedEncoding</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used for representing IntArray types. Provides conversion functions to encode and decode plaintext data as type vector&lt;uint64_t&gt;. This class uses bit packing techniques to enable efficient computing on vectors of integers. It is NOT supported for DCRTPoly.  <a href="classlbcrypto_1_1CKKSPackedEncoding.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1CoefPackedEncoding.html">CoefPackedEncoding</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1config__error.html">config_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1CryptoContextBFVRNS.html">CryptoContextBFVRNS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1CryptoContextBGVRNS.html">CryptoContextBGVRNS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1CryptoContextCKKSRNS.html">CryptoContextCKKSRNS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1CryptoContextFactory.html">CryptoContextFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classlbcrypto_1_1CryptoContextFactory.html" title="CryptoContextFactory.">CryptoContextFactory</a>.  <a href="classlbcrypto_1_1CryptoContextFactory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1CryptoContextHelper.html">CryptoContextHelper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1CryptoContextImpl.html">CryptoContextImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classlbcrypto_1_1CryptoContextImpl.html" title="CryptoContextImpl.">CryptoContextImpl</a>.  <a href="classlbcrypto_1_1CryptoContextImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1CryptoObject.html">CryptoObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classlbcrypto_1_1CryptoObject.html" title="CryptoObject.">CryptoObject</a>.  <a href="classlbcrypto_1_1CryptoObject.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1CryptoParametersBase.html">CryptoParametersBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">main implementation class to capture essential cryptoparameters of any LBC system  <a href="classlbcrypto_1_1CryptoParametersBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1CryptoParametersBFVRNS.html">CryptoParametersBFVRNS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1CryptoParametersBGVRNS.html">CryptoParametersBGVRNS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1CryptoParametersCKKSRNS.html">CryptoParametersCKKSRNS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1CryptoParametersRLWE.html">CryptoParametersRLWE</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template for crypto parameters.  <a href="classlbcrypto_1_1CryptoParametersRLWE.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1CryptoParametersRNS.html">CryptoParametersRNS</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">main implementation class to capture essential cryptoparameters of any LBC system  <a href="classlbcrypto_1_1CryptoParametersRNS.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ideal lattice for the double-CRT representation. The implementation contains a vector of underlying native-integer lattices The double-CRT representation of polynomials is a common optimization for lattice encryption operations. Basically, it allows large-modulus polynomials to be represented as multiple smaller-modulus polynomials. The double-CRT representations are discussed theoretically here:  <a href="classlbcrypto_1_1DCRTPolyImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">DCRTPolyInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbcrypto_1_1DecryptResult.html">DecryptResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decryption result. This represents whether the decryption of a cipheretext was performed correctly.  <a href="structlbcrypto_1_1DecryptResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1deserialize__error.html">deserialize_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DiscreteFourierTransform.html">DiscreteFourierTransform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discrete Fourier Transform FFT implementation.  <a href="classlbcrypto_1_1DiscreteFourierTransform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DiscreteGaussianGeneratorGeneric.html">DiscreteGaussianGeneratorGeneric</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class for Generic Discrete Gaussion Distribution generator.  <a href="classlbcrypto_1_1DiscreteGaussianGeneratorGeneric.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DiscreteGaussianGeneratorImpl.html">DiscreteGaussianGeneratorImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class for Discrete Gaussion Distribution generator.  <a href="classlbcrypto_1_1DiscreteGaussianGeneratorImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DiscreteUniformGeneratorImpl.html">DiscreteUniformGeneratorImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class for Discrete Uniform Distribution generator over Zq.  <a href="classlbcrypto_1_1DiscreteUniformGeneratorImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DistributionGenerator.html">DistributionGenerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class describing generator requirements.  <a href="classlbcrypto_1_1DistributionGenerator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ElemParamFactory.html">ElemParamFactory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ElemParams.html">ElemParams</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1EncodingParamsImpl.html">EncodingParamsImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">All parameters for plaintext encodings into ciphertext space.  <a href="classlbcrypto_1_1EncodingParamsImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbcrypto_1_1EncryptResult.html">EncryptResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1EvalKeyImpl.html">EvalKeyImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract interface for evaluation/proxy keys.  <a href="classlbcrypto_1_1EvalKeyImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1EvalKeyRelinImpl.html">EvalKeyRelinImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete class for Relinearization keys of RLWE scheme.  <a href="classlbcrypto_1_1EvalKeyRelinImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1Field2n.html">Field2n</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to represent field elements with power-of-2 dimension.  <a href="classlbcrypto_1_1Field2n.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1HashUtil.html">HashUtil</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">HexlDCRTPoly</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A DCRTPoly Implementation optimized for HEXL, Intel's AVX512 IFMA instructions.  <a href="classlbcrypto_1_1HexlDCRTPoly.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILDCRTParams.html">ILDCRTParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters for array of ideal lattices (used for Double-CRT).  <a href="classlbcrypto_1_1ILDCRTParams.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html">ILElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for ideal lattices.  <a href="classlbcrypto_1_1ILElement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILParamsImpl.html">ILParamsImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1Key.html">Key</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract interface class for Keys.  <a href="classlbcrypto_1_1Key.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1KeyPair.html">KeyPair</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1KeySwitchBase.html">KeySwitchBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract interface class for LBC SHE algorithms.  <a href="classlbcrypto_1_1KeySwitchBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1KeySwitchBV.html">KeySwitchBV</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract interface class for LBC SHE algorithms.  <a href="classlbcrypto_1_1KeySwitchBV.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1KeySwitchHYBRID.html">KeySwitchHYBRID</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract interface class for LBC SHE algorithms.  <a href="classlbcrypto_1_1KeySwitchHYBRID.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1KeySwitchRNS.html">KeySwitchRNS</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract interface class for LBC SHE algorithms.  <a href="classlbcrypto_1_1KeySwitchRNS.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LatticeGaussSampUtility.html">LatticeGaussSampUtility</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class containing operations needed for lattice sampling; Sources: <a href="https://eprint.iacr.org/2017/844.pdf">https://eprint.iacr.org/2017/844.pdf</a> and <a href="https://eprint.iacr.org/2017/308.pdf">https://eprint.iacr.org/2017/308.pdf</a> This construction is based on the hardness of Ring-LWE problem.  <a href="classlbcrypto_1_1LatticeGaussSampUtility.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LeveledSHEBase.html">LeveledSHEBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract interface class for LBC SHE algorithms.  <a href="classlbcrypto_1_1LeveledSHEBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LeveledSHEBFVRNS.html">LeveledSHEBFVRNS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LeveledSHEBGVRNS.html">LeveledSHEBGVRNS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LeveledSHECKKSRNS.html">LeveledSHECKKSRNS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LeveledSHERNS.html">LeveledSHERNS</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract interface class for LBC SHE algorithms.  <a href="classlbcrypto_1_1LeveledSHERNS.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LWECiphertextImpl.html">LWECiphertextImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that stores a LWE scheme ciphertext; composed of a vector "a" and integer "b".  <a href="classlbcrypto_1_1LWECiphertextImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LWECryptoParams.html">LWECryptoParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that stores all parameters for the LWE scheme.  <a href="classlbcrypto_1_1LWECryptoParams.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LWEEncryptionScheme.html">LWEEncryptionScheme</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Additive LWE scheme.  <a href="classlbcrypto_1_1LWEEncryptionScheme.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LWEPrivateKeyImpl.html">LWEPrivateKeyImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that stores the LWE scheme secret key; contains a vector.  <a href="classlbcrypto_1_1LWEPrivateKeyImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LWESwitchingKey.html">LWESwitchingKey</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that stores the LWE scheme switching key.  <a href="classlbcrypto_1_1LWESwitchingKey.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1math__error.html">math_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1MatrixStrassen.html">MatrixStrassen</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1Metadata.html">Metadata</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty metadata container.  <a href="classlbcrypto_1_1Metadata.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1MetadataTest.html">MetadataTest</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Example class inheriting from <a class="el" href="classlbcrypto_1_1Metadata.html" title="Empty metadata container.">Metadata</a> and adding a member. This is used in unit tests.  <a href="classlbcrypto_1_1MetadataTest.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1MultipartyBase.html">MultipartyBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract interface class for LBC Multiparty algorithms based on threshold FHE. A version of this multiparty scheme built on the BGV scheme is seen here:  <a href="classlbcrypto_1_1MultipartyBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1MultipartyBFVRNS.html">MultipartyBFVRNS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1MultipartyBGVRNS.html">MultipartyBGVRNS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1MultipartyCKKSRNS.html">MultipartyCKKSRNS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1MultipartyRNS.html">MultipartyRNS</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract interface class for LBC Multiparty algorithms based on threshold FHE. A version of this multiparty scheme built on the BGV scheme is seen here:  <a href="classlbcrypto_1_1MultipartyRNS.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1not__available__error.html">not_available_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1not__implemented__error.html">not_implemented_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1PackedEncoding.html">PackedEncoding</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used for representing IntArray types. Provides conversion functions to encode and decode plaintext data as type vector&lt;int64_t&gt;. This class uses bit packing techniques to enable efficient computing on vectors of integers. It is NOT supported for DCRTPoly.  <a href="classlbcrypto_1_1PackedEncoding.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1palisade__error.html">palisade_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ParallelControls.html">ParallelControls</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ParameterGenerationBase.html">ParameterGenerationBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract interface for parameter generation algorithm.  <a href="classlbcrypto_1_1ParameterGenerationBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ParameterGenerationBFVRNS.html">ParameterGenerationBFVRNS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ParameterGenerationBGVRNS.html">ParameterGenerationBGVRNS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ParameterGenerationCKKSRNS.html">ParameterGenerationCKKSRNS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ParameterGenerationRNS.html">ParameterGenerationRNS</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract interface for parameter generation algorithm.  <a href="classlbcrypto_1_1ParameterGenerationRNS.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1Params.html">Params</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1PerturbationVector.html">PerturbationVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1PKEBase.html">PKEBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract interface for encryption algorithm.  <a href="classlbcrypto_1_1PKEBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1PKEBFVRNS.html">PKEBFVRNS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1PKEBGVRNS.html">PKEBGVRNS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1PKECKKSRNS.html">PKECKKSRNS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1PKERNS.html">PKERNS</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract interface for encryption algorithm.  <a href="classlbcrypto_1_1PKERNS.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1PlaintextFactory.html">PlaintextFactory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1PlaintextImpl.html">PlaintextImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents plaintext in the Palisade library.  <a href="classlbcrypto_1_1PlaintextImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1PREBase.html">PREBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract interface class for LBC PRE algorithms.  <a href="classlbcrypto_1_1PREBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1PREBFVRNS.html">PREBFVRNS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1PREBGVRNS.html">PREBGVRNS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1PRECKKSRNS.html">PRECKKSRNS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1PRERNS.html">PRERNS</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract interface class for LBC PRE algorithms.  <a href="classlbcrypto_1_1PRERNS.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1PrivateKeyImpl.html">PrivateKeyImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for private key.  <a href="classlbcrypto_1_1PrivateKeyImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1PseudoRandomNumberGenerator.html">PseudoRandomNumberGenerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class providing the PRNG capability to all random distribution generators in PALISADE. THe security of Ring Learning With Errors (used for all crypto capabilities in PALISADE) depends on the randomness of uniform, ternary, and Gaussian distributions, which derive their randomness from the PRNG.  <a href="classlbcrypto_1_1PseudoRandomNumberGenerator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1PublicKeyImpl.html">PublicKeyImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for public key.  <a href="classlbcrypto_1_1PublicKeyImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1RingGSWAccumulatorScheme.html">RingGSWAccumulatorScheme</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ring GSW accumulator schemes described in <a href="https://eprint.iacr.org/2014/816">https://eprint.iacr.org/2014/816</a> and "Bootstrapping in FHEW-like
Cryptosystems".  <a href="classlbcrypto_1_1RingGSWAccumulatorScheme.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1RingGSWBTKey.html">RingGSWBTKey</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that stores the refreshing key (used in bootstrapping) A three-dimensional vector of RingGSW ciphertexts.  <a href="classlbcrypto_1_1RingGSWBTKey.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1RingGSWCiphertext.html">RingGSWCiphertext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that stores a RingGSW ciphertext; a two-dimensional vector of ring elements.  <a href="classlbcrypto_1_1RingGSWCiphertext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1RingGSWCryptoParams.html">RingGSWCryptoParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that stores all parameters for the RingGSW scheme used in bootstrapping.  <a href="classlbcrypto_1_1RingGSWCryptoParams.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbcrypto_1_1RingGSWEvalKey.html">RingGSWEvalKey</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1RLWETrapdoorPair.html">RLWETrapdoorPair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to store a lattice trapdoor pair generated using construction 1 in section 3.2 of <a href="https://eprint.iacr.org/2013/297.pdf">https://eprint.iacr.org/2013/297.pdf</a> This construction is based on the hardness of Ring-LWE problem.  <a href="classlbcrypto_1_1RLWETrapdoorPair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1RLWETrapdoorParams.html">RLWETrapdoorParams</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1RLWETrapdoorUtility.html">RLWETrapdoorUtility</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static class implementing lattice trapdoor construction in Algorithm 1 of <a href="https://eprint.iacr.org/2017/844.pdf">https://eprint.iacr.org/2017/844.pdf</a>.  <a href="classlbcrypto_1_1RLWETrapdoorUtility.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1SamplerCombiner.html">SamplerCombiner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1SchemeBase.html">SchemeBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract interface for public key encryption schemes.  <a href="classlbcrypto_1_1SchemeBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1SchemeBFVRNS.html">SchemeBFVRNS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1SchemeBGVRNS.html">SchemeBGVRNS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1SchemeCKKSRNS.html">SchemeCKKSRNS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1SchemeRNS.html">SchemeRNS</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract interface class for LBC PRE algorithms.  <a href="classlbcrypto_1_1SchemeRNS.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1Serializable.html">Serializable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for PALISADE serialization.  <a href="classlbcrypto_1_1Serializable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1serialize__error.html">serialize_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1StdLatticeParm.html">StdLatticeParm</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1StringEncoding.html">StringEncoding</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1TernaryUniformGeneratorImpl.html">TernaryUniformGeneratorImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generator of the Ternary Uniform Distribution.  <a href="classlbcrypto_1_1TernaryUniformGeneratorImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ThreadException.html">ThreadException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1TrapdoorParams.html">TrapdoorParams</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1type__error.html">type_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:acb452b027d6b45975db6bfd9ccbb9f6d"><td class="memItemLeft" align="right" valign="top"><a id="acb452b027d6b45975db6bfd9ccbb9f6d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>LWECiphertext</b> = std::shared_ptr&lt; <a class="el" href="classlbcrypto_1_1LWECiphertextImpl.html">LWECiphertextImpl</a> &gt;</td></tr>
<tr class="separator:acb452b027d6b45975db6bfd9ccbb9f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1957028112ca83b8c9a4989bfe0ed577"><td class="memItemLeft" align="right" valign="top"><a id="a1957028112ca83b8c9a4989bfe0ed577"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ConstLWECiphertext</b> = const std::shared_ptr&lt; const <a class="el" href="classlbcrypto_1_1LWECiphertextImpl.html">LWECiphertextImpl</a> &gt;</td></tr>
<tr class="separator:a1957028112ca83b8c9a4989bfe0ed577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8df2266f82e0607db5a7da413685837d"><td class="memItemLeft" align="right" valign="top"><a id="a8df2266f82e0607db5a7da413685837d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>LWEPrivateKey</b> = std::shared_ptr&lt; <a class="el" href="classlbcrypto_1_1LWEPrivateKeyImpl.html">LWEPrivateKeyImpl</a> &gt;</td></tr>
<tr class="separator:a8df2266f82e0607db5a7da413685837d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12fd5403427bb21b4822646f12263bfe"><td class="memItemLeft" align="right" valign="top"><a id="a12fd5403427bb21b4822646f12263bfe"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ConstLWEPrivateKey</b> = const std::shared_ptr&lt; const <a class="el" href="classlbcrypto_1_1LWEPrivateKeyImpl.html">LWEPrivateKeyImpl</a> &gt;</td></tr>
<tr class="separator:a12fd5403427bb21b4822646f12263bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b8efda4e3c084ded9c8a420a3b753f"><td class="memItemLeft" align="right" valign="top"><a id="a56b8efda4e3c084ded9c8a420a3b753f"></a>
typedef int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>LWEPlaintext</b></td></tr>
<tr class="separator:a56b8efda4e3c084ded9c8a420a3b753f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab596cfa1ae084f4959fac5ac2ea98ff"><td class="memItemLeft" align="right" valign="top"><a id="aab596cfa1ae084f4959fac5ac2ea98ff"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>M2DCRTPoly</b> = <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; <a class="el" href="classbigintfxd_1_1BigVectorFixedT.html">M2Vector</a> &gt;</td></tr>
<tr class="separator:aab596cfa1ae084f4959fac5ac2ea98ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c957f1c77e851c454e74da158eac835"><td class="memItemLeft" align="right" valign="top"><a id="a4c957f1c77e851c454e74da158eac835"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>M4DCRTPoly</b> = <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; <a class="el" href="classbigintdyn_1_1mubintvec.html">M4Vector</a> &gt;</td></tr>
<tr class="separator:a4c957f1c77e851c454e74da158eac835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad76306e7b1e24ed6c1cf384444aae463"><td class="memItemLeft" align="right" valign="top"><a id="ad76306e7b1e24ed6c1cf384444aae463"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>M6DCRTPoly</b> = <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; <a class="el" href="classNTL_1_1myVecP.html">M6Vector</a> &gt;</td></tr>
<tr class="separator:ad76306e7b1e24ed6c1cf384444aae463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac7ac88e7bdac5dd5e30483734a93187"><td class="memItemLeft" align="right" valign="top"><a id="aac7ac88e7bdac5dd5e30483734a93187"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>DCRTPoly</b> = <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; <a class="el" href="classbigintfxd_1_1BigVectorFixedT.html">BigVector</a> &gt;</td></tr>
<tr class="separator:aac7ac88e7bdac5dd5e30483734a93187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad54c9c58e793331d0f54b67a69c786"><td class="memItemLeft" align="right" valign="top"><a id="a7ad54c9c58e793331d0f54b67a69c786"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>M2Poly</b> = <a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyImpl</a>&lt; <a class="el" href="classbigintfxd_1_1BigVectorFixedT.html">M2Vector</a> &gt;</td></tr>
<tr class="separator:a7ad54c9c58e793331d0f54b67a69c786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf166fc3b07a8ad6c042ff38abf2998f"><td class="memItemLeft" align="right" valign="top"><a id="adf166fc3b07a8ad6c042ff38abf2998f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>M4Poly</b> = <a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyImpl</a>&lt; <a class="el" href="classbigintdyn_1_1mubintvec.html">M4Vector</a> &gt;</td></tr>
<tr class="separator:adf166fc3b07a8ad6c042ff38abf2998f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f75760ba143b30aeae401110646151"><td class="memItemLeft" align="right" valign="top"><a id="a26f75760ba143b30aeae401110646151"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>M6Poly</b> = <a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyImpl</a>&lt; <a class="el" href="classNTL_1_1myVecP.html">M6Vector</a> &gt;</td></tr>
<tr class="separator:a26f75760ba143b30aeae401110646151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7e617843cb0392e88d4de1cde5024fa"><td class="memItemLeft" align="right" valign="top"><a id="ab7e617843cb0392e88d4de1cde5024fa"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>NativePoly</b> = <a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyImpl</a>&lt; <a class="el" href="classintnat_1_1NativeVectorT.html">NativeVector</a> &gt;</td></tr>
<tr class="separator:ab7e617843cb0392e88d4de1cde5024fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a879c36f72dcc919e303d0a2367195b6e"><td class="memItemLeft" align="right" valign="top"><a id="a879c36f72dcc919e303d0a2367195b6e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>NativePoly64</b> = <a class="el" href="classlbcrypto_1_1PolyImpl.html">NativePoly</a></td></tr>
<tr class="separator:a879c36f72dcc919e303d0a2367195b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7329905b9315a3eb0feb2f46e1472813"><td class="memItemLeft" align="right" valign="top"><a id="a7329905b9315a3eb0feb2f46e1472813"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>M2Params</b> = <a class="el" href="classlbcrypto_1_1ILParamsImpl.html">ILParamsImpl</a>&lt; <a class="el" href="classbigintfxd_1_1BigIntegerFixedT.html">M2Integer</a> &gt;</td></tr>
<tr class="separator:a7329905b9315a3eb0feb2f46e1472813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9229072a6450cd6fb829af044f12472"><td class="memItemLeft" align="right" valign="top"><a id="ab9229072a6450cd6fb829af044f12472"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>M4Params</b> = <a class="el" href="classlbcrypto_1_1ILParamsImpl.html">ILParamsImpl</a>&lt; <a class="el" href="classbigintdyn_1_1ubint.html">M4Integer</a> &gt;</td></tr>
<tr class="separator:ab9229072a6450cd6fb829af044f12472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f028fdb6bea0a0002a6636eb00bb0e"><td class="memItemLeft" align="right" valign="top"><a id="a03f028fdb6bea0a0002a6636eb00bb0e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>M6Params</b> = <a class="el" href="classlbcrypto_1_1ILParamsImpl.html">ILParamsImpl</a>&lt; <a class="el" href="classNTL_1_1myZZ.html">M6Integer</a> &gt;</td></tr>
<tr class="separator:a03f028fdb6bea0a0002a6636eb00bb0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38f596c82337bbefd48be5703fe6b49a"><td class="memItemLeft" align="right" valign="top"><a id="a38f596c82337bbefd48be5703fe6b49a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ILNativeParams</b> = <a class="el" href="classlbcrypto_1_1ILParamsImpl.html">ILParamsImpl</a>&lt; <a class="el" href="classintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;</td></tr>
<tr class="separator:a38f596c82337bbefd48be5703fe6b49a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1709e408f7fa979336b70b7f2aea625b"><td class="memItemLeft" align="right" valign="top"><a id="a1709e408f7fa979336b70b7f2aea625b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ILParams</b> = <a class="el" href="classlbcrypto_1_1ILParamsImpl.html">ILParamsImpl</a>&lt; <a class="el" href="classbigintfxd_1_1BigIntegerFixedT.html">BigInteger</a> &gt;</td></tr>
<tr class="separator:a1709e408f7fa979336b70b7f2aea625b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90fe3c0e0f3e78912d70f3e0e058a087"><td class="memItemLeft" align="right" valign="top"><a id="a90fe3c0e0f3e78912d70f3e0e058a087"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Poly</b> = <a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyImpl</a>&lt; <a class="el" href="classbigintfxd_1_1BigVectorFixedT.html">BigVector</a> &gt;</td></tr>
<tr class="separator:a90fe3c0e0f3e78912d70f3e0e058a087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20d82255e806fefb9c964eb9f4e10ca1"><td class="memItemLeft" align="right" valign="top"><a id="a20d82255e806fefb9c964eb9f4e10ca1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>M2DCRTParams</b> = <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">ILDCRTParams</a>&lt; <a class="el" href="classbigintfxd_1_1BigIntegerFixedT.html">M2Integer</a> &gt;</td></tr>
<tr class="separator:a20d82255e806fefb9c964eb9f4e10ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59ff30262a37fc59d0ca3e042ac5181e"><td class="memItemLeft" align="right" valign="top"><a id="a59ff30262a37fc59d0ca3e042ac5181e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>M4DCRTParams</b> = <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">ILDCRTParams</a>&lt; <a class="el" href="classbigintdyn_1_1ubint.html">M4Integer</a> &gt;</td></tr>
<tr class="separator:a59ff30262a37fc59d0ca3e042ac5181e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da6c2941bef73818d8584714e28c832"><td class="memItemLeft" align="right" valign="top"><a id="a2da6c2941bef73818d8584714e28c832"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>M6DCRTParams</b> = <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">ILDCRTParams</a>&lt; <a class="el" href="classNTL_1_1myZZ.html">M6Integer</a> &gt;</td></tr>
<tr class="separator:a2da6c2941bef73818d8584714e28c832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4766b825dff31cb59050598fd72240"><td class="memItemLeft" align="right" valign="top"><a id="a6e4766b825dff31cb59050598fd72240"></a>
typedef <a class="el" href="classlbcrypto_1_1BinaryUniformGeneratorImpl.html">BinaryUniformGeneratorImpl</a>&lt; <a class="el" href="classbigintfxd_1_1BigVectorFixedT.html">BigVector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>BinaryUniformGenerator</b></td></tr>
<tr class="separator:a6e4766b825dff31cb59050598fd72240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae64a47372b2ec762ffe104d5afbb8923"><td class="memItemLeft" align="right" valign="top"><a id="ae64a47372b2ec762ffe104d5afbb8923"></a>
typedef <a class="el" href="classlbcrypto_1_1DiscreteGaussianGeneratorImpl.html">DiscreteGaussianGeneratorImpl</a>&lt; <a class="el" href="classbigintfxd_1_1BigVectorFixedT.html">BigVector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>DiscreteGaussianGenerator</b></td></tr>
<tr class="separator:ae64a47372b2ec762ffe104d5afbb8923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0383d23ad4c867a07e99b3d9aca606ff"><td class="memItemLeft" align="right" valign="top"><a id="a0383d23ad4c867a07e99b3d9aca606ff"></a>
typedef <a class="el" href="classlbcrypto_1_1DiscreteUniformGeneratorImpl.html">DiscreteUniformGeneratorImpl</a>&lt; <a class="el" href="classbigintfxd_1_1BigVectorFixedT.html">BigVector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>DiscreteUniformGenerator</b></td></tr>
<tr class="separator:a0383d23ad4c867a07e99b3d9aca606ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39744f8943455dfd3c0396f00879c31b"><td class="memItemLeft" align="right" valign="top"><a id="a39744f8943455dfd3c0396f00879c31b"></a>
typedef <a class="el" href="classlbcrypto_1_1Blake2Engine.html">Blake2Engine</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PRNG</b></td></tr>
<tr class="separator:a39744f8943455dfd3c0396f00879c31b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b4ab633afcd8b9a0b07affb00a6aeec"><td class="memItemLeft" align="right" valign="top"><a id="a8b4ab633afcd8b9a0b07affb00a6aeec"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>NativeInteger</b> = <a class="el" href="classintnat_1_1NativeIntegerT.html">intnat::NativeInteger</a></td></tr>
<tr class="separator:a8b4ab633afcd8b9a0b07affb00a6aeec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20f534c99ab5b54df1ac758ab0cd8ba8"><td class="memItemLeft" align="right" valign="top"><a id="a20f534c99ab5b54df1ac758ab0cd8ba8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>NativeVector</b> = <a class="el" href="classintnat_1_1NativeVectorT.html">intnat::NativeVector</a></td></tr>
<tr class="separator:a20f534c99ab5b54df1ac758ab0cd8ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff5741e770603d62450fa066635e0846"><td class="memItemLeft" align="right" valign="top"><a id="aff5741e770603d62450fa066635e0846"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>BigInteger</b> = <a class="el" href="classbigintfxd_1_1BigIntegerFixedT.html">bigintbackend::BigInteger</a></td></tr>
<tr class="separator:aff5741e770603d62450fa066635e0846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a178d50f43e54d1e4db7efef0d423e082"><td class="memItemLeft" align="right" valign="top"><a id="a178d50f43e54d1e4db7efef0d423e082"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>BigVector</b> = <a class="el" href="classbigintfxd_1_1BigVectorFixedT.html">bigintbackend::BigVector</a></td></tr>
<tr class="separator:a178d50f43e54d1e4db7efef0d423e082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee2cfbc857eb5edb8841334ef8f44b3e"><td class="memItemLeft" align="right" valign="top"><a id="aee2cfbc857eb5edb8841334ef8f44b3e"></a>
typedef <a class="el" href="classlbcrypto_1_1TernaryUniformGeneratorImpl.html">TernaryUniformGeneratorImpl</a>&lt; <a class="el" href="classbigintfxd_1_1BigVectorFixedT.html">BigVector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>TernaryUniformGenerator</b></td></tr>
<tr class="separator:aee2cfbc857eb5edb8841334ef8f44b3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a930dee614f630e52e60e5ded508a5f63"><td class="memItemLeft" align="right" valign="top"><a id="a930dee614f630e52e60e5ded508a5f63"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Serialized</b> = void *</td></tr>
<tr class="separator:a930dee614f630e52e60e5ded508a5f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa03aa0d7229109becc0dcac009716fd"><td class="memTemplParams" colspan="2"><a id="aaa03aa0d7229109becc0dcac009716fd"></a>
template&lt;typename Element &gt; </td></tr>
<tr class="memitem:aaa03aa0d7229109becc0dcac009716fd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Ciphertext</b> = shared_ptr&lt; <a class="el" href="classlbcrypto_1_1CiphertextImpl.html">CiphertextImpl</a>&lt; Element &gt; &gt;</td></tr>
<tr class="separator:aaa03aa0d7229109becc0dcac009716fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8bec8b36d441f1a0c84986ce45f8275"><td class="memTemplParams" colspan="2"><a id="ae8bec8b36d441f1a0c84986ce45f8275"></a>
template&lt;typename Element &gt; </td></tr>
<tr class="memitem:ae8bec8b36d441f1a0c84986ce45f8275"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ConstCiphertext</b> = shared_ptr&lt; const <a class="el" href="classlbcrypto_1_1CiphertextImpl.html">CiphertextImpl</a>&lt; Element &gt; &gt;</td></tr>
<tr class="separator:ae8bec8b36d441f1a0c84986ce45f8275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6443ca2b0d18f9fef302de7962b61270"><td class="memTemplParams" colspan="2"><a id="a6443ca2b0d18f9fef302de7962b61270"></a>
template&lt;typename Element &gt; </td></tr>
<tr class="memitem:a6443ca2b0d18f9fef302de7962b61270"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>CryptoContext</b> = shared_ptr&lt; <a class="el" href="classlbcrypto_1_1CryptoContextImpl.html">CryptoContextImpl</a>&lt; Element &gt; &gt;</td></tr>
<tr class="separator:a6443ca2b0d18f9fef302de7962b61270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71e85d54635ea5ff11db11641cc026d1"><td class="memItemLeft" align="right" valign="top"><a id="a71e85d54635ea5ff11db11641cc026d1"></a>
typedef std::shared_ptr&lt; <a class="el" href="classlbcrypto_1_1EncodingParamsImpl.html">EncodingParamsImpl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EncodingParams</b></td></tr>
<tr class="separator:a71e85d54635ea5ff11db11641cc026d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8966403776b0a00a4a72be555e0d3326"><td class="memItemLeft" align="right" valign="top"><a id="a8966403776b0a00a4a72be555e0d3326"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ModulusM</b> = std::pair&lt; <a class="el" href="classintnat_1_1NativeIntegerT.html">NativeInteger</a>, uint64_t &gt;</td></tr>
<tr class="separator:a8966403776b0a00a4a72be555e0d3326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab53c2c742bf4ace22f847ad1f4c49eba"><td class="memItemLeft" align="right" valign="top"><a id="ab53c2c742bf4ace22f847ad1f4c49eba"></a>
typedef shared_ptr&lt; <a class="el" href="classlbcrypto_1_1PlaintextImpl.html">PlaintextImpl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Plaintext</b></td></tr>
<tr class="separator:ab53c2c742bf4ace22f847ad1f4c49eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a653ac37bcbdcbb467a98f80c399c830e"><td class="memItemLeft" align="right" valign="top"><a id="a653ac37bcbdcbb467a98f80c399c830e"></a>
typedef shared_ptr&lt; const <a class="el" href="classlbcrypto_1_1PlaintextImpl.html">PlaintextImpl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ConstPlaintext</b></td></tr>
<tr class="separator:a653ac37bcbdcbb467a98f80c399c830e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96417f3a88348a52c32c0d4ee3dacdda"><td class="memTemplParams" colspan="2"><a id="a96417f3a88348a52c32c0d4ee3dacdda"></a>
template&lt;typename Element &gt; </td></tr>
<tr class="memitem:a96417f3a88348a52c32c0d4ee3dacdda"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>EvalKey</b> = shared_ptr&lt; <a class="el" href="classlbcrypto_1_1EvalKeyImpl.html">EvalKeyImpl</a>&lt; Element &gt; &gt;</td></tr>
<tr class="separator:a96417f3a88348a52c32c0d4ee3dacdda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac94898a5b3c3d751ea989bff88ce3a43"><td class="memTemplParams" colspan="2"><a id="ac94898a5b3c3d751ea989bff88ce3a43"></a>
template&lt;typename Element &gt; </td></tr>
<tr class="memitem:ac94898a5b3c3d751ea989bff88ce3a43"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>EvalKeyRelin</b> = shared_ptr&lt; <a class="el" href="classlbcrypto_1_1EvalKeyRelinImpl.html">EvalKeyRelinImpl</a>&lt; Element &gt; &gt;</td></tr>
<tr class="separator:ac94898a5b3c3d751ea989bff88ce3a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1656106fcc2fba1eaf163b4acbefb368"><td class="memTemplParams" colspan="2"><a id="a1656106fcc2fba1eaf163b4acbefb368"></a>
template&lt;typename Element &gt; </td></tr>
<tr class="memitem:a1656106fcc2fba1eaf163b4acbefb368"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PrivateKey</b> = shared_ptr&lt; <a class="el" href="classlbcrypto_1_1PrivateKeyImpl.html">PrivateKeyImpl</a>&lt; Element &gt; &gt;</td></tr>
<tr class="separator:a1656106fcc2fba1eaf163b4acbefb368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab31a71355cd66838e27cc97c3aa282e3"><td class="memTemplParams" colspan="2"><a id="ab31a71355cd66838e27cc97c3aa282e3"></a>
template&lt;typename Element &gt; </td></tr>
<tr class="memitem:ab31a71355cd66838e27cc97c3aa282e3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PublicKey</b> = shared_ptr&lt; <a class="el" href="classlbcrypto_1_1PublicKeyImpl.html">PublicKeyImpl</a>&lt; Element &gt; &gt;</td></tr>
<tr class="separator:ab31a71355cd66838e27cc97c3aa282e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ac6d7a95dae768cf7ca79a9e9479348"><td class="memItemLeft" align="right" valign="top"><a id="a3ac6d7a95dae768cf7ca79a9e9479348"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>MetadataMap</b> = std::shared_ptr&lt; std::map&lt; std::string, std::shared_ptr&lt; <a class="el" href="classlbcrypto_1_1Metadata.html">Metadata</a> &gt; &gt;&gt;</td></tr>
<tr class="separator:a3ac6d7a95dae768cf7ca79a9e9479348"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ac4087718d0968e40825da01a08c0d45c"><td class="memItemLeft" align="right" valign="top"><a id="ac4087718d0968e40825da01a08c0d45c"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>BINFHEPARAMSET</b> { <br />
&#160;&#160;<b>TOY</b>, 
<b>MEDIUM</b>, 
<b>STD128</b>, 
<b>STD128_AP</b>, 
<br />
&#160;&#160;<b>STD192</b>, 
<b>STD256</b>, 
<b>STD128Q</b>, 
<b>STD192Q</b>, 
<br />
&#160;&#160;<b>STD256Q</b>, 
<b>SIGNED_MOD_TEST</b>
<br />
 }</td></tr>
<tr class="separator:ac4087718d0968e40825da01a08c0d45c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b5938709a6b546de8e6949b77501cdf"><td class="memItemLeft" align="right" valign="top"><a id="a2b5938709a6b546de8e6949b77501cdf"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>BINFHEOUTPUT</b> { <b>FRESH</b>, 
<b>BOOTSTRAPPED</b>
 }</td></tr>
<tr class="separator:a2b5938709a6b546de8e6949b77501cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad083dfcb0afef5e6c196324c9d9f1657"><td class="memItemLeft" align="right" valign="top"><a id="ad083dfcb0afef5e6c196324c9d9f1657"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>BINGATE</b> { <br />
&#160;&#160;<b>OR</b>, 
<b>AND</b>, 
<b>NOR</b>, 
<b>NAND</b>, 
<br />
&#160;&#160;<b>XOR_FAST</b>, 
<b>XNOR_FAST</b>, 
<b>XOR</b>, 
<b>XNOR</b>
<br />
 }</td></tr>
<tr class="separator:ad083dfcb0afef5e6c196324c9d9f1657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9974696e749981821c3de69d0c28e4b0"><td class="memItemLeft" align="right" valign="top"><a id="a9974696e749981821c3de69d0c28e4b0"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>BINFHEMETHOD</b> { <b>AP</b>, 
<b>GINX</b>
 }</td></tr>
<tr class="separator:a9974696e749981821c3de69d0c28e4b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa58d47fa2687f817ac30adb387ed6579"><td class="memItemLeft" align="right" valign="top"><a id="aa58d47fa2687f817ac30adb387ed6579"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>ElementOrder</b> { <br />
&#160;&#160;<b>M16</b> = 0, 
<b>M1024</b>, 
<b>M2048</b>, 
<b>M4096</b>, 
<br />
&#160;&#160;<b>M8192</b>, 
<b>M16384</b>, 
<b>M32768</b>
<br />
 }</td></tr>
<tr class="separator:aa58d47fa2687f817ac30adb387ed6579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0906a90d9338aad421dc11f40959c3d0"><td class="memItemLeft" align="right" valign="top"><a id="a0906a90d9338aad421dc11f40959c3d0"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>DistributionType</b> { <b>HEStd_uniform</b>, 
<b>HEStd_error</b>, 
<b>HEStd_ternary</b>
 }</td></tr>
<tr class="separator:a0906a90d9338aad421dc11f40959c3d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c98d1b524fe1bf640d0edf5e5572159"><td class="memItemLeft" align="right" valign="top"><a id="a9c98d1b524fe1bf640d0edf5e5572159"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>SecurityLevel</b> { <b>HEStd_128_classic</b>, 
<b>HEStd_192_classic</b>, 
<b>HEStd_256_classic</b>, 
<b>HEStd_NotSet</b>
 }</td></tr>
<tr class="separator:a9c98d1b524fe1bf640d0edf5e5572159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0afb7b25fc20bb8658ef8a19de2d3243"><td class="memItemLeft" align="right" valign="top"><a id="a0afb7b25fc20bb8658ef8a19de2d3243"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>BaseSamplerType</b> { <b>KNUTH_YAO</b> = 0, 
<b>PEIKERT</b> = 1
 }</td></tr>
<tr class="separator:a0afb7b25fc20bb8658ef8a19de2d3243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba203dcd773b912f00faac96d3f777c"><td class="memItemLeft" align="right" valign="top"><a id="a1ba203dcd773b912f00faac96d3f777c"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>HashAlgorithm</b> { <b>SHA_256</b> = 0, 
<b>SHA_512</b> = 1
 }</td></tr>
<tr class="separator:a1ba203dcd773b912f00faac96d3f777c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f4c056a70645ce3a80ff8db0eebed0d"><td class="memItemLeft" align="right" valign="top"><a id="a8f4c056a70645ce3a80ff8db0eebed0d"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>PlaintextEncodings</b> { <br />
&#160;&#160;<b>Unknown</b> = 0, 
<b>CoefPacked</b>, 
<b>Packed</b>, 
<b>String</b>, 
<br />
&#160;&#160;<b>CKKSPacked</b>
<br />
 }</td></tr>
<tr class="separator:a8f4c056a70645ce3a80ff8db0eebed0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a083850058f7006d5db58de395bae931b"><td class="memItemLeft" align="right" valign="top"><a id="a083850058f7006d5db58de395bae931b"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>PtxtPolyType</b> { <b>IsPoly</b>, 
<b>IsDCRTPoly</b>, 
<b>IsNativePoly</b>
 }</td></tr>
<tr class="separator:a083850058f7006d5db58de395bae931b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6727ff348994e398764880ef0bdf1fed"><td class="memItemLeft" align="right" valign="top"><a id="a6727ff348994e398764880ef0bdf1fed"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>SCHEME</b> { <b>CKKSRNS_SCHEME</b>, 
<b>BFVRNS_SCHEME</b>, 
<b>BGVRNS_SCHEME</b>, 
<b>INVALID_SCHEME</b>
 }</td></tr>
<tr class="separator:a6727ff348994e398764880ef0bdf1fed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab44995ae273c6bd81a72c8fb9b869839"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#ab44995ae273c6bd81a72c8fb9b869839">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classlbcrypto_1_1Field2n.html">Field2n</a> &amp;m)</td></tr>
<tr class="memdesc:ab44995ae273c6bd81a72c8fb9b869839"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream output operator.  <a href="namespacelbcrypto.html#ab44995ae273c6bd81a72c8fb9b869839">More...</a><br /></td></tr>
<tr class="separator:ab44995ae273c6bd81a72c8fb9b869839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a4b2d09c13153d7fe1c01a37004abbc"><td class="memItemLeft" align="right" valign="top"><a id="a9a4b2d09c13153d7fe1c01a37004abbc"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;s, SecurityLevel sl)</td></tr>
<tr class="separator:a9a4b2d09c13153d7fe1c01a37004abbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae38ba77d200565e23d4f21067a2db89f"><td class="memTemplParams" colspan="2">template&lt;class Element &gt; </td></tr>
<tr class="memitem:ae38ba77d200565e23d4f21067a2db89f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; Element &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#ae38ba77d200565e23d4f21067a2db89f">operator*</a> (Element const &amp;e, <a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; Element &gt; const &amp;M)</td></tr>
<tr class="separator:ae38ba77d200565e23d4f21067a2db89f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cefda2cd901845642ee8445a611db79"><td class="memTemplParams" colspan="2">template&lt;typename Element &gt; </td></tr>
<tr class="memitem:a3cefda2cd901845642ee8445a611db79"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; typename Element::Integer &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#a3cefda2cd901845642ee8445a611db79">Rotate</a> (<a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; Element &gt; const &amp;inMat)</td></tr>
<tr class="separator:a3cefda2cd901845642ee8445a611db79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa6bc09bac6f4dcdf95ffe767d51a1f2"><td class="memTemplParams" colspan="2">template&lt;typename Element &gt; </td></tr>
<tr class="memitem:aaa6bc09bac6f4dcdf95ffe767d51a1f2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; typename Element::Vector &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#aaa6bc09bac6f4dcdf95ffe767d51a1f2">RotateVecResult</a> (<a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; Element &gt; const &amp;inMat)</td></tr>
<tr class="separator:aaa6bc09bac6f4dcdf95ffe767d51a1f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f14c6661dccbdf2203415b63772b8c0"><td class="memTemplParams" colspan="2">template&lt;class Element &gt; </td></tr>
<tr class="memitem:a2f14c6661dccbdf2203415b63772b8c0"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#a2f14c6661dccbdf2203415b63772b8c0">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; Element &gt; &amp;m)</td></tr>
<tr class="separator:a2f14c6661dccbdf2203415b63772b8c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6893ac584a13976b1ce006a926cdcf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#ae6893ac584a13976b1ce006a926cdcf5">Cholesky</a> (const <a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; int32_t &gt; &amp;input)</td></tr>
<tr class="separator:ae6893ac584a13976b1ce006a926cdcf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ea1f433c90f90b727e87977f698c869"><td class="memItemLeft" align="right" valign="top"><a id="a3ea1f433c90f90b727e87977f698c869"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Cholesky</b> (const <a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; int32_t &gt; &amp;input, <a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; double &gt; &amp;result)</td></tr>
<tr class="separator:a3ea1f433c90f90b727e87977f698c869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60610bbb3daecf8c10b1eef358ae04ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#a60610bbb3daecf8c10b1eef358ae04ab">ConvertToInt32</a> (const <a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="classbigintfxd_1_1BigIntegerFixedT.html">BigInteger</a> &gt; &amp;input, const <a class="el" href="classbigintfxd_1_1BigIntegerFixedT.html">BigInteger</a> &amp;modulus)</td></tr>
<tr class="separator:a60610bbb3daecf8c10b1eef358ae04ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a5d674ba2861436dcaac4b88a68d9ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#a2a5d674ba2861436dcaac4b88a68d9ab">ConvertToInt32</a> (const <a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="classbigintfxd_1_1BigVectorFixedT.html">BigVector</a> &gt; &amp;input, const <a class="el" href="classbigintfxd_1_1BigIntegerFixedT.html">BigInteger</a> &amp;modulus)</td></tr>
<tr class="separator:a2a5d674ba2861436dcaac4b88a68d9ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9512202df07e2b7eb423ecbbfcc23a32"><td class="memTemplParams" colspan="2">template&lt;typename Element &gt; </td></tr>
<tr class="memitem:a9512202df07e2b7eb423ecbbfcc23a32"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; Element &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#a9512202df07e2b7eb423ecbbfcc23a32">SplitInt64IntoElements</a> (<a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; int64_t &gt; const &amp;other, size_t n, const shared_ptr&lt; typename Element::Params &gt; params)</td></tr>
<tr class="separator:a9512202df07e2b7eb423ecbbfcc23a32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a33e10aa63a9fd8c929dafd8aee7b6"><td class="memTemplParams" colspan="2">template&lt;typename Element &gt; </td></tr>
<tr class="memitem:aa8a33e10aa63a9fd8c929dafd8aee7b6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; Element &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#aa8a33e10aa63a9fd8c929dafd8aee7b6">SplitInt32AltIntoElements</a> (<a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; int32_t &gt; const &amp;other, size_t n, const shared_ptr&lt; typename Element::Params &gt; params)</td></tr>
<tr class="separator:aa8a33e10aa63a9fd8c929dafd8aee7b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf38638d42ac39f3b143bd5d89150b02"><td class="memTemplParams" colspan="2">template&lt;typename Element &gt; </td></tr>
<tr class="memitem:acf38638d42ac39f3b143bd5d89150b02"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; Element &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#acf38638d42ac39f3b143bd5d89150b02">SplitInt64AltIntoElements</a> (<a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; int64_t &gt; const &amp;other, size_t n, const shared_ptr&lt; typename Element::Params &gt; params)</td></tr>
<tr class="separator:acf38638d42ac39f3b143bd5d89150b02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8405776d94662169fd35fbb408e2059f"><td class="memTemplParams" colspan="2">template&lt;class Element &gt; </td></tr>
<tr class="memitem:a8405776d94662169fd35fbb408e2059f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlbcrypto_1_1MatrixStrassen.html">MatrixStrassen</a>&lt; Element &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#a8405776d94662169fd35fbb408e2059f">operator*</a> (Element const &amp;e, <a class="el" href="classlbcrypto_1_1MatrixStrassen.html">MatrixStrassen</a>&lt; Element &gt; const &amp;M)</td></tr>
<tr class="separator:a8405776d94662169fd35fbb408e2059f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b4318674b09868cabf55377395c95f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlbcrypto_1_1MatrixStrassen.html">MatrixStrassen</a>&lt; <a class="el" href="classbigintfxd_1_1BigIntegerFixedT.html">BigInteger</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#a7b4318674b09868cabf55377395c95f7">Rotate</a> (<a class="el" href="classlbcrypto_1_1MatrixStrassen.html">MatrixStrassen</a>&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">Poly</a> &gt; const &amp;inMat)</td></tr>
<tr class="separator:a7b4318674b09868cabf55377395c95f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cc5c6579eefc968b53d4dffc29cde26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlbcrypto_1_1MatrixStrassen.html">MatrixStrassen</a>&lt; <a class="el" href="classbigintfxd_1_1BigVectorFixedT.html">BigVector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#a9cc5c6579eefc968b53d4dffc29cde26">RotateVecResult</a> (<a class="el" href="classlbcrypto_1_1MatrixStrassen.html">MatrixStrassen</a>&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">Poly</a> &gt; const &amp;inMat)</td></tr>
<tr class="separator:a9cc5c6579eefc968b53d4dffc29cde26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a515ae2c54669e003b1da7d36835e4ed4"><td class="memTemplParams" colspan="2">template&lt;class Element &gt; </td></tr>
<tr class="memitem:a515ae2c54669e003b1da7d36835e4ed4"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#a515ae2c54669e003b1da7d36835e4ed4">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classlbcrypto_1_1MatrixStrassen.html">MatrixStrassen</a>&lt; Element &gt; &amp;m)</td></tr>
<tr class="separator:a515ae2c54669e003b1da7d36835e4ed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5c05572022280760b58ee47de218743"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlbcrypto_1_1MatrixStrassen.html">MatrixStrassen</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#aa5c05572022280760b58ee47de218743">Cholesky</a> (const <a class="el" href="classlbcrypto_1_1MatrixStrassen.html">MatrixStrassen</a>&lt; int32_t &gt; &amp;input)</td></tr>
<tr class="separator:aa5c05572022280760b58ee47de218743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12df49c3ca30f4debbb3c9435019d37e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlbcrypto_1_1MatrixStrassen.html">MatrixStrassen</a>&lt; int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#a12df49c3ca30f4debbb3c9435019d37e">ConvertToInt32</a> (const <a class="el" href="classlbcrypto_1_1MatrixStrassen.html">MatrixStrassen</a>&lt; <a class="el" href="classbigintfxd_1_1BigIntegerFixedT.html">BigInteger</a> &gt; &amp;input, const <a class="el" href="classbigintfxd_1_1BigIntegerFixedT.html">BigInteger</a> &amp;modulus)</td></tr>
<tr class="separator:a12df49c3ca30f4debbb3c9435019d37e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab8e0d271477b1b8afbb5925a16c924a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlbcrypto_1_1MatrixStrassen.html">MatrixStrassen</a>&lt; int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#aab8e0d271477b1b8afbb5925a16c924a">ConvertToInt32</a> (const <a class="el" href="classlbcrypto_1_1MatrixStrassen.html">MatrixStrassen</a>&lt; <a class="el" href="classbigintfxd_1_1BigVectorFixedT.html">BigVector</a> &gt; &amp;input, const <a class="el" href="classbigintfxd_1_1BigIntegerFixedT.html">BigInteger</a> &amp;modulus)</td></tr>
<tr class="separator:aab8e0d271477b1b8afbb5925a16c924a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ebcb03af86d2d7215ad80e6ed640ee0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlbcrypto_1_1MatrixStrassen.html">MatrixStrassen</a>&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">Poly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#a8ebcb03af86d2d7215ad80e6ed640ee0">SplitInt32IntoPolyElements</a> (<a class="el" href="classlbcrypto_1_1MatrixStrassen.html">MatrixStrassen</a>&lt; int32_t &gt; const &amp;other, size_t n, const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILParamsImpl.html">ILParams</a> &gt; params)</td></tr>
<tr class="separator:a8ebcb03af86d2d7215ad80e6ed640ee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3996e2baa9197ffc4c2fae1bf7b213b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlbcrypto_1_1MatrixStrassen.html">MatrixStrassen</a>&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">Poly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#a3996e2baa9197ffc4c2fae1bf7b213b5">SplitInt32AltIntoPolyElements</a> (<a class="el" href="classlbcrypto_1_1MatrixStrassen.html">MatrixStrassen</a>&lt; int32_t &gt; const &amp;other, size_t n, const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILParamsImpl.html">ILParams</a> &gt; params)</td></tr>
<tr class="separator:a3996e2baa9197ffc4c2fae1bf7b213b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab64c6376dae07b23fddf8f29fde17365"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:ab64c6376dae07b23fddf8f29fde17365"><td class="memTemplItemLeft" align="right" valign="top">IntType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#ab64c6376dae07b23fddf8f29fde17365">RootOfUnity</a> (usint m, const IntType &amp;modulo)</td></tr>
<tr class="separator:ab64c6376dae07b23fddf8f29fde17365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a777538aff71cf6138d28e37ebb17a30c"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:a777538aff71cf6138d28e37ebb17a30c"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; IntType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#a777538aff71cf6138d28e37ebb17a30c">RootsOfUnity</a> (usint m, const std::vector&lt; IntType &gt; moduli)</td></tr>
<tr class="separator:a777538aff71cf6138d28e37ebb17a30c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d588dd2ae21929d6c2863246527aca"><td class="memItemLeft" align="right" valign="top"><a id="ae9d588dd2ae21929d6c2863246527aca"></a>
usint&#160;</td><td class="memItemRight" valign="bottom"><b>ReverseBits</b> (usint num, usint msb)</td></tr>
<tr class="separator:ae9d588dd2ae21929d6c2863246527aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65460cc02825edec745044e913db8748"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:a65460cc02825edec745044e913db8748"><td class="memTemplItemLeft" align="right" valign="top">usint&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#a65460cc02825edec745044e913db8748">GetMSB</a> (IntType x)</td></tr>
<tr class="separator:a65460cc02825edec745044e913db8748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187363a8cd7513171e3a9898d5f4043c"><td class="memItemLeft" align="right" valign="top"><a id="a187363a8cd7513171e3a9898d5f4043c"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a187363a8cd7513171e3a9898d5f4043c"><td class="memTemplItemLeft" align="right" valign="top">usint&#160;</td><td class="memTemplItemRight" valign="bottom"><b>GetMSB</b> (uint64_t x)</td></tr>
<tr class="separator:a187363a8cd7513171e3a9898d5f4043c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ccac4a2b8440bbdf3f70f4532f617ef"><td class="memItemLeft" align="right" valign="top"><a id="a4ccac4a2b8440bbdf3f70f4532f617ef"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a4ccac4a2b8440bbdf3f70f4532f617ef"><td class="memTemplItemLeft" align="right" valign="top">usint&#160;</td><td class="memTemplItemRight" valign="bottom"><b>GetMSB</b> (uint32_t x)</td></tr>
<tr class="separator:a4ccac4a2b8440bbdf3f70f4532f617ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fad595ce4aced71752ae2d7e611589c"><td class="memItemLeft" align="right" valign="top"><a id="a7fad595ce4aced71752ae2d7e611589c"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a7fad595ce4aced71752ae2d7e611589c"><td class="memTemplItemLeft" align="right" valign="top">usint&#160;</td><td class="memTemplItemRight" valign="bottom"><b>GetMSB</b> (unsigned __int128 x)</td></tr>
<tr class="separator:a7fad595ce4aced71752ae2d7e611589c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab722558e2a62942f1e07cd2fc5760e32"><td class="memItemLeft" align="right" valign="top">usint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#ab722558e2a62942f1e07cd2fc5760e32">GetMSB64</a> (uint64_t x)</td></tr>
<tr class="separator:ab722558e2a62942f1e07cd2fc5760e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a495331f3e0e44283fa385b171f606bf1"><td class="memTemplParams" colspan="2"><a id="a495331f3e0e44283fa385b171f606bf1"></a>
template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:a495331f3e0e44283fa385b171f606bf1"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; std::vector&lt; int64_t &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>GetDigits</b> (const IntType &amp;u, uint64_t base, uint32_t k)</td></tr>
<tr class="separator:a495331f3e0e44283fa385b171f606bf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eab6b373735c9eae711ed409c546956"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:a8eab6b373735c9eae711ed409c546956"><td class="memTemplItemLeft" align="right" valign="top">IntType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#a8eab6b373735c9eae711ed409c546956">GreatestCommonDivisor</a> (const IntType &amp;a, const IntType &amp;b)</td></tr>
<tr class="separator:a8eab6b373735c9eae711ed409c546956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a29bc692e0f39ec87283fd676b53397"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:a7a29bc692e0f39ec87283fd676b53397"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#a7a29bc692e0f39ec87283fd676b53397">MillerRabinPrimalityTest</a> (const IntType &amp;p, const usint niter=100)</td></tr>
<tr class="separator:a7a29bc692e0f39ec87283fd676b53397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae09fc7340ed7f12f9e04f174f90956cf"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:ae09fc7340ed7f12f9e04f174f90956cf"><td class="memTemplItemLeft" align="right" valign="top">const IntType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#ae09fc7340ed7f12f9e04f174f90956cf">PollardRhoFactorization</a> (const IntType &amp;n)</td></tr>
<tr class="separator:ae09fc7340ed7f12f9e04f174f90956cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe449444ce6c301fe21750fa9c2e43db"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:afe449444ce6c301fe21750fa9c2e43db"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#afe449444ce6c301fe21750fa9c2e43db">PrimeFactorize</a> (IntType n, std::set&lt; IntType &gt; &amp;primeFactors)</td></tr>
<tr class="separator:afe449444ce6c301fe21750fa9c2e43db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed8c06a58fb79474c64e25e30ecd6c2a"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:aed8c06a58fb79474c64e25e30ecd6c2a"><td class="memTemplItemLeft" align="right" valign="top">IntType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#aed8c06a58fb79474c64e25e30ecd6c2a">FirstPrime</a> (uint64_t nBits, uint64_t m)</td></tr>
<tr class="separator:aed8c06a58fb79474c64e25e30ecd6c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ebe688fe684e49623f99078f9d8dbc7"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:a3ebe688fe684e49623f99078f9d8dbc7"><td class="memTemplItemLeft" align="right" valign="top">IntType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#a3ebe688fe684e49623f99078f9d8dbc7">NextPrime</a> (const IntType &amp;q, uint64_t cyclotomicOrder)</td></tr>
<tr class="separator:a3ebe688fe684e49623f99078f9d8dbc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab484504ba741642a2379cc0348f500ea"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:ab484504ba741642a2379cc0348f500ea"><td class="memTemplItemLeft" align="right" valign="top">IntType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#ab484504ba741642a2379cc0348f500ea">PreviousPrime</a> (const IntType &amp;q, uint64_t cyclotomicOrder)</td></tr>
<tr class="separator:ab484504ba741642a2379cc0348f500ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c831c872d1e3f48df8b72379469c8b"><td class="memItemLeft" align="right" valign="top">usint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#ad0c831c872d1e3f48df8b72379469c8b">ModInverse</a> (usint a, usint b)</td></tr>
<tr class="separator:ad0c831c872d1e3f48df8b72379469c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a934e1e8a38d866db774303cb181c6fc6"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:a934e1e8a38d866db774303cb181c6fc6"><td class="memTemplItemLeft" align="right" valign="top">IntType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#a934e1e8a38d866db774303cb181c6fc6">NextPowerOfTwo</a> (const IntType &amp;n)</td></tr>
<tr class="separator:a934e1e8a38d866db774303cb181c6fc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51f165790e4eb0b529f7d6b6f0213101"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#a51f165790e4eb0b529f7d6b6f0213101">GetTotient</a> (const uint64_t n)</td></tr>
<tr class="separator:a51f165790e4eb0b529f7d6b6f0213101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61b61fb7a46031802ad47644177e35d4"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:a61b61fb7a46031802ad47644177e35d4"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; IntType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#a61b61fb7a46031802ad47644177e35d4">GetTotientList</a> (const IntType &amp;n)</td></tr>
<tr class="separator:a61b61fb7a46031802ad47644177e35d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada1accc37bf21f3fa9b9531c6c61ca48"><td class="memTemplParams" colspan="2">template&lt;typename IntVector &gt; </td></tr>
<tr class="memitem:ada1accc37bf21f3fa9b9531c6c61ca48"><td class="memTemplItemLeft" align="right" valign="top">IntVector&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#ada1accc37bf21f3fa9b9531c6c61ca48">PolyMod</a> (const IntVector &amp;dividend, const IntVector &amp;divisor, const typename IntVector::Integer &amp;modulus)</td></tr>
<tr class="separator:ada1accc37bf21f3fa9b9531c6c61ca48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cb585cae211189317ecd51a4dab836e"><td class="memTemplParams" colspan="2">template&lt;typename IntVector &gt; </td></tr>
<tr class="memitem:a7cb585cae211189317ecd51a4dab836e"><td class="memTemplItemLeft" align="right" valign="top">IntVector&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#a7cb585cae211189317ecd51a4dab836e">PolynomialMultiplication</a> (const IntVector &amp;a, const IntVector &amp;b)</td></tr>
<tr class="separator:a7cb585cae211189317ecd51a4dab836e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac039ac1cfc6273e816ffcef787ad3d1d"><td class="memTemplParams" colspan="2">template&lt;typename IntVector &gt; </td></tr>
<tr class="memitem:ac039ac1cfc6273e816ffcef787ad3d1d"><td class="memTemplItemLeft" align="right" valign="top">IntVector&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#ac039ac1cfc6273e816ffcef787ad3d1d">GetCyclotomicPolynomial</a> (usint m, const typename IntVector::Integer &amp;modulus)</td></tr>
<tr class="separator:ac039ac1cfc6273e816ffcef787ad3d1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a060f4282b6f71dc9f51842ff9e972080"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#a060f4282b6f71dc9f51842ff9e972080">GetCyclotomicPolynomialRecursive</a> (usint m)</td></tr>
<tr class="separator:a060f4282b6f71dc9f51842ff9e972080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a233fa7b7c76cb6cde781319cc053ae84"><td class="memTemplParams" colspan="2">template&lt;typename IntVector &gt; </td></tr>
<tr class="memitem:a233fa7b7c76cb6cde781319cc053ae84"><td class="memTemplItemLeft" align="right" valign="top">IntVector::Integer&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#a233fa7b7c76cb6cde781319cc053ae84">SyntheticRemainder</a> (const IntVector &amp;dividend, const typename IntVector::Integer &amp;a, const typename IntVector::Integer &amp;modulus)</td></tr>
<tr class="separator:a233fa7b7c76cb6cde781319cc053ae84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27e1453f38eaf4a41a46c8ed71e4eb52"><td class="memTemplParams" colspan="2">template&lt;typename IntVector &gt; </td></tr>
<tr class="memitem:a27e1453f38eaf4a41a46c8ed71e4eb52"><td class="memTemplItemLeft" align="right" valign="top">IntVector&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#a27e1453f38eaf4a41a46c8ed71e4eb52">SyntheticPolyRemainder</a> (const IntVector &amp;dividend, const IntVector &amp;aList, const typename IntVector::Integer &amp;modulus)</td></tr>
<tr class="separator:a27e1453f38eaf4a41a46c8ed71e4eb52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99054b40e099eba7500c35fca4a0946f"><td class="memTemplParams" colspan="2">template&lt;typename IntVector &gt; </td></tr>
<tr class="memitem:a99054b40e099eba7500c35fca4a0946f"><td class="memTemplItemLeft" align="right" valign="top">IntVector&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#a99054b40e099eba7500c35fca4a0946f">PolynomialPower</a> (const IntVector &amp;input, usint power)</td></tr>
<tr class="separator:a99054b40e099eba7500c35fca4a0946f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6778a7fcb4acdbb7e0edeec91a5bf4ee"><td class="memTemplParams" colspan="2">template&lt;typename IntVector &gt; </td></tr>
<tr class="memitem:a6778a7fcb4acdbb7e0edeec91a5bf4ee"><td class="memTemplItemLeft" align="right" valign="top">IntVector&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#a6778a7fcb4acdbb7e0edeec91a5bf4ee">SyntheticPolynomialDivision</a> (const IntVector &amp;dividend, const typename IntVector::Integer &amp;a, const typename IntVector::Integer &amp;modulus)</td></tr>
<tr class="separator:a6778a7fcb4acdbb7e0edeec91a5bf4ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c677e43a77ecd38d87163ac57e55ecf"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:a7c677e43a77ecd38d87163ac57e55ecf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#a7c677e43a77ecd38d87163ac57e55ecf">IsGenerator</a> (const IntType &amp;g, const IntType &amp;q)</td></tr>
<tr class="separator:a7c677e43a77ecd38d87163ac57e55ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27512aa8ffb726f2cad171d8bab60936"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:a27512aa8ffb726f2cad171d8bab60936"><td class="memTemplItemLeft" align="right" valign="top">IntType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#a27512aa8ffb726f2cad171d8bab60936">FindGeneratorCyclic</a> (const IntType &amp;q)</td></tr>
<tr class="separator:a27512aa8ffb726f2cad171d8bab60936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a014dc4f4f38de1bb1422bed95774eb49"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#a014dc4f4f38de1bb1422bed95774eb49">FindAutomorphismIndex2n</a> (int32_t i, uint32_t m)</td></tr>
<tr class="separator:a014dc4f4f38de1bb1422bed95774eb49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc6dec4c3cfb7cd9ca4830c1d043ed4a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#adc6dec4c3cfb7cd9ca4830c1d043ed4a">FindAutomorphismIndex2nComplex</a> (int32_t i, uint32_t m)</td></tr>
<tr class="separator:adc6dec4c3cfb7cd9ca4830c1d043ed4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80c70f2e9171c0fd1b0f919c8e06fe06"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#a80c70f2e9171c0fd1b0f919c8e06fe06">FindAutomorphismIndexCyclic</a> (int32_t i, uint32_t m, uint32_t g)</td></tr>
<tr class="separator:a80c70f2e9171c0fd1b0f919c8e06fe06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d19d9c8fb254adb4b914f7cdc5b86c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#a5d19d9c8fb254adb4b914f7cdc5b86c3">PrecomputeAutoMap</a> (uint32_t n, uint32_t k, std::vector&lt; uint32_t &gt; *precomp)</td></tr>
<tr class="separator:a5d19d9c8fb254adb4b914f7cdc5b86c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac64841b15a4d2a7ad009d8704685649d"><td class="memItemLeft" align="right" valign="top"><a id="ac64841b15a4d2a7ad009d8704685649d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>_VARIADIC_EXPAND_0X</b> (_MAKE_UNIQUE,,,,) template&lt; typename T</td></tr>
<tr class="separator:ac64841b15a4d2a7ad009d8704685649d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b486be1aa61143ab4376027856225e4"><td class="memItemLeft" align="right" valign="top"><a id="a2b486be1aa61143ab4376027856225e4"></a>
typename Args std::unique_ptr&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>make_unique</b> (Args &amp;&amp;... args)</td></tr>
<tr class="separator:a2b486be1aa61143ab4376027856225e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9256c0ae59398b39464b40432f27741"><td class="memTemplParams" colspan="2"><a id="ac9256c0ae59398b39464b40432f27741"></a>
template&lt;class X &gt; </td></tr>
<tr class="memitem:ac9256c0ae59398b39464b40432f27741"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MoveAppend</b> (std::vector&lt; X &gt; &amp;dst, std::vector&lt; X &gt; &amp;src)</td></tr>
<tr class="separator:ac9256c0ae59398b39464b40432f27741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b534e663a822da7c3e972b7b9837674"><td class="memItemLeft" align="right" valign="top"><a id="a4b534e663a822da7c3e972b7b9837674"></a>
unsigned char&#160;</td><td class="memItemRight" valign="bottom"><b>value_to_base64</b> (int c)</td></tr>
<tr class="separator:a4b534e663a822da7c3e972b7b9837674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8550f44227b8c49e28d3e7d17307f07"><td class="memItemLeft" align="right" valign="top"><a id="af8550f44227b8c49e28d3e7d17307f07"></a>
unsigned char&#160;</td><td class="memItemRight" valign="bottom"><b>base64_to_value</b> (unsigned char b64)</td></tr>
<tr class="separator:af8550f44227b8c49e28d3e7d17307f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f8cf50c1572fb206cd65471816d5c76"><td class="memItemLeft" align="right" valign="top"><a id="a8f8cf50c1572fb206cd65471816d5c76"></a>
unsigned char&#160;</td><td class="memItemRight" valign="bottom"><b>get_6bits_atoffset</b> (uint64_t m_value, uint32_t index)</td></tr>
<tr class="separator:a8f8cf50c1572fb206cd65471816d5c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d0c1073c5289ee5af8e011d97374699"><td class="memTemplParams" colspan="2"><a id="a1d0c1073c5289ee5af8e011d97374699"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1d0c1073c5289ee5af8e011d97374699"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const std::vector&lt; T &gt; &amp;v)</td></tr>
<tr class="separator:a1d0c1073c5289ee5af8e011d97374699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18ae7a620f63f3d3d789f4dcff70b83a"><td class="memItemLeft" align="right" valign="top">DoubleNativeInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#a18ae7a620f63f3d3d789f4dcff70b83a">Mul128</a> (uint64_t a, uint64_t b)</td></tr>
<tr class="separator:a18ae7a620f63f3d3d789f4dcff70b83a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a773e51f8d3e00a51401a2f782c82c3dd"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#a773e51f8d3e00a51401a2f782c82c3dd">BarrettUint128ModUint64</a> (const DoubleNativeInt &amp;a, uint64_t modulus, const DoubleNativeInt &amp;mu)</td></tr>
<tr class="separator:a773e51f8d3e00a51401a2f782c82c3dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24cf55013f5ce730296e1ecfc281bb99"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:a24cf55013f5ce730296e1ecfc281bb99"><td class="memTemplItemLeft" align="right" valign="top">V&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#a24cf55013f5ce730296e1ecfc281bb99">ZeroPadForward</a> (const V &amp;InputPoly, usint target_order)</td></tr>
<tr class="separator:a24cf55013f5ce730296e1ecfc281bb99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10e13f1a38d295d34102d4ca8235826f"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:a10e13f1a38d295d34102d4ca8235826f"><td class="memTemplItemLeft" align="right" valign="top">V&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#a10e13f1a38d295d34102d4ca8235826f">ZeroPadInverse</a> (const V &amp;InputPoly, usint target_order)</td></tr>
<tr class="separator:a10e13f1a38d295d34102d4ca8235826f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c0bee71d2fdd0aeb2b4e300a6da8650"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#a3c0bee71d2fdd0aeb2b4e300a6da8650">IsPowerOfTwo</a> (usint Input)</td></tr>
<tr class="separator:a3c0bee71d2fdd0aeb2b4e300a6da8650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4485da7b198be976967e347486bee467"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#a4485da7b198be976967e347486bee467">replaceChar</a> (std::string str, char in, char out)</td></tr>
<tr class="separator:a4485da7b198be976967e347486bee467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35137dac20ea2cebd63cba9cff60acbc"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#a35137dac20ea2cebd63cba9cff60acbc">IsAdditionOverflow</a> (uint64_t a, uint64_t b)</td></tr>
<tr class="separator:a35137dac20ea2cebd63cba9cff60acbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb34883759c9d975df1450f89b72be7d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#aeb34883759c9d975df1450f89b72be7d">AdditionWithCarryOut</a> (uint64_t a, uint64_t b, uint64_t &amp;c)</td></tr>
<tr class="separator:aeb34883759c9d975df1450f89b72be7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c3ccbd1174931ca8915581ef872f51"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt; std::is_integral&lt; T &gt;::value &amp;&amp;!std::is_same&lt; T, bool &gt;::value, bool &gt;::type  = true&gt; </td></tr>
<tr class="memitem:ae5c3ccbd1174931ca8915581ef872f51"><td class="memTemplItemLeft" align="right" valign="top">constexpr usint&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#ae5c3ccbd1174931ca8915581ef872f51">GetIntegerTypeBitLength</a> ()</td></tr>
<tr class="separator:ae5c3ccbd1174931ca8915581ef872f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f094cd406616fb3aed5170e4025d490"><td class="memItemLeft" align="right" valign="top"><a id="a8f094cd406616fb3aed5170e4025d490"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPLIT64_FOR_TYPE</b> (<a class="el" href="classlbcrypto_1_1PolyImpl.html">M2Poly</a>) SPLIT64ALT_FOR_TYPE(<a class="el" href="classlbcrypto_1_1PolyImpl.html">M2Poly</a>) SPLIT32ALT_FOR_TYPE(<a class="el" href="classlbcrypto_1_1PolyImpl.html">M2Poly</a>) template <a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="classbigintfxd_1_1BigVectorFixedT.html">M2Vector</a> &gt; <a class="el" href="namespacelbcrypto.html#aaa6bc09bac6f4dcdf95ffe767d51a1f2">RotateVecResult</a>(<a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">M2Poly</a> &gt; const &amp;inMat)</td></tr>
<tr class="separator:a8f094cd406616fb3aed5170e4025d490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea6ebd44415c1b3f3b1e3aa2eb1353f3"><td class="memItemLeft" align="right" valign="top"><a id="aea6ebd44415c1b3f3b1e3aa2eb1353f3"></a>
template <a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="classbigintfxd_1_1BigIntegerFixedT.html">M2Integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Rotate</b> (<a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">M2Poly</a> &gt; const &amp;inMat)</td></tr>
<tr class="separator:aea6ebd44415c1b3f3b1e3aa2eb1353f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac30931fd4e595572f2149ba593e61cca"><td class="memItemLeft" align="right" valign="top"><a id="ac30931fd4e595572f2149ba593e61cca"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPLIT64_FOR_TYPE</b> (<a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">M2DCRTPoly</a>) SPLIT64ALT_FOR_TYPE(<a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">M2DCRTPoly</a>) SPLIT32ALT_FOR_TYPE(<a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">M2DCRTPoly</a>) template <a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="classbigintfxd_1_1BigVectorFixedT.html">M2Vector</a> &gt; <a class="el" href="namespacelbcrypto.html#aaa6bc09bac6f4dcdf95ffe767d51a1f2">RotateVecResult</a>(<a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">M2DCRTPoly</a> &gt; const &amp;inMat)</td></tr>
<tr class="separator:ac30931fd4e595572f2149ba593e61cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1c5629b7c89e58fb90f7c520583846d"><td class="memItemLeft" align="right" valign="top"><a id="ae1c5629b7c89e58fb90f7c520583846d"></a>
template <a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="classbigintfxd_1_1BigIntegerFixedT.html">M2Integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Rotate</b> (<a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">M2DCRTPoly</a> &gt; const &amp;inMat)</td></tr>
<tr class="separator:ae1c5629b7c89e58fb90f7c520583846d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82bb7e47ad18e37f32e0dfdf78c7df45"><td class="memItemLeft" align="right" valign="top"><a id="a82bb7e47ad18e37f32e0dfdf78c7df45"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPLIT64_FOR_TYPE</b> (<a class="el" href="classlbcrypto_1_1PolyImpl.html">M4Poly</a>) SPLIT64ALT_FOR_TYPE(<a class="el" href="classlbcrypto_1_1PolyImpl.html">M4Poly</a>) SPLIT32ALT_FOR_TYPE(<a class="el" href="classlbcrypto_1_1PolyImpl.html">M4Poly</a>) template <a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="classbigintdyn_1_1mubintvec.html">M4Vector</a> &gt; <a class="el" href="namespacelbcrypto.html#aaa6bc09bac6f4dcdf95ffe767d51a1f2">RotateVecResult</a>(<a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">M4Poly</a> &gt; const &amp;inMat)</td></tr>
<tr class="separator:a82bb7e47ad18e37f32e0dfdf78c7df45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad07ec91eae9152cf79b6c111826320d7"><td class="memItemLeft" align="right" valign="top"><a id="ad07ec91eae9152cf79b6c111826320d7"></a>
template <a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="classbigintdyn_1_1ubint.html">M4Integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Rotate</b> (<a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">M4Poly</a> &gt; const &amp;inMat)</td></tr>
<tr class="separator:ad07ec91eae9152cf79b6c111826320d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae39d0608aeb00071ba758c9290ca2781"><td class="memItemLeft" align="right" valign="top"><a id="ae39d0608aeb00071ba758c9290ca2781"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPLIT64_FOR_TYPE</b> (<a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">M4DCRTPoly</a>) SPLIT64ALT_FOR_TYPE(<a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">M4DCRTPoly</a>) SPLIT32ALT_FOR_TYPE(<a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">M4DCRTPoly</a>) template <a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="classbigintdyn_1_1mubintvec.html">M4Vector</a> &gt; <a class="el" href="namespacelbcrypto.html#aaa6bc09bac6f4dcdf95ffe767d51a1f2">RotateVecResult</a>(<a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">M4DCRTPoly</a> &gt; const &amp;inMat)</td></tr>
<tr class="separator:ae39d0608aeb00071ba758c9290ca2781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22c724aafd5c55544c778b2357675086"><td class="memItemLeft" align="right" valign="top"><a id="a22c724aafd5c55544c778b2357675086"></a>
template <a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="classbigintdyn_1_1ubint.html">M4Integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Rotate</b> (<a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">M4DCRTPoly</a> &gt; const &amp;inMat)</td></tr>
<tr class="separator:a22c724aafd5c55544c778b2357675086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af97cd580d542c274baa36fab8b994d6e"><td class="memItemLeft" align="right" valign="top"><a id="af97cd580d542c274baa36fab8b994d6e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPLIT64_FOR_TYPE</b> (<a class="el" href="classlbcrypto_1_1PolyImpl.html">M6Poly</a>) SPLIT64ALT_FOR_TYPE(<a class="el" href="classlbcrypto_1_1PolyImpl.html">M6Poly</a>) SPLIT32ALT_FOR_TYPE(<a class="el" href="classlbcrypto_1_1PolyImpl.html">M6Poly</a>) template <a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="classNTL_1_1myVecP.html">M6Vector</a> &gt; <a class="el" href="namespacelbcrypto.html#aaa6bc09bac6f4dcdf95ffe767d51a1f2">RotateVecResult</a>(<a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">M6Poly</a> &gt; const &amp;inMat)</td></tr>
<tr class="separator:af97cd580d542c274baa36fab8b994d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d6185b2ebe425597f4eddf88431abd"><td class="memItemLeft" align="right" valign="top"><a id="a14d6185b2ebe425597f4eddf88431abd"></a>
template <a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="classNTL_1_1myZZ.html">M6Integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Rotate</b> (<a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">M6Poly</a> &gt; const &amp;inMat)</td></tr>
<tr class="separator:a14d6185b2ebe425597f4eddf88431abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8baa31ef96adca59c11b8c6c36a01ac5"><td class="memItemLeft" align="right" valign="top"><a id="a8baa31ef96adca59c11b8c6c36a01ac5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPLIT64_FOR_TYPE</b> (<a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">M6DCRTPoly</a>) SPLIT64ALT_FOR_TYPE(<a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">M6DCRTPoly</a>) SPLIT32ALT_FOR_TYPE(<a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">M6DCRTPoly</a>) template <a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="classNTL_1_1myVecP.html">M6Vector</a> &gt; <a class="el" href="namespacelbcrypto.html#aaa6bc09bac6f4dcdf95ffe767d51a1f2">RotateVecResult</a>(<a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">M6DCRTPoly</a> &gt; const &amp;inMat)</td></tr>
<tr class="separator:a8baa31ef96adca59c11b8c6c36a01ac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a90a721585da33dac406d6b214b5b9"><td class="memItemLeft" align="right" valign="top"><a id="a85a90a721585da33dac406d6b214b5b9"></a>
template <a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="classNTL_1_1myZZ.html">M6Integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Rotate</b> (<a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">M6DCRTPoly</a> &gt; const &amp;inMat)</td></tr>
<tr class="separator:a85a90a721585da33dac406d6b214b5b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3530a671bd73dbffc39a578f794861a7"><td class="memItemLeft" align="right" valign="top"><a id="a3530a671bd73dbffc39a578f794861a7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPLIT64_FOR_TYPE</b> (<a class="el" href="classlbcrypto_1_1PolyImpl.html">NativePoly</a>) SPLIT64ALT_FOR_TYPE(<a class="el" href="classlbcrypto_1_1PolyImpl.html">NativePoly</a>) SPLIT32ALT_FOR_TYPE(<a class="el" href="classlbcrypto_1_1PolyImpl.html">NativePoly</a>) template <a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="classintnat_1_1NativeVectorT.html">NativeVector</a> &gt; <a class="el" href="namespacelbcrypto.html#aaa6bc09bac6f4dcdf95ffe767d51a1f2">RotateVecResult</a>(<a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">NativePoly</a> &gt; const &amp;inMat)</td></tr>
<tr class="separator:a3530a671bd73dbffc39a578f794861a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3dc6693ef25ec532d3f030d44d152bd"><td class="memItemLeft" align="right" valign="top"><a id="aa3dc6693ef25ec532d3f030d44d152bd"></a>
template <a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="classintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Rotate</b> (<a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">NativePoly</a> &gt; const &amp;inMat)</td></tr>
<tr class="separator:aa3dc6693ef25ec532d3f030d44d152bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dcf2181b48b69d9647b43014cdbe925"><td class="memTemplParams" colspan="2"><a id="a5dcf2181b48b69d9647b43014cdbe925"></a>
template&lt;typename VecType &gt; </td></tr>
<tr class="memitem:a5dcf2181b48b69d9647b43014cdbe925"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt; &amp;p)</td></tr>
<tr class="separator:a5dcf2181b48b69d9647b43014cdbe925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae6a3119088869115ebf06bdf634f0c6"><td class="memTemplParams" colspan="2"><a id="aae6a3119088869115ebf06bdf634f0c6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aae6a3119088869115ebf06bdf634f0c6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; int32_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ConvertToInt32</b> (const <a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; T &gt; &amp;input, const T &amp;modulus)</td></tr>
<tr class="separator:aae6a3119088869115ebf06bdf634f0c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9b2b9dbb0a770a7b6fe41ca146b298c"><td class="memTemplParams" colspan="2"><a id="ad9b2b9dbb0a770a7b6fe41ca146b298c"></a>
template&lt;typename V &gt; </td></tr>
<tr class="memitem:ad9b2b9dbb0a770a7b6fe41ca146b298c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; int32_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ConvertToInt32</b> (const <a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; V &gt; &amp;input, const typename V::Integer &amp;modulus)</td></tr>
<tr class="separator:ad9b2b9dbb0a770a7b6fe41ca146b298c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a118eb4a5f0d548d8c5e68958bf3a7db5"><td class="memTemplParams" colspan="2">template&lt;typename VecType &gt; </td></tr>
<tr class="memitem:a118eb4a5f0d548d8c5e68958bf3a7db5"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#a118eb4a5f0d548d8c5e68958bf3a7db5">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyImpl</a>&lt; VecType &gt; &amp;p)</td></tr>
<tr class="separator:a118eb4a5f0d548d8c5e68958bf3a7db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a162399cf989751e3098b6a5d6e90319f"><td class="memItemLeft" align="right" valign="top"><a id="a162399cf989751e3098b6a5d6e90319f"></a>
template <a class="el" href="classbigintdyn_1_1ubint.html">M4Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>RootOfUnity&lt; M4Integer &gt;</b> (usint m, const <a class="el" href="classbigintdyn_1_1ubint.html">M4Integer</a> &amp;modulo)</td></tr>
<tr class="separator:a162399cf989751e3098b6a5d6e90319f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afebdaf62a078c94461a0ef159c83c692"><td class="memItemLeft" align="right" valign="top"><a id="afebdaf62a078c94461a0ef159c83c692"></a>
template std::vector&lt; <a class="el" href="classbigintdyn_1_1ubint.html">M4Integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>RootsOfUnity</b> (usint m, const std::vector&lt; <a class="el" href="classbigintdyn_1_1ubint.html">M4Integer</a> &gt; moduli)</td></tr>
<tr class="separator:afebdaf62a078c94461a0ef159c83c692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d6dfb2dca5c6b6c06ec6c06e4e1059"><td class="memItemLeft" align="right" valign="top"><a id="af2d6dfb2dca5c6b6c06ec6c06e4e1059"></a>
template <a class="el" href="classbigintdyn_1_1ubint.html">M4Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GreatestCommonDivisor</b> (const <a class="el" href="classbigintdyn_1_1ubint.html">M4Integer</a> &amp;a, const <a class="el" href="classbigintdyn_1_1ubint.html">M4Integer</a> &amp;b)</td></tr>
<tr class="separator:af2d6dfb2dca5c6b6c06ec6c06e4e1059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a8c88d793e86e048b259c06beeb908c"><td class="memItemLeft" align="right" valign="top"><a id="a3a8c88d793e86e048b259c06beeb908c"></a>
template bool&#160;</td><td class="memItemRight" valign="bottom"><b>MillerRabinPrimalityTest</b> (const <a class="el" href="classbigintdyn_1_1ubint.html">M4Integer</a> &amp;p, const usint niter)</td></tr>
<tr class="separator:a3a8c88d793e86e048b259c06beeb908c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad14aa102a199629f008c31812bb3fe49"><td class="memItemLeft" align="right" valign="top"><a id="ad14aa102a199629f008c31812bb3fe49"></a>
const template <a class="el" href="classbigintdyn_1_1ubint.html">M4Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PollardRhoFactorization</b> (const <a class="el" href="classbigintdyn_1_1ubint.html">M4Integer</a> &amp;n)</td></tr>
<tr class="separator:ad14aa102a199629f008c31812bb3fe49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad65d817dc95d54f9ffc78cddb9d2fe30"><td class="memItemLeft" align="right" valign="top"><a id="ad65d817dc95d54f9ffc78cddb9d2fe30"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>PrimeFactorize</b> (<a class="el" href="classbigintdyn_1_1ubint.html">M4Integer</a> n, std::set&lt; <a class="el" href="classbigintdyn_1_1ubint.html">M4Integer</a> &gt; &amp;primeFactors)</td></tr>
<tr class="separator:ad65d817dc95d54f9ffc78cddb9d2fe30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec74875354454447bac67db315714399"><td class="memItemLeft" align="right" valign="top"><a id="aec74875354454447bac67db315714399"></a>
template <a class="el" href="classbigintdyn_1_1ubint.html">M4Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>NextPrime</b> (const <a class="el" href="classbigintdyn_1_1ubint.html">M4Integer</a> &amp;q, uint64_t cyclotomicOrder)</td></tr>
<tr class="separator:aec74875354454447bac67db315714399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa86c844db52248fe8ec55a07b37e2bc0"><td class="memItemLeft" align="right" valign="top"><a id="aa86c844db52248fe8ec55a07b37e2bc0"></a>
template <a class="el" href="classbigintdyn_1_1ubint.html">M4Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PreviousPrime</b> (const <a class="el" href="classbigintdyn_1_1ubint.html">M4Integer</a> &amp;q, uint64_t cyclotomicOrder)</td></tr>
<tr class="separator:aa86c844db52248fe8ec55a07b37e2bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6785d5dc837c6127bc1f8e6adf4a544"><td class="memItemLeft" align="right" valign="top"><a id="af6785d5dc837c6127bc1f8e6adf4a544"></a>
template std::vector&lt; <a class="el" href="classbigintdyn_1_1ubint.html">M4Integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GetTotientList</b> (const <a class="el" href="classbigintdyn_1_1ubint.html">M4Integer</a> &amp;n)</td></tr>
<tr class="separator:af6785d5dc837c6127bc1f8e6adf4a544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a726806553ba1e41813d44855d0d60e57"><td class="memItemLeft" align="right" valign="top"><a id="a726806553ba1e41813d44855d0d60e57"></a>
template <a class="el" href="classbigintdyn_1_1mubintvec.html">M4Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PolyMod</b> (const <a class="el" href="classbigintdyn_1_1mubintvec.html">M4Vector</a> &amp;dividend, const <a class="el" href="classbigintdyn_1_1mubintvec.html">M4Vector</a> &amp;divisor, const <a class="el" href="classbigintdyn_1_1ubint.html">M4Integer</a> &amp;modulus)</td></tr>
<tr class="separator:a726806553ba1e41813d44855d0d60e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a097bd1aeb89667ee873f3f0b7fdb24df"><td class="memItemLeft" align="right" valign="top"><a id="a097bd1aeb89667ee873f3f0b7fdb24df"></a>
template <a class="el" href="classbigintdyn_1_1mubintvec.html">M4Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PolynomialMultiplication</b> (const <a class="el" href="classbigintdyn_1_1mubintvec.html">M4Vector</a> &amp;a, const <a class="el" href="classbigintdyn_1_1mubintvec.html">M4Vector</a> &amp;b)</td></tr>
<tr class="separator:a097bd1aeb89667ee873f3f0b7fdb24df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add511dfed53131e0c84ac513ecc29d81"><td class="memItemLeft" align="right" valign="top"><a id="add511dfed53131e0c84ac513ecc29d81"></a>
template <a class="el" href="classbigintdyn_1_1mubintvec.html">M4Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetCyclotomicPolynomial</b> (usint m, const <a class="el" href="classbigintdyn_1_1ubint.html">M4Integer</a> &amp;modulus)</td></tr>
<tr class="separator:add511dfed53131e0c84ac513ecc29d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a233af5c807363d7bb764cf14cd2f0069"><td class="memItemLeft" align="right" valign="top"><a id="a233af5c807363d7bb764cf14cd2f0069"></a>
template <a class="el" href="classbigintdyn_1_1ubint.html">M4Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>SyntheticRemainder</b> (const <a class="el" href="classbigintdyn_1_1mubintvec.html">M4Vector</a> &amp;dividend, const <a class="el" href="classbigintdyn_1_1ubint.html">M4Integer</a> &amp;a, const <a class="el" href="classbigintdyn_1_1ubint.html">M4Integer</a> &amp;modulus)</td></tr>
<tr class="separator:a233af5c807363d7bb764cf14cd2f0069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01d3bdbff6f160b3b9bd2d73b4b1d0e"><td class="memItemLeft" align="right" valign="top"><a id="af01d3bdbff6f160b3b9bd2d73b4b1d0e"></a>
template <a class="el" href="classbigintdyn_1_1mubintvec.html">M4Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>SyntheticPolyRemainder</b> (const <a class="el" href="classbigintdyn_1_1mubintvec.html">M4Vector</a> &amp;dividend, const <a class="el" href="classbigintdyn_1_1mubintvec.html">M4Vector</a> &amp;aList, const <a class="el" href="classbigintdyn_1_1ubint.html">M4Integer</a> &amp;modulus)</td></tr>
<tr class="separator:af01d3bdbff6f160b3b9bd2d73b4b1d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0257ac90df555bf4642186b548445565"><td class="memItemLeft" align="right" valign="top"><a id="a0257ac90df555bf4642186b548445565"></a>
template <a class="el" href="classbigintdyn_1_1mubintvec.html">M4Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PolynomialPower&lt; M4Vector &gt;</b> (const <a class="el" href="classbigintdyn_1_1mubintvec.html">M4Vector</a> &amp;input, usint power)</td></tr>
<tr class="separator:a0257ac90df555bf4642186b548445565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af42c1f7c62b59e046af1faa498e40029"><td class="memItemLeft" align="right" valign="top"><a id="af42c1f7c62b59e046af1faa498e40029"></a>
template <a class="el" href="classbigintdyn_1_1mubintvec.html">M4Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>SyntheticPolynomialDivision</b> (const <a class="el" href="classbigintdyn_1_1mubintvec.html">M4Vector</a> &amp;dividend, const <a class="el" href="classbigintdyn_1_1ubint.html">M4Integer</a> &amp;a, const <a class="el" href="classbigintdyn_1_1ubint.html">M4Integer</a> &amp;modulus)</td></tr>
<tr class="separator:af42c1f7c62b59e046af1faa498e40029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb8cdf79f97779d658bce1d8e85756d2"><td class="memItemLeft" align="right" valign="top"><a id="aeb8cdf79f97779d658bce1d8e85756d2"></a>
template <a class="el" href="classbigintdyn_1_1ubint.html">M4Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>FindGeneratorCyclic</b> (const <a class="el" href="classbigintdyn_1_1ubint.html">M4Integer</a> &amp;modulo)</td></tr>
<tr class="separator:aeb8cdf79f97779d658bce1d8e85756d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afee89904c977132d8d775d4ca7ac2447"><td class="memItemLeft" align="right" valign="top"><a id="afee89904c977132d8d775d4ca7ac2447"></a>
template bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsGenerator</b> (const <a class="el" href="classbigintdyn_1_1ubint.html">M4Integer</a> &amp;g, const <a class="el" href="classbigintdyn_1_1ubint.html">M4Integer</a> &amp;modulo)</td></tr>
<tr class="separator:afee89904c977132d8d775d4ca7ac2447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a5e848a7d42c4ec09d6c07423b0d8a"><td class="memItemLeft" align="right" valign="top"><a id="a42a5e848a7d42c4ec09d6c07423b0d8a"></a>
template std::shared_ptr&lt; std::vector&lt; int64_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GetDigits</b> (const <a class="el" href="classbigintdyn_1_1ubint.html">M4Integer</a> &amp;u, uint64_t base, uint32_t k)</td></tr>
<tr class="separator:a42a5e848a7d42c4ec09d6c07423b0d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a875faac9a919c7c6ea2190d7cf1a543f"><td class="memItemLeft" align="right" valign="top"><a id="a875faac9a919c7c6ea2190d7cf1a543f"></a>
template <a class="el" href="classbigintfxd_1_1BigIntegerFixedT.html">M2Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>RootOfUnity&lt; M2Integer &gt;</b> (usint m, const <a class="el" href="classbigintfxd_1_1BigIntegerFixedT.html">M2Integer</a> &amp;modulo)</td></tr>
<tr class="separator:a875faac9a919c7c6ea2190d7cf1a543f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dd9bb73a1f07af650f9df3bf65570b5"><td class="memItemLeft" align="right" valign="top"><a id="a2dd9bb73a1f07af650f9df3bf65570b5"></a>
template std::vector&lt; <a class="el" href="classbigintfxd_1_1BigIntegerFixedT.html">M2Integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>RootsOfUnity</b> (usint m, const std::vector&lt; <a class="el" href="classbigintfxd_1_1BigIntegerFixedT.html">M2Integer</a> &gt; moduli)</td></tr>
<tr class="separator:a2dd9bb73a1f07af650f9df3bf65570b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd66fcd7ecc909f25b13eaed38bef578"><td class="memItemLeft" align="right" valign="top"><a id="afd66fcd7ecc909f25b13eaed38bef578"></a>
template <a class="el" href="classbigintfxd_1_1BigIntegerFixedT.html">M2Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GreatestCommonDivisor</b> (const <a class="el" href="classbigintfxd_1_1BigIntegerFixedT.html">M2Integer</a> &amp;a, const <a class="el" href="classbigintfxd_1_1BigIntegerFixedT.html">M2Integer</a> &amp;b)</td></tr>
<tr class="separator:afd66fcd7ecc909f25b13eaed38bef578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad185d5d0e66e2e522a3cabd6ebc27bf9"><td class="memItemLeft" align="right" valign="top"><a id="ad185d5d0e66e2e522a3cabd6ebc27bf9"></a>
template bool&#160;</td><td class="memItemRight" valign="bottom"><b>MillerRabinPrimalityTest</b> (const <a class="el" href="classbigintfxd_1_1BigIntegerFixedT.html">M2Integer</a> &amp;p, const usint niter)</td></tr>
<tr class="separator:ad185d5d0e66e2e522a3cabd6ebc27bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a34dff1c6d2ea2002756857f30d35f"><td class="memItemLeft" align="right" valign="top"><a id="a85a34dff1c6d2ea2002756857f30d35f"></a>
const template <a class="el" href="classbigintfxd_1_1BigIntegerFixedT.html">M2Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PollardRhoFactorization</b> (const <a class="el" href="classbigintfxd_1_1BigIntegerFixedT.html">M2Integer</a> &amp;n)</td></tr>
<tr class="separator:a85a34dff1c6d2ea2002756857f30d35f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fed1fb82ddb582c2c6c57a46eab3d39"><td class="memItemLeft" align="right" valign="top"><a id="a7fed1fb82ddb582c2c6c57a46eab3d39"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>PrimeFactorize</b> (<a class="el" href="classbigintfxd_1_1BigIntegerFixedT.html">M2Integer</a> n, std::set&lt; <a class="el" href="classbigintfxd_1_1BigIntegerFixedT.html">M2Integer</a> &gt; &amp;primeFactors)</td></tr>
<tr class="separator:a7fed1fb82ddb582c2c6c57a46eab3d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22cdbe234974f0b7e4d52eb184d60fd4"><td class="memItemLeft" align="right" valign="top"><a id="a22cdbe234974f0b7e4d52eb184d60fd4"></a>
template <a class="el" href="classbigintfxd_1_1BigIntegerFixedT.html">M2Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>NextPrime</b> (const <a class="el" href="classbigintfxd_1_1BigIntegerFixedT.html">M2Integer</a> &amp;q, uint64_t cyclotomicOrder)</td></tr>
<tr class="separator:a22cdbe234974f0b7e4d52eb184d60fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e358db3a13e49369f1d8ef936b0730"><td class="memItemLeft" align="right" valign="top"><a id="ad8e358db3a13e49369f1d8ef936b0730"></a>
template <a class="el" href="classbigintfxd_1_1BigIntegerFixedT.html">M2Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PreviousPrime</b> (const <a class="el" href="classbigintfxd_1_1BigIntegerFixedT.html">M2Integer</a> &amp;q, uint64_t cyclotomicOrder)</td></tr>
<tr class="separator:ad8e358db3a13e49369f1d8ef936b0730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a316e5a88fa14b1ba4d8287bd38bbfce1"><td class="memItemLeft" align="right" valign="top"><a id="a316e5a88fa14b1ba4d8287bd38bbfce1"></a>
template std::vector&lt; <a class="el" href="classbigintfxd_1_1BigIntegerFixedT.html">M2Integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GetTotientList</b> (const <a class="el" href="classbigintfxd_1_1BigIntegerFixedT.html">M2Integer</a> &amp;n)</td></tr>
<tr class="separator:a316e5a88fa14b1ba4d8287bd38bbfce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae14a327f0ca11a6d78f8b9d4069b5c33"><td class="memItemLeft" align="right" valign="top"><a id="ae14a327f0ca11a6d78f8b9d4069b5c33"></a>
template <a class="el" href="classbigintfxd_1_1BigVectorFixedT.html">M2Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PolyMod</b> (const <a class="el" href="classbigintfxd_1_1BigVectorFixedT.html">M2Vector</a> &amp;dividend, const <a class="el" href="classbigintfxd_1_1BigVectorFixedT.html">M2Vector</a> &amp;divisor, const <a class="el" href="classbigintfxd_1_1BigIntegerFixedT.html">M2Integer</a> &amp;modulus)</td></tr>
<tr class="separator:ae14a327f0ca11a6d78f8b9d4069b5c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86f95af405b8ae0862eb3e3ab916cd11"><td class="memItemLeft" align="right" valign="top"><a id="a86f95af405b8ae0862eb3e3ab916cd11"></a>
template <a class="el" href="classbigintfxd_1_1BigVectorFixedT.html">M2Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PolynomialMultiplication</b> (const <a class="el" href="classbigintfxd_1_1BigVectorFixedT.html">M2Vector</a> &amp;a, const <a class="el" href="classbigintfxd_1_1BigVectorFixedT.html">M2Vector</a> &amp;b)</td></tr>
<tr class="separator:a86f95af405b8ae0862eb3e3ab916cd11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacdcff5fe96c5e3c4bb44f53e1b82878"><td class="memItemLeft" align="right" valign="top"><a id="aacdcff5fe96c5e3c4bb44f53e1b82878"></a>
template <a class="el" href="classbigintfxd_1_1BigVectorFixedT.html">M2Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetCyclotomicPolynomial</b> (usint m, const <a class="el" href="classbigintfxd_1_1BigIntegerFixedT.html">M2Integer</a> &amp;modulus)</td></tr>
<tr class="separator:aacdcff5fe96c5e3c4bb44f53e1b82878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80788a097dab91bab7d67f1313a87f40"><td class="memItemLeft" align="right" valign="top"><a id="a80788a097dab91bab7d67f1313a87f40"></a>
template <a class="el" href="classbigintfxd_1_1BigIntegerFixedT.html">M2Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>SyntheticRemainder</b> (const <a class="el" href="classbigintfxd_1_1BigVectorFixedT.html">M2Vector</a> &amp;dividend, const <a class="el" href="classbigintfxd_1_1BigIntegerFixedT.html">M2Integer</a> &amp;a, const <a class="el" href="classbigintfxd_1_1BigIntegerFixedT.html">M2Integer</a> &amp;modulus)</td></tr>
<tr class="separator:a80788a097dab91bab7d67f1313a87f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada544cae31c7e1c2f30c5accf63485b5"><td class="memItemLeft" align="right" valign="top"><a id="ada544cae31c7e1c2f30c5accf63485b5"></a>
template <a class="el" href="classbigintfxd_1_1BigVectorFixedT.html">M2Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>SyntheticPolyRemainder</b> (const <a class="el" href="classbigintfxd_1_1BigVectorFixedT.html">M2Vector</a> &amp;dividend, const <a class="el" href="classbigintfxd_1_1BigVectorFixedT.html">M2Vector</a> &amp;aList, const <a class="el" href="classbigintfxd_1_1BigIntegerFixedT.html">M2Integer</a> &amp;modulus)</td></tr>
<tr class="separator:ada544cae31c7e1c2f30c5accf63485b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dcbcd4a3bc3bc28010ba281d2546855"><td class="memItemLeft" align="right" valign="top"><a id="a2dcbcd4a3bc3bc28010ba281d2546855"></a>
template <a class="el" href="classbigintfxd_1_1BigVectorFixedT.html">M2Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PolynomialPower&lt; M2Vector &gt;</b> (const <a class="el" href="classbigintfxd_1_1BigVectorFixedT.html">M2Vector</a> &amp;input, usint power)</td></tr>
<tr class="separator:a2dcbcd4a3bc3bc28010ba281d2546855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20dc048d567853ea6b6f48b7c1ee6ccf"><td class="memItemLeft" align="right" valign="top"><a id="a20dc048d567853ea6b6f48b7c1ee6ccf"></a>
template <a class="el" href="classbigintfxd_1_1BigVectorFixedT.html">M2Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>SyntheticPolynomialDivision</b> (const <a class="el" href="classbigintfxd_1_1BigVectorFixedT.html">M2Vector</a> &amp;dividend, const <a class="el" href="classbigintfxd_1_1BigIntegerFixedT.html">M2Integer</a> &amp;a, const <a class="el" href="classbigintfxd_1_1BigIntegerFixedT.html">M2Integer</a> &amp;modulus)</td></tr>
<tr class="separator:a20dc048d567853ea6b6f48b7c1ee6ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d4778fb02dd61b9213f6d4cbd1f85e"><td class="memItemLeft" align="right" valign="top"><a id="a11d4778fb02dd61b9213f6d4cbd1f85e"></a>
template <a class="el" href="classbigintfxd_1_1BigIntegerFixedT.html">M2Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>FindGeneratorCyclic</b> (const <a class="el" href="classbigintfxd_1_1BigIntegerFixedT.html">M2Integer</a> &amp;modulo)</td></tr>
<tr class="separator:a11d4778fb02dd61b9213f6d4cbd1f85e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a962639e81eadb60080e604d43f9de48a"><td class="memItemLeft" align="right" valign="top"><a id="a962639e81eadb60080e604d43f9de48a"></a>
template bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsGenerator</b> (const <a class="el" href="classbigintfxd_1_1BigIntegerFixedT.html">M2Integer</a> &amp;g, const <a class="el" href="classbigintfxd_1_1BigIntegerFixedT.html">M2Integer</a> &amp;modulo)</td></tr>
<tr class="separator:a962639e81eadb60080e604d43f9de48a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e6a168ccbdb90b9a72e62887c36d54b"><td class="memItemLeft" align="right" valign="top"><a id="a4e6a168ccbdb90b9a72e62887c36d54b"></a>
template std::shared_ptr&lt; std::vector&lt; int64_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GetDigits</b> (const <a class="el" href="classbigintfxd_1_1BigIntegerFixedT.html">M2Integer</a> &amp;u, uint64_t base, uint32_t k)</td></tr>
<tr class="separator:a4e6a168ccbdb90b9a72e62887c36d54b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9217a952de34243535793e32a411b038"><td class="memItemLeft" align="right" valign="top"><a id="a9217a952de34243535793e32a411b038"></a>
template <a class="el" href="classNTL_1_1myZZ.html">M6Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>RootOfUnity&lt; M6Integer &gt;</b> (usint m, const <a class="el" href="classNTL_1_1myZZ.html">M6Integer</a> &amp;modulo)</td></tr>
<tr class="separator:a9217a952de34243535793e32a411b038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee86302cc4f4ba397ecc068fda71734a"><td class="memItemLeft" align="right" valign="top"><a id="aee86302cc4f4ba397ecc068fda71734a"></a>
template std::vector&lt; <a class="el" href="classNTL_1_1myZZ.html">M6Integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>RootsOfUnity</b> (usint m, const std::vector&lt; <a class="el" href="classNTL_1_1myZZ.html">M6Integer</a> &gt; moduli)</td></tr>
<tr class="separator:aee86302cc4f4ba397ecc068fda71734a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7912c508dcc85d4a80ffcc803bf4c307"><td class="memItemLeft" align="right" valign="top"><a id="a7912c508dcc85d4a80ffcc803bf4c307"></a>
template <a class="el" href="classNTL_1_1myZZ.html">M6Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GreatestCommonDivisor</b> (const <a class="el" href="classNTL_1_1myZZ.html">M6Integer</a> &amp;a, const <a class="el" href="classNTL_1_1myZZ.html">M6Integer</a> &amp;b)</td></tr>
<tr class="separator:a7912c508dcc85d4a80ffcc803bf4c307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1110582237255f7af782117309db5974"><td class="memItemLeft" align="right" valign="top"><a id="a1110582237255f7af782117309db5974"></a>
template bool&#160;</td><td class="memItemRight" valign="bottom"><b>MillerRabinPrimalityTest</b> (const <a class="el" href="classNTL_1_1myZZ.html">M6Integer</a> &amp;p, const usint niter)</td></tr>
<tr class="separator:a1110582237255f7af782117309db5974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee2643fa3855aa2b8d1e6e2ebcfe02e8"><td class="memItemLeft" align="right" valign="top"><a id="aee2643fa3855aa2b8d1e6e2ebcfe02e8"></a>
const template <a class="el" href="classNTL_1_1myZZ.html">M6Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PollardRhoFactorization</b> (const <a class="el" href="classNTL_1_1myZZ.html">M6Integer</a> &amp;n)</td></tr>
<tr class="separator:aee2643fa3855aa2b8d1e6e2ebcfe02e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dd1d5f4e433a1ade081a4819107c140"><td class="memItemLeft" align="right" valign="top"><a id="a6dd1d5f4e433a1ade081a4819107c140"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>PrimeFactorize</b> (<a class="el" href="classNTL_1_1myZZ.html">M6Integer</a> n, std::set&lt; <a class="el" href="classNTL_1_1myZZ.html">M6Integer</a> &gt; &amp;primeFactors)</td></tr>
<tr class="separator:a6dd1d5f4e433a1ade081a4819107c140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae0b319c6111c513447b77651b94ab2"><td class="memItemLeft" align="right" valign="top"><a id="abae0b319c6111c513447b77651b94ab2"></a>
template <a class="el" href="classNTL_1_1myZZ.html">M6Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>NextPrime</b> (const <a class="el" href="classNTL_1_1myZZ.html">M6Integer</a> &amp;q, uint64_t cyclotomicOrder)</td></tr>
<tr class="separator:abae0b319c6111c513447b77651b94ab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa19478796bf02caf7c354d6038ec0a1d"><td class="memItemLeft" align="right" valign="top"><a id="aa19478796bf02caf7c354d6038ec0a1d"></a>
template <a class="el" href="classNTL_1_1myZZ.html">M6Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PreviousPrime</b> (const <a class="el" href="classNTL_1_1myZZ.html">M6Integer</a> &amp;q, uint64_t cyclotomicOrder)</td></tr>
<tr class="separator:aa19478796bf02caf7c354d6038ec0a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4177c36b53150702c59ef7773bd35535"><td class="memItemLeft" align="right" valign="top"><a id="a4177c36b53150702c59ef7773bd35535"></a>
template std::vector&lt; <a class="el" href="classNTL_1_1myZZ.html">M6Integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GetTotientList</b> (const <a class="el" href="classNTL_1_1myZZ.html">M6Integer</a> &amp;n)</td></tr>
<tr class="separator:a4177c36b53150702c59ef7773bd35535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0ab88377ad6efb48ae1145f14cecef"><td class="memItemLeft" align="right" valign="top"><a id="adb0ab88377ad6efb48ae1145f14cecef"></a>
template <a class="el" href="classNTL_1_1myVecP.html">M6Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PolyMod</b> (const <a class="el" href="classNTL_1_1myVecP.html">M6Vector</a> &amp;dividend, const <a class="el" href="classNTL_1_1myVecP.html">M6Vector</a> &amp;divisor, const <a class="el" href="classNTL_1_1myZZ.html">M6Integer</a> &amp;modulus)</td></tr>
<tr class="separator:adb0ab88377ad6efb48ae1145f14cecef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad971beb5721f0df7466273a2e9a4d867"><td class="memItemLeft" align="right" valign="top"><a id="ad971beb5721f0df7466273a2e9a4d867"></a>
template <a class="el" href="classNTL_1_1myVecP.html">M6Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PolynomialMultiplication</b> (const <a class="el" href="classNTL_1_1myVecP.html">M6Vector</a> &amp;a, const <a class="el" href="classNTL_1_1myVecP.html">M6Vector</a> &amp;b)</td></tr>
<tr class="separator:ad971beb5721f0df7466273a2e9a4d867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd99264b450e251934fcac7e42d3575b"><td class="memItemLeft" align="right" valign="top"><a id="acd99264b450e251934fcac7e42d3575b"></a>
template <a class="el" href="classNTL_1_1myVecP.html">M6Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetCyclotomicPolynomial</b> (usint m, const <a class="el" href="classNTL_1_1myZZ.html">M6Integer</a> &amp;modulus)</td></tr>
<tr class="separator:acd99264b450e251934fcac7e42d3575b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a032a9deeec9be7dc7dfabb40e3690746"><td class="memItemLeft" align="right" valign="top"><a id="a032a9deeec9be7dc7dfabb40e3690746"></a>
template <a class="el" href="classNTL_1_1myZZ.html">M6Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>SyntheticRemainder</b> (const <a class="el" href="classNTL_1_1myVecP.html">M6Vector</a> &amp;dividend, const <a class="el" href="classNTL_1_1myZZ.html">M6Integer</a> &amp;a, const <a class="el" href="classNTL_1_1myZZ.html">M6Integer</a> &amp;modulus)</td></tr>
<tr class="separator:a032a9deeec9be7dc7dfabb40e3690746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20f7cfcd66fd2484a384355c6aeb4e1f"><td class="memItemLeft" align="right" valign="top"><a id="a20f7cfcd66fd2484a384355c6aeb4e1f"></a>
template <a class="el" href="classNTL_1_1myVecP.html">M6Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>SyntheticPolyRemainder</b> (const <a class="el" href="classNTL_1_1myVecP.html">M6Vector</a> &amp;dividend, const <a class="el" href="classNTL_1_1myVecP.html">M6Vector</a> &amp;aList, const <a class="el" href="classNTL_1_1myZZ.html">M6Integer</a> &amp;modulus)</td></tr>
<tr class="separator:a20f7cfcd66fd2484a384355c6aeb4e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f9ba7c179c63089f2b52367ec94f2d9"><td class="memItemLeft" align="right" valign="top"><a id="a3f9ba7c179c63089f2b52367ec94f2d9"></a>
template <a class="el" href="classNTL_1_1myVecP.html">M6Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PolynomialPower&lt; M6Vector &gt;</b> (const <a class="el" href="classNTL_1_1myVecP.html">M6Vector</a> &amp;input, usint power)</td></tr>
<tr class="separator:a3f9ba7c179c63089f2b52367ec94f2d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2145792bbe19adef047e147453aeb71"><td class="memItemLeft" align="right" valign="top"><a id="ac2145792bbe19adef047e147453aeb71"></a>
template <a class="el" href="classNTL_1_1myVecP.html">M6Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>SyntheticPolynomialDivision</b> (const <a class="el" href="classNTL_1_1myVecP.html">M6Vector</a> &amp;dividend, const <a class="el" href="classNTL_1_1myZZ.html">M6Integer</a> &amp;a, const <a class="el" href="classNTL_1_1myZZ.html">M6Integer</a> &amp;modulus)</td></tr>
<tr class="separator:ac2145792bbe19adef047e147453aeb71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eb3be37a822b9c1450c123120495bab"><td class="memItemLeft" align="right" valign="top"><a id="a4eb3be37a822b9c1450c123120495bab"></a>
template <a class="el" href="classNTL_1_1myZZ.html">M6Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>FindGeneratorCyclic</b> (const <a class="el" href="classNTL_1_1myZZ.html">M6Integer</a> &amp;modulo)</td></tr>
<tr class="separator:a4eb3be37a822b9c1450c123120495bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2583a5d04e6f735fb1e50e778bcf48e7"><td class="memItemLeft" align="right" valign="top"><a id="a2583a5d04e6f735fb1e50e778bcf48e7"></a>
template bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsGenerator</b> (const <a class="el" href="classNTL_1_1myZZ.html">M6Integer</a> &amp;g, const <a class="el" href="classNTL_1_1myZZ.html">M6Integer</a> &amp;modulo)</td></tr>
<tr class="separator:a2583a5d04e6f735fb1e50e778bcf48e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1558134817a7c65aa2ed60eb2382194d"><td class="memItemLeft" align="right" valign="top"><a id="a1558134817a7c65aa2ed60eb2382194d"></a>
template std::shared_ptr&lt; std::vector&lt; int64_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GetDigits</b> (const <a class="el" href="classNTL_1_1myZZ.html">M6Integer</a> &amp;u, uint64_t base, uint32_t k)</td></tr>
<tr class="separator:a1558134817a7c65aa2ed60eb2382194d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc35494290182f6262d47240e6b6448b"><td class="memItemLeft" align="right" valign="top"><a id="abc35494290182f6262d47240e6b6448b"></a>
template <a class="el" href="classintnat_1_1NativeIntegerT.html">NativeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><b>RootOfUnity&lt; NativeInteger &gt;</b> (usint m, const <a class="el" href="classintnat_1_1NativeIntegerT.html">NativeInteger</a> &amp;modulo)</td></tr>
<tr class="separator:abc35494290182f6262d47240e6b6448b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f4be2be343f0d8b52a3df2fde23653b"><td class="memItemLeft" align="right" valign="top"><a id="a3f4be2be343f0d8b52a3df2fde23653b"></a>
template std::vector&lt; <a class="el" href="classintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>RootsOfUnity</b> (usint m, const std::vector&lt; <a class="el" href="classintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; moduli)</td></tr>
<tr class="separator:a3f4be2be343f0d8b52a3df2fde23653b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a7277f1b7e7b5d77019a261fa1d4e92"><td class="memItemLeft" align="right" valign="top"><a id="a1a7277f1b7e7b5d77019a261fa1d4e92"></a>
template <a class="el" href="classintnat_1_1NativeIntegerT.html">NativeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GreatestCommonDivisor</b> (const <a class="el" href="classintnat_1_1NativeIntegerT.html">NativeInteger</a> &amp;a, const <a class="el" href="classintnat_1_1NativeIntegerT.html">NativeInteger</a> &amp;b)</td></tr>
<tr class="separator:a1a7277f1b7e7b5d77019a261fa1d4e92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c3abee5fa5fcb15599c2baf80bb828"><td class="memItemLeft" align="right" valign="top"><a id="a51c3abee5fa5fcb15599c2baf80bb828"></a>
template bool&#160;</td><td class="memItemRight" valign="bottom"><b>MillerRabinPrimalityTest</b> (const <a class="el" href="classintnat_1_1NativeIntegerT.html">NativeInteger</a> &amp;p, const usint niter)</td></tr>
<tr class="separator:a51c3abee5fa5fcb15599c2baf80bb828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24193c8d79313c5d772f745bdd54d85c"><td class="memItemLeft" align="right" valign="top"><a id="a24193c8d79313c5d772f745bdd54d85c"></a>
const template <a class="el" href="classintnat_1_1NativeIntegerT.html">NativeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PollardRhoFactorization</b> (const <a class="el" href="classintnat_1_1NativeIntegerT.html">NativeInteger</a> &amp;n)</td></tr>
<tr class="separator:a24193c8d79313c5d772f745bdd54d85c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b0d86ee3bfbc5e4c688063a4a9e552"><td class="memItemLeft" align="right" valign="top"><a id="a24b0d86ee3bfbc5e4c688063a4a9e552"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>PrimeFactorize</b> (<a class="el" href="classintnat_1_1NativeIntegerT.html">NativeInteger</a> n, std::set&lt; <a class="el" href="classintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;primeFactors)</td></tr>
<tr class="separator:a24b0d86ee3bfbc5e4c688063a4a9e552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c34e010eb56aaefef1accc726f4c11e"><td class="memItemLeft" align="right" valign="top"><a id="a6c34e010eb56aaefef1accc726f4c11e"></a>
template <a class="el" href="classintnat_1_1NativeIntegerT.html">NativeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><b>NextPrime</b> (const <a class="el" href="classintnat_1_1NativeIntegerT.html">NativeInteger</a> &amp;q, uint64_t cyclotomicOrder)</td></tr>
<tr class="separator:a6c34e010eb56aaefef1accc726f4c11e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7497f93377fefeb153bc3860bf9da349"><td class="memItemLeft" align="right" valign="top"><a id="a7497f93377fefeb153bc3860bf9da349"></a>
template <a class="el" href="classintnat_1_1NativeIntegerT.html">NativeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PreviousPrime</b> (const <a class="el" href="classintnat_1_1NativeIntegerT.html">NativeInteger</a> &amp;q, uint64_t cyclotomicOrder)</td></tr>
<tr class="separator:a7497f93377fefeb153bc3860bf9da349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad814d0fbd1f7c6e4b2a1c40d063588d0"><td class="memItemLeft" align="right" valign="top"><a id="ad814d0fbd1f7c6e4b2a1c40d063588d0"></a>
template std::vector&lt; <a class="el" href="classintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GetTotientList</b> (const <a class="el" href="classintnat_1_1NativeIntegerT.html">NativeInteger</a> &amp;n)</td></tr>
<tr class="separator:ad814d0fbd1f7c6e4b2a1c40d063588d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b757af11ecc9d23918a79927ad466c9"><td class="memItemLeft" align="right" valign="top"><a id="a3b757af11ecc9d23918a79927ad466c9"></a>
template std::vector&lt; usint &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GetTotientList</b> (const usint &amp;n)</td></tr>
<tr class="separator:a3b757af11ecc9d23918a79927ad466c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed8ddbb783f446d599e168b9ad5cb52"><td class="memItemLeft" align="right" valign="top"><a id="a0ed8ddbb783f446d599e168b9ad5cb52"></a>
template <a class="el" href="classintnat_1_1NativeVectorT.html">NativeVector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PolyMod</b> (const <a class="el" href="classintnat_1_1NativeVectorT.html">NativeVector</a> &amp;dividend, const <a class="el" href="classintnat_1_1NativeVectorT.html">NativeVector</a> &amp;divisor, const <a class="el" href="classintnat_1_1NativeIntegerT.html">NativeInteger</a> &amp;modulus)</td></tr>
<tr class="separator:a0ed8ddbb783f446d599e168b9ad5cb52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0838cba4f211b64dae6591fc8d8b9eb"><td class="memItemLeft" align="right" valign="top"><a id="aa0838cba4f211b64dae6591fc8d8b9eb"></a>
template <a class="el" href="classintnat_1_1NativeVectorT.html">NativeVector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PolynomialMultiplication</b> (const <a class="el" href="classintnat_1_1NativeVectorT.html">NativeVector</a> &amp;a, const <a class="el" href="classintnat_1_1NativeVectorT.html">NativeVector</a> &amp;b)</td></tr>
<tr class="separator:aa0838cba4f211b64dae6591fc8d8b9eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb485e4c7c1974b0956ed550cecd03f8"><td class="memItemLeft" align="right" valign="top"><a id="afb485e4c7c1974b0956ed550cecd03f8"></a>
template <a class="el" href="classintnat_1_1NativeVectorT.html">NativeVector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetCyclotomicPolynomial</b> (usint m, const <a class="el" href="classintnat_1_1NativeIntegerT.html">NativeInteger</a> &amp;modulus)</td></tr>
<tr class="separator:afb485e4c7c1974b0956ed550cecd03f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2f794e17209ddbc43b365f6302ba187"><td class="memItemLeft" align="right" valign="top"><a id="ad2f794e17209ddbc43b365f6302ba187"></a>
template <a class="el" href="classintnat_1_1NativeIntegerT.html">NativeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><b>SyntheticRemainder</b> (const <a class="el" href="classintnat_1_1NativeVectorT.html">NativeVector</a> &amp;dividend, const <a class="el" href="classintnat_1_1NativeIntegerT.html">NativeInteger</a> &amp;a, const <a class="el" href="classintnat_1_1NativeIntegerT.html">NativeInteger</a> &amp;modulus)</td></tr>
<tr class="separator:ad2f794e17209ddbc43b365f6302ba187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace1d16c89a6d19891ada254d6affa607"><td class="memItemLeft" align="right" valign="top"><a id="ace1d16c89a6d19891ada254d6affa607"></a>
template <a class="el" href="classintnat_1_1NativeVectorT.html">NativeVector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>SyntheticPolyRemainder</b> (const <a class="el" href="classintnat_1_1NativeVectorT.html">NativeVector</a> &amp;dividend, const <a class="el" href="classintnat_1_1NativeVectorT.html">NativeVector</a> &amp;aList, const <a class="el" href="classintnat_1_1NativeIntegerT.html">NativeInteger</a> &amp;modulus)</td></tr>
<tr class="separator:ace1d16c89a6d19891ada254d6affa607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3a8fdd7d52710deb9041797b2a8445d"><td class="memItemLeft" align="right" valign="top"><a id="ab3a8fdd7d52710deb9041797b2a8445d"></a>
template <a class="el" href="classintnat_1_1NativeVectorT.html">NativeVector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PolynomialPower&lt; NativeVector &gt;</b> (const <a class="el" href="classintnat_1_1NativeVectorT.html">NativeVector</a> &amp;input, usint power)</td></tr>
<tr class="separator:ab3a8fdd7d52710deb9041797b2a8445d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45789e9e9b96c33782078174336b9e22"><td class="memItemLeft" align="right" valign="top"><a id="a45789e9e9b96c33782078174336b9e22"></a>
template <a class="el" href="classintnat_1_1NativeVectorT.html">NativeVector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>SyntheticPolynomialDivision</b> (const <a class="el" href="classintnat_1_1NativeVectorT.html">NativeVector</a> &amp;dividend, const <a class="el" href="classintnat_1_1NativeIntegerT.html">NativeInteger</a> &amp;a, const <a class="el" href="classintnat_1_1NativeIntegerT.html">NativeInteger</a> &amp;modulus)</td></tr>
<tr class="separator:a45789e9e9b96c33782078174336b9e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40f4523dc145b5c36700602878483d5"><td class="memItemLeft" align="right" valign="top"><a id="ad40f4523dc145b5c36700602878483d5"></a>
template <a class="el" href="classintnat_1_1NativeIntegerT.html">NativeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><b>FindGeneratorCyclic</b> (const <a class="el" href="classintnat_1_1NativeIntegerT.html">NativeInteger</a> &amp;modulo)</td></tr>
<tr class="separator:ad40f4523dc145b5c36700602878483d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bce58da1c779e6d4b147c2ef09031ac"><td class="memItemLeft" align="right" valign="top"><a id="a5bce58da1c779e6d4b147c2ef09031ac"></a>
template bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsGenerator</b> (const <a class="el" href="classintnat_1_1NativeIntegerT.html">NativeInteger</a> &amp;g, const <a class="el" href="classintnat_1_1NativeIntegerT.html">NativeInteger</a> &amp;modulo)</td></tr>
<tr class="separator:a5bce58da1c779e6d4b147c2ef09031ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18b8da1431b69131c1c08bd346894a08"><td class="memItemLeft" align="right" valign="top"><a id="a18b8da1431b69131c1c08bd346894a08"></a>
template std::shared_ptr&lt; std::vector&lt; int64_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GetDigits</b> (const <a class="el" href="classintnat_1_1NativeIntegerT.html">NativeInteger</a> &amp;u, uint64_t base, uint32_t k)</td></tr>
<tr class="separator:a18b8da1431b69131c1c08bd346894a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3257c3185be37e0115a4ebcd73746998"><td class="memItemLeft" align="right" valign="top"><a id="a3257c3185be37e0115a4ebcd73746998"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MODEQ_FOR_TYPE</b> (<a class="el" href="classintnat_1_1NativeIntegerT.html">NativeInteger</a>) MODEQ_FOR_TYPE(<a class="el" href="classbigintfxd_1_1BigIntegerFixedT.html">BigInteger</a>) MODSUBEQ_FOR_TYPE(<a class="el" href="classintnat_1_1NativeIntegerT.html">NativeInteger</a>) MODSUBEQ_FOR_TYPE(<a class="el" href="classbigintfxd_1_1BigIntegerFixedT.html">BigInteger</a>) <a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; double &gt; <a class="el" href="namespacelbcrypto.html#ae6893ac584a13976b1ce006a926cdcf5">Cholesky</a>(const <a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; int32_t &gt; &amp;input)</td></tr>
<tr class="separator:a3257c3185be37e0115a4ebcd73746998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a989ba2f567fd052fd706de852ec0a187"><td class="memItemLeft" align="right" valign="top"><a id="a989ba2f567fd052fd706de852ec0a187"></a>
<a class="el" href="classNTL_1_1myZZ.html">NTL::myZZ</a>&#160;</td><td class="memItemRight" valign="bottom"><b>RNG</b> (const <a class="el" href="classNTL_1_1myZZ.html">NTL::myZZ</a> &amp;modulus)</td></tr>
<tr class="separator:a989ba2f567fd052fd706de852ec0a187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe396ed546052863f0805146cafbf7c"><td class="memTemplParams" colspan="2">template&lt;class Element &gt; </td></tr>
<tr class="memitem:aafe396ed546052863f0805146cafbf7c"><td class="memTemplItemLeft" align="right" valign="top">Ciphertext&lt; Element &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#aafe396ed546052863f0805146cafbf7c">operator+</a> (const Ciphertext&lt; Element &gt; &amp;a, const Ciphertext&lt; Element &gt; &amp;b)</td></tr>
<tr class="separator:aafe396ed546052863f0805146cafbf7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54311f16acb675d1d583e657738e8cee"><td class="memTemplParams" colspan="2">template&lt;class Element &gt; </td></tr>
<tr class="memitem:a54311f16acb675d1d583e657738e8cee"><td class="memTemplItemLeft" align="right" valign="top">const Ciphertext&lt; Element &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#a54311f16acb675d1d583e657738e8cee">operator+=</a> (Ciphertext&lt; Element &gt; &amp;a, const Ciphertext&lt; Element &gt; &amp;b)</td></tr>
<tr class="separator:a54311f16acb675d1d583e657738e8cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e050263421918db5b94679962aed44a"><td class="memTemplParams" colspan="2">template&lt;class Element &gt; </td></tr>
<tr class="memitem:a5e050263421918db5b94679962aed44a"><td class="memTemplItemLeft" align="right" valign="top">Ciphertext&lt; Element &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#a5e050263421918db5b94679962aed44a">operator-</a> (const Ciphertext&lt; Element &gt; &amp;a)</td></tr>
<tr class="separator:a5e050263421918db5b94679962aed44a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad21db8adad8da86eb55ac6baf2484f92"><td class="memTemplParams" colspan="2">template&lt;class Element &gt; </td></tr>
<tr class="memitem:ad21db8adad8da86eb55ac6baf2484f92"><td class="memTemplItemLeft" align="right" valign="top">Ciphertext&lt; Element &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#ad21db8adad8da86eb55ac6baf2484f92">operator-</a> (const Ciphertext&lt; Element &gt; &amp;a, const Ciphertext&lt; Element &gt; &amp;b)</td></tr>
<tr class="separator:ad21db8adad8da86eb55ac6baf2484f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdbb6a74258dfaf9a8bb391ea5be078f"><td class="memTemplParams" colspan="2">template&lt;class Element &gt; </td></tr>
<tr class="memitem:abdbb6a74258dfaf9a8bb391ea5be078f"><td class="memTemplItemLeft" align="right" valign="top">const Ciphertext&lt; Element &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#abdbb6a74258dfaf9a8bb391ea5be078f">operator-=</a> (Ciphertext&lt; Element &gt; &amp;a, const Ciphertext&lt; Element &gt; &amp;b)</td></tr>
<tr class="separator:abdbb6a74258dfaf9a8bb391ea5be078f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a700d05a136c2540ed57cea26eb0670a5"><td class="memTemplParams" colspan="2">template&lt;class Element &gt; </td></tr>
<tr class="memitem:a700d05a136c2540ed57cea26eb0670a5"><td class="memTemplItemLeft" align="right" valign="top">Ciphertext&lt; Element &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#a700d05a136c2540ed57cea26eb0670a5">operator*</a> (const Ciphertext&lt; Element &gt; &amp;a, const Ciphertext&lt; Element &gt; &amp;b)</td></tr>
<tr class="separator:a700d05a136c2540ed57cea26eb0670a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b08387d409937360c05572578eae5ce"><td class="memTemplParams" colspan="2">template&lt;class Element &gt; </td></tr>
<tr class="memitem:a4b08387d409937360c05572578eae5ce"><td class="memTemplItemLeft" align="right" valign="top">const Ciphertext&lt; Element &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#a4b08387d409937360c05572578eae5ce">operator*=</a> (Ciphertext&lt; Element &gt; &amp;a, const Ciphertext&lt; Element &gt; &amp;b)</td></tr>
<tr class="separator:a4b08387d409937360c05572578eae5ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad07b4c0a703df08618d07f219d0a3535"><td class="memItemLeft" align="right" valign="top"><a id="ad07b4c0a703df08618d07f219d0a3535"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>knownParameterSet</b> (string p)</td></tr>
<tr class="separator:ad07b4c0a703df08618d07f219d0a3535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a698c28cae7b93e04de9616db6b168e68"><td class="memItemLeft" align="right" valign="top"><a id="a698c28cae7b93e04de9616db6b168e68"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;out, std::shared_ptr&lt; <a class="el" href="classlbcrypto_1_1EncodingParamsImpl.html">EncodingParamsImpl</a> &gt; o)</td></tr>
<tr class="separator:a698c28cae7b93e04de9616db6b168e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a229bf915ef5f8183bfbcfd035805cf27"><td class="memItemLeft" align="right" valign="top"><a id="a229bf915ef5f8183bfbcfd035805cf27"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (std::shared_ptr&lt; <a class="el" href="classlbcrypto_1_1EncodingParamsImpl.html">EncodingParamsImpl</a> &gt; o1, std::shared_ptr&lt; <a class="el" href="classlbcrypto_1_1EncodingParamsImpl.html">EncodingParamsImpl</a> &gt; o2)</td></tr>
<tr class="separator:a229bf915ef5f8183bfbcfd035805cf27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61b2aa664ff5573de0f99874387ce287"><td class="memItemLeft" align="right" valign="top"><a id="a61b2aa664ff5573de0f99874387ce287"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;out, const PlaintextEncodings p)</td></tr>
<tr class="separator:a61b2aa664ff5573de0f99874387ce287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab608cbe2fdb7070fe58d93e4390c882a"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#ab608cbe2fdb7070fe58d93e4390c882a">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classlbcrypto_1_1PlaintextImpl.html">PlaintextImpl</a> &amp;item)</td></tr>
<tr class="separator:ab608cbe2fdb7070fe58d93e4390c882a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3c8f4eb84a5c6177dff7074b2fa05ba"><td class="memItemLeft" align="right" valign="top"><a id="aa3c8f4eb84a5c6177dff7074b2fa05ba"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;out, const Plaintext item)</td></tr>
<tr class="separator:aa3c8f4eb84a5c6177dff7074b2fa05ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac529e48eb6c79c3079f4323092dd7fe3"><td class="memItemLeft" align="right" valign="top"><a id="ac529e48eb6c79c3079f4323092dd7fe3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const Plaintext p1, const Plaintext p2)</td></tr>
<tr class="separator:ac529e48eb6c79c3079f4323092dd7fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bf0ee5b42baed22de3a365ad711c945"><td class="memItemLeft" align="right" valign="top"><a id="a5bf0ee5b42baed22de3a365ad711c945"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const Plaintext p1, const Plaintext p2)</td></tr>
<tr class="separator:a5bf0ee5b42baed22de3a365ad711c945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b260745a29baa0ad6d8d8307859c353"><td class="memTemplParams" colspan="2"><a id="a2b260745a29baa0ad6d8d8307859c353"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2b260745a29baa0ad6d8d8307859c353"><td class="memTemplItemLeft" align="right" valign="top">T::ContextType&#160;</td><td class="memTemplItemRight" valign="bottom"><b>GenCryptoContext</b> (const <a class="el" href="classlbcrypto_1_1CCParams.html">CCParams</a>&lt; T &gt; &amp;params)</td></tr>
<tr class="separator:a2b260745a29baa0ad6d8d8307859c353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b8bb81efe13f78c359a1d3636d167de"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#a3b8bb81efe13f78c359a1d3636d167de">GenerateUniqueKeyID</a> ()</td></tr>
<tr class="separator:a3b8bb81efe13f78c359a1d3636d167de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6453c5c7cd74a33137d04183bab0d100"><td class="memTemplParams" colspan="2"><a id="a6453c5c7cd74a33137d04183bab0d100"></a>
template&lt;typename ContextGeneratorType , typename Element &gt; </td></tr>
<tr class="memitem:a6453c5c7cd74a33137d04183bab0d100"><td class="memTemplItemLeft" align="right" valign="top">ContextGeneratorType::ContextType&#160;</td><td class="memTemplItemRight" valign="bottom"><b>genCryptoContextBFVRNSInternal</b> (const <a class="el" href="classlbcrypto_1_1CCParams.html">CCParams</a>&lt; ContextGeneratorType &gt; &amp;parameters)</td></tr>
<tr class="separator:a6453c5c7cd74a33137d04183bab0d100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f27544fbb7aef023a0eeb1acb93d051"><td class="memTemplParams" colspan="2"><a id="a7f27544fbb7aef023a0eeb1acb93d051"></a>
template&lt;typename ContextGeneratorType , typename Element &gt; </td></tr>
<tr class="memitem:a7f27544fbb7aef023a0eeb1acb93d051"><td class="memTemplItemLeft" align="right" valign="top">ContextGeneratorType::ContextType&#160;</td><td class="memTemplItemRight" valign="bottom"><b>genCryptoContextBGVRNSInternal</b> (const <a class="el" href="classlbcrypto_1_1CCParams.html">CCParams</a>&lt; ContextGeneratorType &gt; &amp;parameters)</td></tr>
<tr class="separator:a7f27544fbb7aef023a0eeb1acb93d051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ae6379a742b49ccd6088c5b8f009e8"><td class="memTemplParams" colspan="2"><a id="a64ae6379a742b49ccd6088c5b8f009e8"></a>
template&lt;typename ContextGeneratorType , typename Element &gt; </td></tr>
<tr class="memitem:a64ae6379a742b49ccd6088c5b8f009e8"><td class="memTemplItemLeft" align="right" valign="top">ContextGeneratorType::ContextType&#160;</td><td class="memTemplItemRight" valign="bottom"><b>genCryptoContextCKKSRNSInternal</b> (const <a class="el" href="classlbcrypto_1_1CCParams.html">CCParams</a>&lt; ContextGeneratorType &gt; &amp;parameters)</td></tr>
<tr class="separator:a64ae6379a742b49ccd6088c5b8f009e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab95221c9970071b989b99e6feeb860cc"><td class="memItemLeft" align="right" valign="top"><a id="ab95221c9970071b989b99e6feeb860cc"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, SCHEME schemeId)</td></tr>
<tr class="separator:ab95221c9970071b989b99e6feeb860cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a994a0e2160fd10bd384d560059b4137d"><td class="memItemLeft" align="right" valign="top"><a id="a994a0e2160fd10bd384d560059b4137d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isCKKS</b> (SCHEME schemeId)</td></tr>
<tr class="separator:a994a0e2160fd10bd384d560059b4137d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3962f9d17edfbe028f6c183c9f419d63"><td class="memItemLeft" align="right" valign="top"><a id="a3962f9d17edfbe028f6c183c9f419d63"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isBFVRNS</b> (SCHEME schemeId)</td></tr>
<tr class="separator:a3962f9d17edfbe028f6c183c9f419d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b28d66bb9c779b66e2c90c06f6b633"><td class="memItemLeft" align="right" valign="top"><a id="a85b28d66bb9c779b66e2c90c06f6b633"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isBGVRNS</b> (SCHEME schemeId)</td></tr>
<tr class="separator:a85b28d66bb9c779b66e2c90c06f6b633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63f9764ef3827ab89259b02a25769f55"><td class="memTemplParams" colspan="2"><a id="a63f9764ef3827ab89259b02a25769f55"></a>
template&lt;typename Element &gt; </td></tr>
<tr class="memitem:a63f9764ef3827ab89259b02a25769f55"><td class="memTemplItemLeft" align="right" valign="top">shared_ptr&lt; <a class="el" href="classlbcrypto_1_1SchemeBase.html">SchemeBase</a>&lt; Element &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>CreateSchemeGivenName</b> (const string &amp;schemeName)</td></tr>
<tr class="separator:a63f9764ef3827ab89259b02a25769f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4511ad96f5ab358e576946b7317a4587"><td class="memItemLeft" align="right" valign="top"><a id="a4511ad96f5ab358e576946b7317a4587"></a>
std::vector&lt; std::complex&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Conjugate</b> (const std::vector&lt; std::complex&lt; double &gt;&gt; &amp;vec)</td></tr>
<tr class="separator:a4511ad96f5ab358e576946b7317a4587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a2693cad24b155cf37b5d12f6ef3c77"><td class="memItemLeft" align="right" valign="top"><a id="a4a2693cad24b155cf37b5d12f6ef3c77"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>StdDev</b> (const std::vector&lt; std::complex&lt; double &gt;&gt; &amp;vec, const std::vector&lt; std::complex&lt; double &gt;&gt; &amp;conjugate)</td></tr>
<tr class="separator:a4a2693cad24b155cf37b5d12f6ef3c77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3c1aa4b37ce57e4baa6a5b6e71cc34a"><td class="memItemLeft" align="right" valign="top"><a id="ae3c1aa4b37ce57e4baa6a5b6e71cc34a"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classlbcrypto_1_1Params.html">Params</a> &amp;obj)</td></tr>
<tr class="separator:ae3c1aa4b37ce57e4baa6a5b6e71cc34a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a0a6e6282ae0e886a87fb5a1693598f44"><td class="memItemLeft" align="right" valign="top"><a id="a0a6e6282ae0e886a87fb5a1693598f44"></a>
const double&#160;</td><td class="memItemRight" valign="bottom"><b>DG_ERROR</b> = 8.27181e-25</td></tr>
<tr class="separator:a0a6e6282ae0e886a87fb5a1693598f44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c73e2cbee7f77581e902e06e1ce6ad1"><td class="memItemLeft" align="right" valign="top"><a id="a3c73e2cbee7f77581e902e06e1ce6ad1"></a>
const int32_t&#160;</td><td class="memItemRight" valign="bottom"><b>N_MAX</b> = 16384</td></tr>
<tr class="separator:a3c73e2cbee7f77581e902e06e1ce6ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5f0404e17692d0b4e5c47e1a28ee8a"><td class="memItemLeft" align="right" valign="top"><a id="a6a5f0404e17692d0b4e5c47e1a28ee8a"></a>
const double&#160;</td><td class="memItemRight" valign="bottom"><b>SIGMA</b> = std::sqrt(std::log(2 * N_MAX / DG_ERROR) / M_PI)</td></tr>
<tr class="separator:a6a5f0404e17692d0b4e5c47e1a28ee8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa477c1444af1a5bde710fc4c668078f1"><td class="memItemLeft" align="right" valign="top"><a id="aa477c1444af1a5bde710fc4c668078f1"></a>
const double&#160;</td><td class="memItemRight" valign="bottom"><b>SPECTRAL_CONSTANT</b> = 1.8</td></tr>
<tr class="separator:aa477c1444af1a5bde710fc4c668078f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c79f993ae311c3119359c6944f2ba5a"><td class="memItemLeft" align="right" valign="top">const auto&#160;</td><td class="memItemRight" valign="bottom"><b>SPECTRAL_BOUND</b></td></tr>
<tr class="separator:a7c79f993ae311c3119359c6944f2ba5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d321b262649b69f3e6420ca5ff1bd40"><td class="memItemLeft" align="right" valign="top">const auto&#160;</td><td class="memItemRight" valign="bottom"><b>SPECTRAL_BOUND_D</b></td></tr>
<tr class="separator:a9d321b262649b69f3e6420ca5ff1bd40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8286306ff1a1f7279c4855023510639e"><td class="memItemLeft" align="right" valign="top"><a id="a8286306ff1a1f7279c4855023510639e"></a>
const double&#160;</td><td class="memItemRight" valign="bottom"><b>KARNEY_THRESHOLD</b> = 300</td></tr>
<tr class="separator:a8286306ff1a1f7279c4855023510639e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84d4bfb81c1c76bff907a7c5bf9084be"><td class="memItemLeft" align="right" valign="top">const char&#160;</td><td class="memItemRight" valign="bottom"><b>to_base64_char</b> []</td></tr>
<tr class="separator:a84d4bfb81c1c76bff907a7c5bf9084be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8ee328e7b07e765350e69e9651b7cde"><td class="memItemLeft" align="right" valign="top"><a id="ab8ee328e7b07e765350e69e9651b7cde"></a>
<a class="el" href="classlbcrypto_1_1ParallelControls.html">ParallelControls</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PalisadeParallelControls</b></td></tr>
<tr class="separator:ab8ee328e7b07e765350e69e9651b7cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23a7625996aa462989c3e0a81c1f583b"><td class="memItemLeft" align="right" valign="top"><a id="a23a7625996aa462989c3e0a81c1f583b"></a>
const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>PRNG_BUFFER_SIZE</b> = 1024</td></tr>
<tr class="separator:a23a7625996aa462989c3e0a81c1f583b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae41ced5c10016524ef4d69c29b8a61db"><td class="memItemLeft" align="right" valign="top"><a id="ae41ced5c10016524ef4d69c29b8a61db"></a>
const int32_t&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_TREE_DEPTH</b> = 64</td></tr>
<tr class="separator:ae41ced5c10016524ef4d69c29b8a61db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88f78fcc75cecd1035bd2476bf70e2be"><td class="memItemLeft" align="right" valign="top"><a id="a88f78fcc75cecd1035bd2476bf70e2be"></a>
const int32_t&#160;</td><td class="memItemRight" valign="bottom"><b>PRECISION</b> = 53</td></tr>
<tr class="separator:a88f78fcc75cecd1035bd2476bf70e2be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87676b013cb607c1cf0045c9048c640e"><td class="memItemLeft" align="right" valign="top"><a id="a87676b013cb607c1cf0045c9048c640e"></a>
const int32_t&#160;</td><td class="memItemRight" valign="bottom"><b>BERNOULLI_FLIPS</b> = 23</td></tr>
<tr class="separator:a87676b013cb607c1cf0045c9048c640e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a942e3397033092e14f5b39c2f223f25f"><td class="memItemLeft" align="right" valign="top"><a id="a942e3397033092e14f5b39c2f223f25f"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><b>FIRSTMODSIZE</b> = 105</td></tr>
<tr class="separator:a942e3397033092e14f5b39c2f223f25f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accde60e76c2989c9dc6b573c7d3bc6ef"><td class="memItemLeft" align="right" valign="top"><a id="accde60e76c2989c9dc6b573c7d3bc6ef"></a>
enum RescalingTechnique&#160;</td><td class="memItemRight" valign="bottom"><b>DEFAULTRSTECH</b> = FIXEDAUTO</td></tr>
<tr class="separator:accde60e76c2989c9dc6b573c7d3bc6ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59985a08843f10d2b1d519d9fd8222f3"><td class="memItemLeft" align="right" valign="top"><a id="a59985a08843f10d2b1d519d9fd8222f3"></a>
map&lt; string, map&lt; string, string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>CryptoContextParameterSets</b></td></tr>
<tr class="separator:a59985a08843f10d2b1d519d9fd8222f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab90467d6f235a657fa1a6c0a2d718953"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelbcrypto.html#ab90467d6f235a657fa1a6c0a2d718953">SERIALIZE_PRECOMPUTE</a> = true</td></tr>
<tr class="separator:ab90467d6f235a657fa1a6c0a2d718953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a354d3324b5cb03541e92b63fc511ceff"><td class="memItemLeft" align="right" valign="top"><a id="a354d3324b5cb03541e92b63fc511ceff"></a>
const double&#160;</td><td class="memItemRight" valign="bottom"><b>MP_SD</b> = 1048576</td></tr>
<tr class="separator:a354d3324b5cb03541e92b63fc511ceff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44546a10b31155118c633b8633231679"><td class="memItemLeft" align="right" valign="top"><a id="a44546a10b31155118c633b8633231679"></a>
const double&#160;</td><td class="memItemRight" valign="bottom"><b>MPRE_SD</b> = 1048576</td></tr>
<tr class="separator:a44546a10b31155118c633b8633231679"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The namespace of lbcrypto</p>
<p>WARNING FOR PARAMETER SELECTION IN GENERIC SAMPLER</p>
<p>MAKE SURE THAT PRECISION - BERNOULLI FLIPS IS ALWAYS DIVISIBLE BY LOG_BASE WHEN CHOOSING A STANDARD DEVIATION SIGMA_B FOR BASE SAMPLER, MAKE SURE THAT SIGMA_B&gt;=4*SQRT(2)*N WHERE N IS THE SMOOTHING PARAMETER </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="aeb34883759c9d975df1450f89b72be7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb34883759c9d975df1450f89b72be7d">&#9670;&nbsp;</a></span>AdditionWithCarryOut()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t lbcrypto::AdditionWithCarryOut </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>add two 64-bit number with carry out, c = a + b </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>operand 1 </td></tr>
    <tr><td class="paramname">b</td><td>operand 2 </td></tr>
    <tr><td class="paramname">c</td><td>c = a + b </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if overflow occurs, 0 otherwise </dd></dl>

</div>
</div>
<a id="a773e51f8d3e00a51401a2f782c82c3dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a773e51f8d3e00a51401a2f782c82c3dd">&#9670;&nbsp;</a></span>BarrettUint128ModUint64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lbcrypto::BarrettUint128ModUint64 </td>
          <td>(</td>
          <td class="paramtype">const DoubleNativeInt &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>modulus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DoubleNativeInt &amp;&#160;</td>
          <td class="paramname"><em>mu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Barrett reduction of 128-bit integer modulo 64-bit integer. Source: Menezes, Alfred; Oorschot, Paul; Vanstone, Scott. Handbook of Applied Cryptography, Section 14.3.3. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>operand (128-bit) </td></tr>
    <tr><td class="paramname">m</td><td>modulus (64-bit) </td></tr>
    <tr><td class="paramname">mu</td><td>2^128/modulus (128-bit) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result: 64-bit result = a mod m </dd></dl>

</div>
</div>
<a id="ae6893ac584a13976b1ce006a926cdcf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6893ac584a13976b1ce006a926cdcf5">&#9670;&nbsp;</a></span>Cholesky() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt;double&gt; lbcrypto::Cholesky </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; int32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gives the Choleshky decomposition of the input matrix. The assumption is that covariance matrix does not have large coefficients because it is formed by discrete gaussians e and s; this implies int32_t can be used This algorithm can be further improved - see the Darmstadt paper section 4.4 <a href="http://eprint.iacr.org/2013/297.pdf">http://eprint.iacr.org/2013/297.pdf</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;input</td><td>the matrix for which the Cholesky decomposition is to be computed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting matrix of floating-point numbers </dd></dl>

</div>
</div>
<a id="aa5c05572022280760b58ee47de218743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5c05572022280760b58ee47de218743">&#9670;&nbsp;</a></span>Cholesky() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlbcrypto_1_1MatrixStrassen.html">MatrixStrassen</a>&lt; double &gt; lbcrypto::Cholesky </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlbcrypto_1_1MatrixStrassen.html">MatrixStrassen</a>&lt; int32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gives the Choleshky decomposition of the input matrix. The assumption is that covariance matrix does not have large coefficients because it is formed by discrete gaussians e and s; this implies int32_t can be used This algorithm can be further improved - see the Darmstadt paper section 4.4 <a href="http://eprint.iacr.org/2013/297.pdf">http://eprint.iacr.org/2013/297.pdf</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;input</td><td>the matrix for which the Cholesky decomposition is to be computed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting matrix of floating-point numbers </dd></dl>

</div>
</div>
<a id="a60610bbb3daecf8c10b1eef358ae04ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60610bbb3daecf8c10b1eef358ae04ab">&#9670;&nbsp;</a></span>ConvertToInt32() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; int32_t &gt; lbcrypto::ConvertToInt32 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="classbigintfxd_1_1BigIntegerFixedT.html">BigInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbigintfxd_1_1BigIntegerFixedT.html">BigInteger</a> &amp;&#160;</td>
          <td class="paramname"><em>modulus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert a matrix of integers from BigInteger to int32_t Convert from Z_q to [-q/2, q/2]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;input</td><td>the input matrix </td></tr>
    <tr><td class="paramname">&amp;modulus</td><td>the ring modulus </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting matrix of int32_t </dd></dl>

</div>
</div>
<a id="a2a5d674ba2861436dcaac4b88a68d9ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a5d674ba2861436dcaac4b88a68d9ab">&#9670;&nbsp;</a></span>ConvertToInt32() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; int32_t &gt; lbcrypto::ConvertToInt32 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="classbigintfxd_1_1BigVectorFixedT.html">BigVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbigintfxd_1_1BigIntegerFixedT.html">BigInteger</a> &amp;&#160;</td>
          <td class="paramname"><em>modulus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert a matrix of BigVector to int32_t Convert from Z_q to [-q/2, q/2]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;input</td><td>the input matrix </td></tr>
    <tr><td class="paramname">&amp;modulus</td><td>the ring modulus </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting matrix of int32_t </dd></dl>

</div>
</div>
<a id="a12df49c3ca30f4debbb3c9435019d37e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12df49c3ca30f4debbb3c9435019d37e">&#9670;&nbsp;</a></span>ConvertToInt32() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlbcrypto_1_1MatrixStrassen.html">MatrixStrassen</a>&lt; int32_t &gt; lbcrypto::ConvertToInt32 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlbcrypto_1_1MatrixStrassen.html">MatrixStrassen</a>&lt; <a class="el" href="classbigintfxd_1_1BigIntegerFixedT.html">BigInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbigintfxd_1_1BigIntegerFixedT.html">BigInteger</a> &amp;&#160;</td>
          <td class="paramname"><em>modulus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert a matrix of integers from BigInteger to int32_t Convert from Z_q to [-q/2, q/2]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;input</td><td>the input matrix </td></tr>
    <tr><td class="paramname">&amp;modulus</td><td>the ring modulus </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting matrix of int32_t </dd></dl>

</div>
</div>
<a id="aab8e0d271477b1b8afbb5925a16c924a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab8e0d271477b1b8afbb5925a16c924a">&#9670;&nbsp;</a></span>ConvertToInt32() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlbcrypto_1_1MatrixStrassen.html">MatrixStrassen</a>&lt; int32_t &gt; lbcrypto::ConvertToInt32 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlbcrypto_1_1MatrixStrassen.html">MatrixStrassen</a>&lt; <a class="el" href="classbigintfxd_1_1BigVectorFixedT.html">BigVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbigintfxd_1_1BigIntegerFixedT.html">BigInteger</a> &amp;&#160;</td>
          <td class="paramname"><em>modulus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert a matrix of BigVector to int32_t Convert from Z_q to [-q/2, q/2]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;input</td><td>the input matrix </td></tr>
    <tr><td class="paramname">&amp;modulus</td><td>the ring modulus </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting matrix of int32_t </dd></dl>

</div>
</div>
<a id="a014dc4f4f38de1bb1422bed95774eb49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a014dc4f4f38de1bb1422bed95774eb49">&#9670;&nbsp;</a></span>FindAutomorphismIndex2n()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t lbcrypto::FindAutomorphismIndex2n </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find an automorphism index for a power-of-two cyclotomic order </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>is the plaintext array index </td></tr>
    <tr><td class="paramname">m</td><td>is the cyclotomic order </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the automorphism index </dd></dl>

</div>
</div>
<a id="adc6dec4c3cfb7cd9ca4830c1d043ed4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc6dec4c3cfb7cd9ca4830c1d043ed4a">&#9670;&nbsp;</a></span>FindAutomorphismIndex2nComplex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t lbcrypto::FindAutomorphismIndex2nComplex </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacelbcrypto.html#a014dc4f4f38de1bb1422bed95774eb49">FindAutomorphismIndex2n()</a> version for CKKS </dd></dl>

</div>
</div>
<a id="a80c70f2e9171c0fd1b0f919c8e06fe06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80c70f2e9171c0fd1b0f919c8e06fe06">&#9670;&nbsp;</a></span>FindAutomorphismIndexCyclic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t lbcrypto::FindAutomorphismIndexCyclic </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find an automorhism index for cyclic groups </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>is the plaintext array index </td></tr>
    <tr><td class="paramname">m</td><td>is the cyclotomic order </td></tr>
    <tr><td class="paramname">g</td><td>is the generator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the automorphism index </dd></dl>

</div>
</div>
<a id="a27512aa8ffb726f2cad171d8bab60936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27512aa8ffb726f2cad171d8bab60936">&#9670;&nbsp;</a></span>FindGeneratorCyclic()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">IntType lbcrypto::FindGeneratorCyclic </td>
          <td>(</td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds a generator for any cyclic group with modulus q (non-prime moduli are supported); currently q up to 64 bits only are supported </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;q</td><td>is the modulus ( 2, 4, p^k, or 2*p^k where p^k is a power of an odd prime number ) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if g is a generator </dd></dl>

</div>
</div>
<a id="aed8c06a58fb79474c64e25e30ecd6c2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed8c06a58fb79474c64e25e30ecd6c2a">&#9670;&nbsp;</a></span>FirstPrime()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">IntType lbcrypto::FirstPrime </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>nBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the first prime that satisfies q = 1 mod m</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nBits</td><td>the number of bits needed to be in q. </td></tr>
    <tr><td class="paramname">m</td><td>the the ring parameter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the first prime modulus. </dd></dl>

</div>
</div>
<a id="a3b8bb81efe13f78c359a1d3636d167de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b8bb81efe13f78c359a1d3636d167de">&#9670;&nbsp;</a></span>GenerateUniqueKeyID()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string lbcrypto::GenerateUniqueKeyID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generates a random 128-bit hash </p>

</div>
</div>
<a id="ac039ac1cfc6273e816ffcef787ad3d1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac039ac1cfc6273e816ffcef787ad3d1d">&#9670;&nbsp;</a></span>GetCyclotomicPolynomial()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">IntVector lbcrypto::GetCyclotomicPolynomial </td>
          <td>(</td>
          <td class="paramtype">usint&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename IntVector::Integer &amp;&#160;</td>
          <td class="paramname"><em>modulus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the m-th cyclotomic polynomial. Added as a wrapper to GetCyclotomicPolynomialRecursive </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;m</td><td>the input cyclotomic order. </td></tr>
    <tr><td class="paramname">&amp;modulus</td><td>is the working modulus. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>resultant m-th cyclotomic polynomial with coefficients in modulus. </dd></dl>

</div>
</div>
<a id="a060f4282b6f71dc9f51842ff9e972080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a060f4282b6f71dc9f51842ff9e972080">&#9670;&nbsp;</a></span>GetCyclotomicPolynomialRecursive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; lbcrypto::GetCyclotomicPolynomialRecursive </td>
          <td>(</td>
          <td class="paramtype">usint&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the m-th cyclotomic polynomial.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;m</td><td>the input cyclotomic order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>resultant m-th cyclotomic polynomial. </dd></dl>

</div>
</div>
<a id="ae5c3ccbd1174931ca8915581ef872f51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5c3ccbd1174931ca8915581ef872f51">&#9670;&nbsp;</a></span>GetIntegerTypeBitLength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename std::enable_if&lt; std::is_integral&lt; T &gt;::value &amp;&amp;!std::is_same&lt; T, bool &gt;::value, bool &gt;::type  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr usint lbcrypto::GetIntegerTypeBitLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="namespacelbcrypto.html#ae5c3ccbd1174931ca8915581ef872f51">GetIntegerTypeBitLength()</a> calculates the number of all bits in type T and std::enable_if&lt;...&gt; constrains the allowable types to primitive integers only. All other types are excluded. Examples: enum, bool, floating point, any class or struct (ex.: BigInteger, NativeIntegerT, etc.) Ex: auto bitlen = <a class="el" href="namespacelbcrypto.html#ae5c3ccbd1174931ca8915581ef872f51">GetIntegerTypeBitLength&lt;short&gt;()</a>; bitlen == 16 </p>

</div>
</div>
<a id="a65460cc02825edec745044e913db8748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65460cc02825edec745044e913db8748">&#9670;&nbsp;</a></span>GetMSB()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">usint lbcrypto::GetMSB </td>
          <td>(</td>
          <td class="paramtype">IntType&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get MSB of an integer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the input to find MSB of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the MSB bit location. </dd></dl>

</div>
</div>
<a id="ab722558e2a62942f1e07cd2fc5760e32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab722558e2a62942f1e07cd2fc5760e32">&#9670;&nbsp;</a></span>GetMSB64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">usint lbcrypto::GetMSB64 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get MSB of an unsigned 64 bit integer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the input to find MSB of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the MSB bit location. </dd></dl>

</div>
</div>
<a id="a51f165790e4eb0b529f7d6b6f0213101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51f165790e4eb0b529f7d6b6f0213101">&#9670;&nbsp;</a></span>GetTotient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lbcrypto::GetTotient </td>
          <td>(</td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the totient value phi of a number n.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;n</td><td>the input number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>phi of n which is the number of integers m coprime to n such that 1 &lt;= m &lt;= n. </dd></dl>

</div>
</div>
<a id="a61b61fb7a46031802ad47644177e35d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61b61fb7a46031802ad47644177e35d4">&#9670;&nbsp;</a></span>GetTotientList()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; IntType &gt; lbcrypto::GetTotientList </td>
          <td>(</td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the list of coprimes to number n in ascending order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;n</td><td>the input number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of mi's such that 1 &lt;= mi &lt;= n and gcd(mi,n)==1. </dd></dl>

</div>
</div>
<a id="a8eab6b373735c9eae711ed409c546956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eab6b373735c9eae711ed409c546956">&#9670;&nbsp;</a></span>GreatestCommonDivisor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">IntType lbcrypto::GreatestCommonDivisor </td>
          <td>(</td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return greatest common divisor of two big binary integers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>one integer to find greatest common divisor of. </td></tr>
    <tr><td class="paramname">b</td><td>another integer to find greatest common divisor of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the greatest common divisor. </dd></dl>

</div>
</div>
<a id="a35137dac20ea2cebd63cba9cff60acbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35137dac20ea2cebd63cba9cff60acbc">&#9670;&nbsp;</a></span>IsAdditionOverflow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t lbcrypto::IsAdditionOverflow </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>check if adding two 64-bit number can cause overflow </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>operand 1 </td></tr>
    <tr><td class="paramname">b</td><td>operand 2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if overflow occurs, 0 otherwise </dd></dl>

</div>
</div>
<a id="a7c677e43a77ecd38d87163ac57e55ecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c677e43a77ecd38d87163ac57e55ecf">&#9670;&nbsp;</a></span>IsGenerator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool lbcrypto::IsGenerator </td>
          <td>(</td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checkes if g is a generator for any cyclic group with modulus q (non-prime moduli are supported); currently q up to 64 bits only are supported </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;g</td><td>is candidate generator </td></tr>
    <tr><td class="paramname">&amp;q</td><td>is the modulus ( 2, 4, p^k, or 2*p^k where p^k is a power of an odd prime number ) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if g is a generator </dd></dl>

</div>
</div>
<a id="a3c0bee71d2fdd0aeb2b4e300a6da8650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c0bee71d2fdd0aeb2b4e300a6da8650">&#9670;&nbsp;</a></span>IsPowerOfTwo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lbcrypto::IsPowerOfTwo </td>
          <td>(</td>
          <td class="paramtype">usint&#160;</td>
          <td class="paramname"><em>Input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determines if a number is a power of 2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>to test if it is a power of 2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is true if the unsigned int is a power of 2. </dd></dl>

</div>
</div>
<a id="a7a29bc692e0f39ec87283fd676b53397"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a29bc692e0f39ec87283fd676b53397">&#9670;&nbsp;</a></span>MillerRabinPrimalityTest()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool lbcrypto::MillerRabinPrimalityTest </td>
          <td>(</td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const usint&#160;</td>
          <td class="paramname"><em>niter</em> = <code>100</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform the MillerRabin primality test on an IntType. This approach to primality testing is iterative and randomized. It returns false if evidence of non-primality is found, and true if no evidence is found after multiple rounds of testing. The const parameter PRIMALITY_NO_OF_ITERATIONS determines how many rounds are used ( set in <a class="el" href="nbtheory_8h_source.html">nbtheory.h</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the candidate prime to test. </td></tr>
    <tr><td class="paramname">niter</td><td>Number of iterations used for primality testing (default = 100.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if evidence of non-primality is found. True is no evidence of non-primality is found. </dd></dl>

</div>
</div>
<a id="ad0c831c872d1e3f48df8b72379469c8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0c831c872d1e3f48df8b72379469c8b">&#9670;&nbsp;</a></span>ModInverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">usint lbcrypto::ModInverse </td>
          <td>(</td>
          <td class="paramtype">usint&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">usint&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiplicative inverse for primitive unsigned integer data types</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the number we need the inverse of. </td></tr>
    <tr><td class="paramname">b</td><td>the modulus we are working with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the multiplicative inverse </dd></dl>

</div>
</div>
<a id="a18ae7a620f63f3d3d789f4dcff70b83a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18ae7a620f63f3d3d789f4dcff70b83a">&#9670;&nbsp;</a></span>Mul128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DoubleNativeInt lbcrypto::Mul128 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>64-bit uint multiplier, result is 128-bit </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>operand 1 </td></tr>
    <tr><td class="paramname">b</td><td>operand 2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result: 128-bit result = a * b </dd></dl>

</div>
</div>
<a id="a934e1e8a38d866db774303cb181c6fc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a934e1e8a38d866db774303cb181c6fc6">&#9670;&nbsp;</a></span>NextPowerOfTwo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">IntType lbcrypto::NextPowerOfTwo </td>
          <td>(</td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the next power of 2 that is greater than the input number.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;n</td><td>is the input value for which next power of 2 needs to be computed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Next power of 2 that is greater or equal to n. </dd></dl>

</div>
</div>
<a id="a3ebe688fe684e49623f99078f9d8dbc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ebe688fe684e49623f99078f9d8dbc7">&#9670;&nbsp;</a></span>NextPrime()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">IntType lbcrypto::NextPrime </td>
          <td>(</td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>cyclotomicOrder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the next prime that satisfies q = 1 mod m</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;q</td><td>is the prime number to start from (the number itself is not included)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the next prime modulus. </dd></dl>

</div>
</div>
<a id="a700d05a136c2540ed57cea26eb0670a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a700d05a136c2540ed57cea26eb0670a5">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Ciphertext&lt;Element&gt; lbcrypto::operator* </td>
          <td>(</td>
          <td class="paramtype">const Ciphertext&lt; Element &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ciphertext&lt; Element &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>operator* overload. Performs EvalMult.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Element</td><td>a ring element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;a</td><td>ciphertext operand </td></tr>
    <tr><td class="paramname">&amp;b</td><td>ciphertext operand</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of multiplication. </dd></dl>

</div>
</div>
<a id="ae38ba77d200565e23d4f21067a2db89f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae38ba77d200565e23d4f21067a2db89f">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt;Element&gt; lbcrypto::operator* </td>
          <td>(</td>
          <td class="paramtype">Element const &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; Element &gt; const &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator for scalar multiplication of matrix</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;e</td><td>element </td></tr>
    <tr><td class="paramname">&amp;M</td><td>matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting matrix </dd></dl>

</div>
</div>
<a id="a8405776d94662169fd35fbb408e2059f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8405776d94662169fd35fbb408e2059f">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlbcrypto_1_1MatrixStrassen.html">MatrixStrassen</a>&lt;Element&gt; lbcrypto::operator* </td>
          <td>(</td>
          <td class="paramtype">Element const &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlbcrypto_1_1MatrixStrassen.html">MatrixStrassen</a>&lt; Element &gt; const &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Operator for scalar multiplication of matrix</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;e</td><td>element </td></tr>
    <tr><td class="paramname">&amp;M</td><td>matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting matrix </dd></dl>

</div>
</div>
<a id="a4b08387d409937360c05572578eae5ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b08387d409937360c05572578eae5ce">&#9670;&nbsp;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const Ciphertext&lt;Element&gt;&amp; lbcrypto::operator*= </td>
          <td>(</td>
          <td class="paramtype">Ciphertext&lt; Element &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ciphertext&lt; Element &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>operator*= overload for Ciphertexts. Performs EvalMult.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Element</td><td>a ring element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;a</td><td>ciphertext to be multiplied </td></tr>
    <tr><td class="paramname">&amp;b</td><td>ciphertext to multiply by &amp;a</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&amp;a </dd></dl>

</div>
</div>
<a id="aafe396ed546052863f0805146cafbf7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafe396ed546052863f0805146cafbf7c">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Ciphertext&lt;Element&gt; lbcrypto::operator+ </td>
          <td>(</td>
          <td class="paramtype">const Ciphertext&lt; Element &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ciphertext&lt; Element &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>operator+ overload for Ciphertexts. Performs EvalAdd.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Element</td><td>a ring element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;a</td><td>ciphertext operand </td></tr>
    <tr><td class="paramname">&amp;b</td><td>ciphertext operand</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of addition. </dd></dl>

</div>
</div>
<a id="a54311f16acb675d1d583e657738e8cee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54311f16acb675d1d583e657738e8cee">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const Ciphertext&lt;Element&gt;&amp; lbcrypto::operator+= </td>
          <td>(</td>
          <td class="paramtype">Ciphertext&lt; Element &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ciphertext&lt; Element &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>operator+= overload for Ciphertexts. Performs EvalAdd.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Element</td><td>a ring element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;a</td><td>ciphertext to be added to </td></tr>
    <tr><td class="paramname">&amp;b</td><td>ciphertext to add to &amp;a</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&amp;a </dd></dl>

</div>
</div>
<a id="a5e050263421918db5b94679962aed44a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e050263421918db5b94679962aed44a">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Ciphertext&lt;Element&gt; lbcrypto::operator- </td>
          <td>(</td>
          <td class="paramtype">const Ciphertext&lt; Element &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unary negation operator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;a</td><td>ciphertext operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the negation. </dd></dl>

</div>
</div>
<a id="ad21db8adad8da86eb55ac6baf2484f92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad21db8adad8da86eb55ac6baf2484f92">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Ciphertext&lt;Element&gt; lbcrypto::operator- </td>
          <td>(</td>
          <td class="paramtype">const Ciphertext&lt; Element &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ciphertext&lt; Element &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>operator- overload. Performs EvalSub.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Element</td><td>a ring element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;a</td><td>ciphertext operand </td></tr>
    <tr><td class="paramname">&amp;b</td><td>ciphertext operand</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of subtraction. </dd></dl>

</div>
</div>
<a id="abdbb6a74258dfaf9a8bb391ea5be078f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdbb6a74258dfaf9a8bb391ea5be078f">&#9670;&nbsp;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const Ciphertext&lt;Element&gt;&amp; lbcrypto::operator-= </td>
          <td>(</td>
          <td class="paramtype">Ciphertext&lt; Element &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ciphertext&lt; Element &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>operator-= overload for Ciphertexts. Performs EvalAdd.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Element</td><td>a ring element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;a</td><td>ciphertext to be subtracted from </td></tr>
    <tr><td class="paramname">&amp;b</td><td>ciphertext to subtract from &amp;a</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&amp;a </dd></dl>

</div>
</div>
<a id="ab44995ae273c6bd81a72c8fb9b869839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab44995ae273c6bd81a72c8fb9b869839">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; lbcrypto::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlbcrypto_1_1Field2n.html">Field2n</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stream output operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;os</td><td>stream </td></tr>
    <tr><td class="paramname">&amp;m</td><td>matrix to be outputted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the chained stream </dd></dl>

</div>
</div>
<a id="a2f14c6661dccbdf2203415b63772b8c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f14c6661dccbdf2203415b63772b8c0">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; lbcrypto::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; Element &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stream output operator</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;os</td><td>stream </td></tr>
    <tr><td class="paramname">&amp;m</td><td>matrix to be outputted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the chained stream </dd></dl>

</div>
</div>
<a id="a515ae2c54669e003b1da7d36835e4ed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a515ae2c54669e003b1da7d36835e4ed4">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; lbcrypto::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlbcrypto_1_1MatrixStrassen.html">MatrixStrassen</a>&lt; Element &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stream output operator</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;os</td><td>stream </td></tr>
    <tr><td class="paramname">&amp;m</td><td>matrix to be outputted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the chained stream </dd></dl>

</div>
</div>
<a id="a118eb4a5f0d548d8c5e68958bf3a7db5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a118eb4a5f0d548d8c5e68958bf3a7db5">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; lbcrypto::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyImpl</a>&lt; VecType &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>the input preceding output stream </td></tr>
    <tr><td class="paramname">vec</td><td>the element to add to the output stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a resulting concatenated output stream </dd></dl>

</div>
</div>
<a id="ab608cbe2fdb7070fe58d93e4390c882a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab608cbe2fdb7070fe58d93e4390c882a">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; lbcrypto::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlbcrypto_1_1PlaintextImpl.html">PlaintextImpl</a> &amp;&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>operator&lt;&lt; for ostream integration - calls PrintValue </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td></td></tr>
    <tr><td class="paramname">item</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ae09fc7340ed7f12f9e04f174f90956cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae09fc7340ed7f12f9e04f174f90956cf">&#9670;&nbsp;</a></span>PollardRhoFactorization()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const IntType lbcrypto::PollardRhoFactorization </td>
          <td>(</td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform the PollardRho factorization of a IntType. Returns IntType::ONE if no factorization is found.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the value to perform a factorization on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a factor of n, and IntType::ONE if no other factor is found. </dd></dl>

</div>
</div>
<a id="ada1accc37bf21f3fa9b9531c6c61ca48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada1accc37bf21f3fa9b9531c6c61ca48">&#9670;&nbsp;</a></span>PolyMod()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">IntVector lbcrypto::PolyMod </td>
          <td>(</td>
          <td class="paramtype">const IntVector &amp;&#160;</td>
          <td class="paramname"><em>dividend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntVector &amp;&#160;</td>
          <td class="paramname"><em>divisor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename IntVector::Integer &amp;&#160;</td>
          <td class="paramname"><em>modulus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the polynomial modulus.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;dividend</td><td>the input dividend polynomial with degree &gt;= degree of divisor. </td></tr>
    <tr><td class="paramname">&amp;divisor</td><td>the input divisor polynomial with degree &lt;= degree of dividend and divisor is a monic polynomial. </td></tr>
    <tr><td class="paramname">&amp;modulus</td><td>the working modulus. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>resultant polynomial vector s.t. return = divident mod (divisor,modulus). </dd></dl>

</div>
</div>
<a id="a7cb585cae211189317ecd51a4dab836e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cb585cae211189317ecd51a4dab836e">&#9670;&nbsp;</a></span>PolynomialMultiplication()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">IntVector lbcrypto::PolynomialMultiplication </td>
          <td>(</td>
          <td class="paramtype">const IntVector &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntVector &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the polynomial multiplication of the input operands.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;a</td><td>the input polynomial. </td></tr>
    <tr><td class="paramname">&amp;b</td><td>the input polynomial. a and b must have the same modulus. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>resultant polynomial s.t. return = a*b and coefficinet ci = cimodulus. </dd></dl>

</div>
</div>
<a id="a99054b40e099eba7500c35fca4a0946f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99054b40e099eba7500c35fca4a0946f">&#9670;&nbsp;</a></span>PolynomialPower()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">IntVector lbcrypto::PolynomialPower </td>
          <td>(</td>
          <td class="paramtype">const IntVector &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">usint&#160;</td>
          <td class="paramname"><em>power</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the polynomial after raising it by exponent = power. Returns input^power.Uses Frobenius mapping. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;input</td><td>is operand polynomial which needs to be exponentiated. </td></tr>
    <tr><td class="paramname">&amp;power</td><td>is the exponent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>exponentiated polynomial. </dd></dl>

</div>
</div>
<a id="a5d19d9c8fb254adb4b914f7cdc5b86c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d19d9c8fb254adb4b914f7cdc5b86c3">&#9670;&nbsp;</a></span>PrecomputeAutoMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lbcrypto::PrecomputeAutoMap </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint32_t &gt; *&#160;</td>
          <td class="paramname"><em>precomp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Precompute a bit reversal map for a specific automorphism </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>ring dimension </td></tr>
    <tr><td class="paramname">k</td><td>automorphism index </td></tr>
    <tr><td class="paramname">*precomp</td><td>the vector where the precomputed table is stored </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab484504ba741642a2379cc0348f500ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab484504ba741642a2379cc0348f500ea">&#9670;&nbsp;</a></span>PreviousPrime()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">IntType lbcrypto::PreviousPrime </td>
          <td>(</td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>cyclotomicOrder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the previous prime that satisfies q = 1 mod m</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;q</td><td>is the prime number to start from (the number itself is not included)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the previous prime modulus. </dd></dl>

</div>
</div>
<a id="afe449444ce6c301fe21750fa9c2e43db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe449444ce6c301fe21750fa9c2e43db">&#9670;&nbsp;</a></span>PrimeFactorize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void lbcrypto::PrimeFactorize </td>
          <td>(</td>
          <td class="paramtype">IntType&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; IntType &gt; &amp;&#160;</td>
          <td class="paramname"><em>primeFactors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Recursively factorizes to find the distinct primefactors of a number. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;n</td><td>the value to factorize. [note the value of n is destroyed] </td></tr>
    <tr><td class="paramname">&amp;primeFactors</td><td>set of factors found [must begin cleared] Side effects: n is destroyed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4485da7b198be976967e347486bee467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4485da7b198be976967e347486bee467">&#9670;&nbsp;</a></span>replaceChar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string lbcrypto::replaceChar </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Auxiliary function to replace a specific character "in" with another character "out"</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string where in which characters are replaced </td></tr>
    <tr><td class="paramname">in</td><td>character being replaced </td></tr>
    <tr><td class="paramname">out</td><td>character to be replaced with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the modified string. </dd></dl>

</div>
</div>
<a id="ab64c6376dae07b23fddf8f29fde17365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab64c6376dae07b23fddf8f29fde17365">&#9670;&nbsp;</a></span>RootOfUnity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">IntType lbcrypto::RootOfUnity </td>
          <td>(</td>
          <td class="paramtype">usint&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>modulo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds roots of unity for given input. Assumes the the input is a power of two.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>as number which is cyclotomic(in format of int). </td></tr>
    <tr><td class="paramname">&amp;modulo</td><td>which is used to find generator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a root of unity. </dd></dl>

</div>
</div>
<a id="a777538aff71cf6138d28e37ebb17a30c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a777538aff71cf6138d28e37ebb17a30c">&#9670;&nbsp;</a></span>RootsOfUnity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; IntType &gt; lbcrypto::RootsOfUnity </td>
          <td>(</td>
          <td class="paramtype">usint&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; IntType &gt;&#160;</td>
          <td class="paramname"><em>moduli</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds roots of unity for given input. Assumes the the input cyclotomicorder is a power of two.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>as number which is cyclotomic(in format of int). </td></tr>
    <tr><td class="paramname">moduli</td><td>vector of modulus</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of roots of unity corresponding to each modulus. </dd></dl>

</div>
</div>
<a id="a3cefda2cd901845642ee8445a611db79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cefda2cd901845642ee8445a611db79">&#9670;&nbsp;</a></span>Rotate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; typename Element::Integer &gt; lbcrypto::Rotate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; Element &gt; const &amp;&#160;</td>
          <td class="paramname"><em>inMat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generates a matrix of rotations. See pages 7-8 of <a href="https://eprint.iacr.org/2013/297">https://eprint.iacr.org/2013/297</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;inMat</td><td>the matrix of power-of-2 cyclotomic ring elements to be rotated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting matrix of big binary integers </dd></dl>

</div>
</div>
<a id="a7b4318674b09868cabf55377395c95f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b4318674b09868cabf55377395c95f7">&#9670;&nbsp;</a></span>Rotate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlbcrypto_1_1MatrixStrassen.html">MatrixStrassen</a>&lt; <a class="el" href="classbigintfxd_1_1BigIntegerFixedT.html">BigInteger</a> &gt; lbcrypto::Rotate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlbcrypto_1_1MatrixStrassen.html">MatrixStrassen</a>&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">Poly</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>inMat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generates a matrix of rotations. See pages 7-8 of <a href="https://eprint.iacr.org/2013/297">https://eprint.iacr.org/2013/297</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;inMat</td><td>the matrix of power-of-2 cyclotomic ring elements to be rotated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting matrix of big binary integers </dd></dl>

</div>
</div>
<a id="aaa6bc09bac6f4dcdf95ffe767d51a1f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa6bc09bac6f4dcdf95ffe767d51a1f2">&#9670;&nbsp;</a></span>RotateVecResult() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; typename Element::Vector &gt; lbcrypto::RotateVecResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; Element &gt; const &amp;&#160;</td>
          <td class="paramname"><em>inMat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Each element becomes a square matrix with columns of that element's rotations in coefficient form. See pages 7-8 of <a href="https://eprint.iacr.org/2013/297">https://eprint.iacr.org/2013/297</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;inMat</td><td>the matrix of power-of-2 cyclotomic ring elements to be rotated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting matrix of big binary integers</dd></dl>
<p>Each element becomes a square matrix with columns of that element's rotations in Format::COEFFICIENT form. </p>

</div>
</div>
<a id="a9cc5c6579eefc968b53d4dffc29cde26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cc5c6579eefc968b53d4dffc29cde26">&#9670;&nbsp;</a></span>RotateVecResult() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlbcrypto_1_1MatrixStrassen.html">MatrixStrassen</a>&lt; <a class="el" href="classbigintfxd_1_1BigVectorFixedT.html">BigVector</a> &gt; lbcrypto::RotateVecResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlbcrypto_1_1MatrixStrassen.html">MatrixStrassen</a>&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">Poly</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>inMat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Each element becomes a square matrix with columns of that element's rotations in coefficient form. See pages 7-8 of <a href="https://eprint.iacr.org/2013/297">https://eprint.iacr.org/2013/297</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;inMat</td><td>the matrix of power-of-2 cyclotomic ring elements to be rotated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting matrix of big binary integers</dd></dl>
<p>Each element becomes a square matrix with columns of that element's rotations in Format::COEFFICIENT form. </p>

</div>
</div>
<a id="aa8a33e10aa63a9fd8c929dafd8aee7b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8a33e10aa63a9fd8c929dafd8aee7b6">&#9670;&nbsp;</a></span>SplitInt32AltIntoElements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt;Element&gt; lbcrypto::SplitInt32AltIntoElements </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; int32_t &gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; typename Element::Params &gt;&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Another method for splitting a vector of int32_t into a vector of ring elements with ring dimension n</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;other</td><td>the input matrix </td></tr>
    <tr><td class="paramname">&amp;n</td><td>the ring dimension </td></tr>
    <tr><td class="paramname">&amp;params</td><td>Poly element params </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting matrix of Poly </dd></dl>

</div>
</div>
<a id="a3996e2baa9197ffc4c2fae1bf7b213b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3996e2baa9197ffc4c2fae1bf7b213b5">&#9670;&nbsp;</a></span>SplitInt32AltIntoPolyElements()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlbcrypto_1_1MatrixStrassen.html">MatrixStrassen</a>&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">Poly</a> &gt; lbcrypto::SplitInt32AltIntoPolyElements </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlbcrypto_1_1MatrixStrassen.html">MatrixStrassen</a>&lt; int32_t &gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILParamsImpl.html">ILParams</a> &gt;&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Another method for splitting a vector of int32_t into a vector of ring elements with ring dimension n</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;other</td><td>the input matrix </td></tr>
    <tr><td class="paramname">&amp;n</td><td>the ring dimension </td></tr>
    <tr><td class="paramname">&amp;params</td><td>Poly element params </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting matrix of Poly </dd></dl>

</div>
</div>
<a id="a8ebcb03af86d2d7215ad80e6ed640ee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ebcb03af86d2d7215ad80e6ed640ee0">&#9670;&nbsp;</a></span>SplitInt32IntoPolyElements()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlbcrypto_1_1MatrixStrassen.html">MatrixStrassen</a>&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">Poly</a> &gt; lbcrypto::SplitInt32IntoPolyElements </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlbcrypto_1_1MatrixStrassen.html">MatrixStrassen</a>&lt; int32_t &gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILParamsImpl.html">ILParams</a> &gt;&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Split a vector of int32_t into a vector of ring elements with ring dimension n</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;other</td><td>the input matrix </td></tr>
    <tr><td class="paramname">&amp;n</td><td>the ring dimension </td></tr>
    <tr><td class="paramname">&amp;params</td><td>Poly element params </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting matrix of Poly </dd></dl>

</div>
</div>
<a id="acf38638d42ac39f3b143bd5d89150b02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf38638d42ac39f3b143bd5d89150b02">&#9670;&nbsp;</a></span>SplitInt64AltIntoElements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt;Element&gt; lbcrypto::SplitInt64AltIntoElements </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; int64_t &gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; typename Element::Params &gt;&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Split a vector of int64_t into a vector of ring elements with ring dimension n</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;other</td><td>the input matrix </td></tr>
    <tr><td class="paramname">&amp;n</td><td>the ring dimension </td></tr>
    <tr><td class="paramname">&amp;params</td><td>Poly element params </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting matrix of Poly </dd></dl>

</div>
</div>
<a id="a9512202df07e2b7eb423ecbbfcc23a32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9512202df07e2b7eb423ecbbfcc23a32">&#9670;&nbsp;</a></span>SplitInt64IntoElements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt;Element&gt; lbcrypto::SplitInt64IntoElements </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlbcrypto_1_1Matrix.html">Matrix</a>&lt; int64_t &gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; typename Element::Params &gt;&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Split a vector of int32_t into a vector of ring elements with ring dimension n</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;other</td><td>the input matrix </td></tr>
    <tr><td class="paramname">&amp;n</td><td>the ring dimension </td></tr>
    <tr><td class="paramname">&amp;params</td><td>Poly element params </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting matrix of Poly </dd></dl>

</div>
</div>
<a id="a6778a7fcb4acdbb7e0edeec91a5bf4ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6778a7fcb4acdbb7e0edeec91a5bf4ee">&#9670;&nbsp;</a></span>SyntheticPolynomialDivision()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">IntVector lbcrypto::SyntheticPolynomialDivision </td>
          <td>(</td>
          <td class="paramtype">const IntVector &amp;&#160;</td>
          <td class="paramname"><em>dividend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename IntVector::Integer &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename IntVector::Integer &amp;&#160;</td>
          <td class="paramname"><em>modulus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the quotient after polynomial division of dividend with divisor = x-a. Uses synthetic division algorithm. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;dividend</td><td>is the input polynomial dividend in lower to higher coefficient form. </td></tr>
    <tr><td class="paramname">&amp;a</td><td>is the integer in divisor[x-a]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>quotient after division with x-a. </dd></dl>

</div>
</div>
<a id="a27e1453f38eaf4a41a46c8ed71e4eb52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27e1453f38eaf4a41a46c8ed71e4eb52">&#9670;&nbsp;</a></span>SyntheticPolyRemainder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">IntVector lbcrypto::SyntheticPolyRemainder </td>
          <td>(</td>
          <td class="paramtype">const IntVector &amp;&#160;</td>
          <td class="paramname"><em>dividend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntVector &amp;&#160;</td>
          <td class="paramname"><em>aList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename IntVector::Integer &amp;&#160;</td>
          <td class="paramname"><em>modulus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the remainder vector after polynomial division of dividend with divisor = x-aList[i]. Uses synthetic division algorithm. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;dividend</td><td>is the input polynomial dividend in lower to higher coefficient form. </td></tr>
    <tr><td class="paramname">&amp;aList</td><td>is the integer vector for divisor[x-aList[i]]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>remainder vector after division with x-aList[i]. </dd></dl>

</div>
</div>
<a id="a233fa7b7c76cb6cde781319cc053ae84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a233fa7b7c76cb6cde781319cc053ae84">&#9670;&nbsp;</a></span>SyntheticRemainder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">IntVector::Integer lbcrypto::SyntheticRemainder </td>
          <td>(</td>
          <td class="paramtype">const IntVector &amp;&#160;</td>
          <td class="paramname"><em>dividend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename IntVector::Integer &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename IntVector::Integer &amp;&#160;</td>
          <td class="paramname"><em>modulus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the remainder after polynomial division of dividend with divisor = x-a. Uses synthetic division algorithm. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;dividend</td><td>is the input polynomial dividend in lower to higher coefficient form. </td></tr>
    <tr><td class="paramname">&amp;a</td><td>is the integer in divisor[x-a]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>remainder after division with x-a. </dd></dl>

</div>
</div>
<a id="a24cf55013f5ce730296e1ecfc281bb99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24cf55013f5ce730296e1ecfc281bb99">&#9670;&nbsp;</a></span>ZeroPadForward()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">V lbcrypto::ZeroPadForward </td>
          <td>(</td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>InputPoly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">usint&#160;</td>
          <td class="paramname"><em>target_order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Zero Padding of Elements. Adds zeros to form a polynomial of length 2n (corresponding to cyclotomic order m = 2n). It is used by the forward transform of ChineseRemainderTransform (a modified version of ZeroPadd will be used for the non-power-of-2 case).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;InputPoly</td><td>is the element to perform the transform on. </td></tr>
    <tr><td class="paramname">target_order</td><td>is the intended target ordering. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the output of the zero padding. </dd></dl>

</div>
</div>
<a id="a10e13f1a38d295d34102d4ca8235826f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10e13f1a38d295d34102d4ca8235826f">&#9670;&nbsp;</a></span>ZeroPadInverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">V lbcrypto::ZeroPadInverse </td>
          <td>(</td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>InputPoly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">usint&#160;</td>
          <td class="paramname"><em>target_order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Zero Pad Inverse of Elements. Adds alternating zeroes to form a polynomial of length of length 2n (corresponding to cyclotomic order m = 2n). It is used by the inverse transform of ChineseRemainderTransform (a modified version of ZeroPadInverse will be used for the non-power-of-2 case).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;InputPoly</td><td>is the element to perform the transform on. </td></tr>
    <tr><td class="paramname">target_order</td><td>is the intended target ordering. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the output of the zero padding. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ab90467d6f235a657fa1a6c0a2d718953"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab90467d6f235a657fa1a6c0a2d718953">&#9670;&nbsp;</a></span>SERIALIZE_PRECOMPUTE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lbcrypto::SERIALIZE_PRECOMPUTE = true</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Global config variable to determine if PrecomputeCRTTables() will be executed during CryptoContext deserialization. Deserializing without this precomputation can speed up the procedure by a factor of 100.</p>
<p>true (default value): PrecomputeCRTTables() will be executed during deserialization false: PrecomputeCRTTables() will not be executed during deserialization </p>

</div>
</div>
<a id="a7c79f993ae311c3119359c6944f2ba5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c79f993ae311c3119359c6944f2ba5a">&#9670;&nbsp;</a></span>SPECTRAL_BOUND</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const auto lbcrypto::SPECTRAL_BOUND</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](uint64_t n, uint64_t k,</div>
<div class="line">                               uint64_t base) -&gt; <span class="keywordtype">double</span> {</div>
<div class="line">  <span class="keywordflow">return</span> SPECTRAL_CONSTANT * (base + 1) * SIGMA * SIGMA *</div>
<div class="line">         (std::sqrt(n * k) + std::sqrt(2 * n) + 4.7);</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a9d321b262649b69f3e6420ca5ff1bd40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d321b262649b69f3e6420ca5ff1bd40">&#9670;&nbsp;</a></span>SPECTRAL_BOUND_D</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const auto lbcrypto::SPECTRAL_BOUND_D</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](uint64_t n, uint64_t k, uint64_t base,</div>
<div class="line">                                 uint64_t d) -&gt; <span class="keywordtype">double</span> {</div>
<div class="line">  <span class="keywordflow">return</span> SPECTRAL_CONSTANT * (base + 1) * SIGMA * SIGMA *</div>
<div class="line">         (std::sqrt(d * n * k) + std::sqrt(2 * n) + 4.7);</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a84d4bfb81c1c76bff907a7c5bf9084be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84d4bfb81c1c76bff907a7c5bf9084be">&#9670;&nbsp;</a></span>to_base64_char</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char lbcrypto::to_base64_char</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    <span class="stringliteral">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span></div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Feb 4 2022 18:05:24 for PALISADE Lattice Crypto Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
