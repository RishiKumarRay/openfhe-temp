<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PALISADE Lattice Crypto Library: lbcrypto::DCRTPolyImpl&lt; VecType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PALISADE Lattice Crypto Library
   &#160;<span id="projectnumber">1.11.5</span>
   </div>
   <div id="projectbrief">A lattice crypto library for software engineers by software engineers.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelbcrypto.html">lbcrypto</a></li><li class="navelem"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classlbcrypto_1_1DCRTPolyImpl-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">lbcrypto::DCRTPolyImpl&lt; VecType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Ideal lattice for the double-CRT representation. The implementation contains a vector of underlying native-integer lattices The double-CRT representation of polynomials is a common optimization for lattice encryption operations. Basically, it allows large-modulus polynomials to be represented as multiple smaller-modulus polynomials. The double-CRT representations are discussed theoretically here:  
 <a href="classlbcrypto_1_1DCRTPolyImpl.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="dcrtpoly_8h_source.html">dcrtpoly.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for lbcrypto::DCRTPolyImpl&lt; VecType &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classlbcrypto_1_1DCRTPolyImpl__inherit__graph.png" border="0" usemap="#lbcrypto_1_1DCRTPolyImpl_3_01VecType_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="lbcrypto_1_1DCRTPolyImpl_3_01VecType_01_4_inherit__map" id="lbcrypto_1_1DCRTPolyImpl_3_01VecType_01_4_inherit__map">
<area shape="rect" title="Ideal lattice for the double&#45;CRT representation. The implementation contains a vector of underlying n..." alt="" coords="709,20,884,61"/>
<area shape="rect" href="classlbcrypto_1_1DCRTPolyInterface.html" title=" " alt="" coords="457,5,661,76"/>
<area shape="rect" href="classlbcrypto_1_1ILElement.html" title=" " alt="" coords="212,13,409,69"/>
<area shape="rect" href="classlbcrypto_1_1Serializable.html" title="Base class for PALISADE serialization." alt="" coords="5,27,164,54"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for lbcrypto::DCRTPolyImpl&lt; VecType &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classlbcrypto_1_1DCRTPolyImpl__coll__graph.png" border="0" usemap="#lbcrypto_1_1DCRTPolyImpl_3_01VecType_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="lbcrypto_1_1DCRTPolyImpl_3_01VecType_01_4_coll__map" id="lbcrypto_1_1DCRTPolyImpl_3_01VecType_01_4_coll__map">
<area shape="rect" title="Ideal lattice for the double&#45;CRT representation. The implementation contains a vector of underlying n..." alt="" coords="785,69,960,110"/>
<area shape="rect" href="classlbcrypto_1_1DCRTPolyInterface.html" title=" " alt="" coords="532,54,736,125"/>
<area shape="rect" href="classlbcrypto_1_1ILElement.html" title=" " alt="" coords="213,5,411,61"/>
<area shape="rect" href="classlbcrypto_1_1Serializable.html" title="Base class for PALISADE serialization." alt="" coords="5,20,164,47"/>
<area shape="rect" title=" " alt="" coords="233,86,391,127"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a4ca3b6c26118605c4d90a976c174777c"><td class="memItemLeft" align="right" valign="top"><a id="a4ca3b6c26118605c4d90a976c174777c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Integer</b> = typename VecType::Integer</td></tr>
<tr class="separator:a4ca3b6c26118605c4d90a976c174777c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80f4f2e42da3cacc568605024942e5de"><td class="memItemLeft" align="right" valign="top"><a id="a80f4f2e42da3cacc568605024942e5de"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Params</b> = <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">ILDCRTParams</a>&lt; Integer &gt;</td></tr>
<tr class="separator:a80f4f2e42da3cacc568605024942e5de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a83ba8d74d46ce41a6cfea3576ba386"><td class="memItemLeft" align="right" valign="top"><a id="a0a83ba8d74d46ce41a6cfea3576ba386"></a>
typedef VecType&#160;</td><td class="memItemRight" valign="bottom"><b>Vector</b></td></tr>
<tr class="separator:a0a83ba8d74d46ce41a6cfea3576ba386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83b56aa2d2d47b7e190435225334afb7"><td class="memItemLeft" align="right" valign="top"><a id="a83b56aa2d2d47b7e190435225334afb7"></a>
typedef <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>DCRTPolyType</b></td></tr>
<tr class="separator:a83b56aa2d2d47b7e190435225334afb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a217ef6670b2e50c38c6077569b69c8d5"><td class="memItemLeft" align="right" valign="top"><a id="a217ef6670b2e50c38c6077569b69c8d5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>DCRTPolyInterfaceType</b> = <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">DCRTPolyInterface</a>&lt; <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt;, VecType, <a class="el" href="classbigintnat_1_1NativeVector.html">NativeVector</a>, <a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyImpl</a> &gt;</td></tr>
<tr class="separator:a217ef6670b2e50c38c6077569b69c8d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0437cd39919fdc0f80ea21e1dba54f51"><td class="memItemLeft" align="right" valign="top"><a id="a0437cd39919fdc0f80ea21e1dba54f51"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>DggType</b> = typename <a class="el" href="classlbcrypto_1_1DiscreteGaussianGeneratorImpl.html">DCRTPolyInterfaceType::DggType</a></td></tr>
<tr class="separator:a0437cd39919fdc0f80ea21e1dba54f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0311761dc329c1008bdc2a5da66d77d9"><td class="memItemLeft" align="right" valign="top"><a id="a0311761dc329c1008bdc2a5da66d77d9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>DugType</b> = typename <a class="el" href="classlbcrypto_1_1DiscreteUniformGeneratorImpl.html">DCRTPolyInterfaceType::DugType</a></td></tr>
<tr class="separator:a0311761dc329c1008bdc2a5da66d77d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06b4952f1489ca7463e0592b1c114981"><td class="memItemLeft" align="right" valign="top"><a id="a06b4952f1489ca7463e0592b1c114981"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>TugType</b> = typename <a class="el" href="classlbcrypto_1_1TernaryUniformGeneratorImpl.html">DCRTPolyInterfaceType::TugType</a></td></tr>
<tr class="separator:a06b4952f1489ca7463e0592b1c114981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a140023971be4be4ab352cc92b76e22c3"><td class="memItemLeft" align="right" valign="top"><a id="a140023971be4be4ab352cc92b76e22c3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>BugType</b> = typename <a class="el" href="classlbcrypto_1_1BinaryUniformGeneratorImpl.html">DCRTPolyInterfaceType::BugType</a></td></tr>
<tr class="separator:a140023971be4be4ab352cc92b76e22c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0f890b159d51b3289b7cbefd467592d"><td class="memItemLeft" align="right" valign="top"><a id="ab0f890b159d51b3289b7cbefd467592d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>PolyType</b> = <a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyImpl</a>&lt; <a class="el" href="classbigintnat_1_1NativeVector.html">NativeVector</a> &gt;</td></tr>
<tr class="separator:ab0f890b159d51b3289b7cbefd467592d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81194b4a3ba4a99e124ad2412d6b36ad"><td class="memItemLeft" align="right" valign="top"><a id="a81194b4a3ba4a99e124ad2412d6b36ad"></a>
typedef <a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyImpl</a>&lt; VecType &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>PolyLargeType</b></td></tr>
<tr class="separator:a81194b4a3ba4a99e124ad2412d6b36ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classlbcrypto_1_1DCRTPolyInterface"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classlbcrypto_1_1DCRTPolyInterface')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a></td></tr>
<tr class="memitem:a74dfeac425705028c00cad2ebd141417 inherit pub_types_classlbcrypto_1_1DCRTPolyInterface"><td class="memItemLeft" align="right" valign="top"><a id="a74dfeac425705028c00cad2ebd141417"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>BigIntType</b> = typename VecType ::Integer</td></tr>
<tr class="separator:a74dfeac425705028c00cad2ebd141417 inherit pub_types_classlbcrypto_1_1DCRTPolyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd98e3f4f38664fb55e89031a0ae527 inherit pub_types_classlbcrypto_1_1DCRTPolyInterface"><td class="memItemLeft" align="right" valign="top"><a id="a7cd98e3f4f38664fb55e89031a0ae527"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Params</b> = <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">ILDCRTParams</a>&lt; BigIntType &gt;</td></tr>
<tr class="separator:a7cd98e3f4f38664fb55e89031a0ae527 inherit pub_types_classlbcrypto_1_1DCRTPolyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8d7bac4f3bb9d538d175ea4a3f72d42 inherit pub_types_classlbcrypto_1_1DCRTPolyInterface"><td class="memItemLeft" align="right" valign="top"><a id="aa8d7bac4f3bb9d538d175ea4a3f72d42"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>LilIntType</b> = typename <a class="el" href="classbigintnat_1_1NativeVector.html">NativeVector</a> ::Integer</td></tr>
<tr class="separator:aa8d7bac4f3bb9d538d175ea4a3f72d42 inherit pub_types_classlbcrypto_1_1DCRTPolyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6115a3c9848efe0e7eb0f03a571ab62 inherit pub_types_classlbcrypto_1_1DCRTPolyInterface"><td class="memItemLeft" align="right" valign="top"><a id="ad6115a3c9848efe0e7eb0f03a571ab62"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>TowerType</b> = <a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyImpl</a>&lt; <a class="el" href="classbigintnat_1_1NativeVector.html">NativeVector</a> &gt;</td></tr>
<tr class="separator:ad6115a3c9848efe0e7eb0f03a571ab62 inherit pub_types_classlbcrypto_1_1DCRTPolyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb5c47ff7d9e720e63ce9813a3548ce5 inherit pub_types_classlbcrypto_1_1DCRTPolyInterface"><td class="memItemLeft" align="right" valign="top"><a id="acb5c47ff7d9e720e63ce9813a3548ce5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>PolyLargeType</b> = <a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyImpl</a>&lt; VecType &gt;</td></tr>
<tr class="separator:acb5c47ff7d9e720e63ce9813a3548ce5 inherit pub_types_classlbcrypto_1_1DCRTPolyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5560043bd7a46c9fead585f179e9620 inherit pub_types_classlbcrypto_1_1DCRTPolyInterface"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">DCRTPolyInterface</a>&lt; <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt;, VecType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#aa5560043bd7a46c9fead585f179e9620">DCRTPolyInterfaceType</a></td></tr>
<tr class="memdesc:aa5560043bd7a46c9fead585f179e9620 inherit pub_types_classlbcrypto_1_1DCRTPolyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Probably not going to use this, in lieu of.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#aa5560043bd7a46c9fead585f179e9620">More...</a><br /></td></tr>
<tr class="separator:aa5560043bd7a46c9fead585f179e9620 inherit pub_types_classlbcrypto_1_1DCRTPolyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a838ed13093d8b6db3dec4f01c86b59b5 inherit pub_types_classlbcrypto_1_1DCRTPolyInterface"><td class="memItemLeft" align="right" valign="top"><a id="a838ed13093d8b6db3dec4f01c86b59b5"></a>
typedef <a class="el" href="classlbcrypto_1_1DiscreteGaussianGeneratorImpl.html">DiscreteGaussianGeneratorImpl</a>&lt; <a class="el" href="classbigintnat_1_1NativeVector.html">NativeVector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>DggType</b></td></tr>
<tr class="separator:a838ed13093d8b6db3dec4f01c86b59b5 inherit pub_types_classlbcrypto_1_1DCRTPolyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b4241230f64810b01f918979298c9f inherit pub_types_classlbcrypto_1_1DCRTPolyInterface"><td class="memItemLeft" align="right" valign="top"><a id="a96b4241230f64810b01f918979298c9f"></a>
typedef <a class="el" href="classlbcrypto_1_1DiscreteUniformGeneratorImpl.html">DiscreteUniformGeneratorImpl</a>&lt; <a class="el" href="classbigintnat_1_1NativeVector.html">NativeVector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>DugType</b></td></tr>
<tr class="separator:a96b4241230f64810b01f918979298c9f inherit pub_types_classlbcrypto_1_1DCRTPolyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf6855d43cd97e1b381f61846981b0ed inherit pub_types_classlbcrypto_1_1DCRTPolyInterface"><td class="memItemLeft" align="right" valign="top"><a id="aaf6855d43cd97e1b381f61846981b0ed"></a>
typedef <a class="el" href="classlbcrypto_1_1TernaryUniformGeneratorImpl.html">TernaryUniformGeneratorImpl</a>&lt; <a class="el" href="classbigintnat_1_1NativeVector.html">NativeVector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>TugType</b></td></tr>
<tr class="separator:aaf6855d43cd97e1b381f61846981b0ed inherit pub_types_classlbcrypto_1_1DCRTPolyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3cd3ddea172baab0ba6c82c903b7483 inherit pub_types_classlbcrypto_1_1DCRTPolyInterface"><td class="memItemLeft" align="right" valign="top"><a id="aa3cd3ddea172baab0ba6c82c903b7483"></a>
typedef <a class="el" href="classlbcrypto_1_1BinaryUniformGeneratorImpl.html">BinaryUniformGeneratorImpl</a>&lt; <a class="el" href="classbigintnat_1_1NativeVector.html">NativeVector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>BugType</b></td></tr>
<tr class="separator:aa3cd3ddea172baab0ba6c82c903b7483 inherit pub_types_classlbcrypto_1_1DCRTPolyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1ff9f5a499eb6a965275ae0a67bab94a"><td class="memItemLeft" align="right" valign="top"><a id="a1ff9f5a499eb6a965275ae0a67bab94a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a1ff9f5a499eb6a965275ae0a67bab94a">DCRTPolyImpl</a> ()</td></tr>
<tr class="memdesc:a1ff9f5a499eb6a965275ae0a67bab94a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that initialized m_format to EVALUATION and calls m_params to nothing. <br /></td></tr>
<tr class="separator:a1ff9f5a499eb6a965275ae0a67bab94a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add4d65132a6acb62c693c04feab9daba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#add4d65132a6acb62c693c04feab9daba">DCRTPolyImpl</a> (const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt; params, Format format=EVALUATION, bool initializeElementToZero=false)</td></tr>
<tr class="separator:add4d65132a6acb62c693c04feab9daba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac40bd7c467c1045cd8e8bb0b8f1d22d2"><td class="memItemLeft" align="right" valign="top"><a id="ac40bd7c467c1045cd8e8bb0b8f1d22d2"></a>
const <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyLargeType</a> &amp;element)</td></tr>
<tr class="separator:ac40bd7c467c1045cd8e8bb0b8f1d22d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a119218908b8a4614ab25218a2db60270"><td class="memItemLeft" align="right" valign="top"><a id="a119218908b8a4614ab25218a2db60270"></a>
const <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyType</a> &amp;element) override</td></tr>
<tr class="separator:a119218908b8a4614ab25218a2db60270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb81b8f38fa7176e7748cce5ed23f800"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#afb81b8f38fa7176e7748cce5ed23f800">DCRTPolyImpl</a> (const DggType &amp;dgg, const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt; params, Format format=EVALUATION)</td></tr>
<tr class="memdesc:afb81b8f38fa7176e7748cce5ed23f800"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor based on discrete Gaussian generator.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#afb81b8f38fa7176e7748cce5ed23f800">More...</a><br /></td></tr>
<tr class="separator:afb81b8f38fa7176e7748cce5ed23f800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05dc5796dac3425cf2d69052d878a118"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a05dc5796dac3425cf2d69052d878a118">DCRTPolyImpl</a> (const BugType &amp;bug, const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt; params, Format format=EVALUATION)</td></tr>
<tr class="memdesc:a05dc5796dac3425cf2d69052d878a118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor based on binary distribution generator. This is not implemented. Will throw an error.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#a05dc5796dac3425cf2d69052d878a118">More...</a><br /></td></tr>
<tr class="separator:a05dc5796dac3425cf2d69052d878a118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5680d4bac624abac0bd4fa01fc92d28"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#ab5680d4bac624abac0bd4fa01fc92d28">DCRTPolyImpl</a> (const TugType &amp;tug, const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt; params, Format format=EVALUATION, uint32_t h=0)</td></tr>
<tr class="memdesc:ab5680d4bac624abac0bd4fa01fc92d28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor based on ternary distribution generator.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#ab5680d4bac624abac0bd4fa01fc92d28">More...</a><br /></td></tr>
<tr class="separator:ab5680d4bac624abac0bd4fa01fc92d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f8f7f7a99b19297e4c62b91854bd6c5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a9f8f7f7a99b19297e4c62b91854bd6c5">DCRTPolyImpl</a> (DugType &amp;dug, const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt; params, Format format=EVALUATION)</td></tr>
<tr class="memdesc:a9f8f7f7a99b19297e4c62b91854bd6c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor based on discrete uniform generator.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#a9f8f7f7a99b19297e4c62b91854bd6c5">More...</a><br /></td></tr>
<tr class="separator:a9f8f7f7a99b19297e4c62b91854bd6c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b75d1bd3d12a62767dd859d6e3862fb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a1b75d1bd3d12a62767dd859d6e3862fb">DCRTPolyImpl</a> (const <a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyLargeType</a> &amp;element, const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt; params)</td></tr>
<tr class="memdesc:a1b75d1bd3d12a62767dd859d6e3862fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct using a single Poly. The Poly is copied into every tower. Each tower will be reduced to it's corresponding modulus via GetModuli(at tower index). The format is derived from the passed in Poly.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#a1b75d1bd3d12a62767dd859d6e3862fb">More...</a><br /></td></tr>
<tr class="separator:a1b75d1bd3d12a62767dd859d6e3862fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae944168601d7fcda3791a1c10aee559d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#ae944168601d7fcda3791a1c10aee559d">DCRTPolyImpl</a> (const <a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyType</a> &amp;element, const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt; params)</td></tr>
<tr class="memdesc:ae944168601d7fcda3791a1c10aee559d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct using a single PolyType. The PolyType is copied into every tower. Each tower will be reduced to it's corresponding modulus via GetModuli(at tower index). The format is derived from the passed in PolyType.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#ae944168601d7fcda3791a1c10aee559d">More...</a><br /></td></tr>
<tr class="separator:ae944168601d7fcda3791a1c10aee559d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a11d784c029c0ce3c1a0953721d488"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a88a11d784c029c0ce3c1a0953721d488">DCRTPolyImpl</a> (const std::vector&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyType</a> &gt; &amp;elements)</td></tr>
<tr class="memdesc:a88a11d784c029c0ce3c1a0953721d488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct using an tower of ILVectro2ns. The params and format for the DCRTPoly will be derived from the towers.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#a88a11d784c029c0ce3c1a0953721d488">More...</a><br /></td></tr>
<tr class="separator:a88a11d784c029c0ce3c1a0953721d488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac19166c5d8d28697457b50309e314159"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#ac19166c5d8d28697457b50309e314159">DCRTPolyImpl</a> (const <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a> &amp;element)</td></tr>
<tr class="memdesc:ac19166c5d8d28697457b50309e314159"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#ac19166c5d8d28697457b50309e314159">More...</a><br /></td></tr>
<tr class="separator:ac19166c5d8d28697457b50309e314159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d760fe59b028b74c26f230c85ae77cc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a4d760fe59b028b74c26f230c85ae77cc">DCRTPolyImpl</a> (const <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a> &amp;&amp;element)</td></tr>
<tr class="memdesc:a4d760fe59b028b74c26f230c85ae77cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#a4d760fe59b028b74c26f230c85ae77cc">More...</a><br /></td></tr>
<tr class="separator:a4d760fe59b028b74c26f230c85ae77cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1824ade6bc5ba90e9188de3bd2b400c7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a1824ade6bc5ba90e9188de3bd2b400c7">Clone</a> () const override</td></tr>
<tr class="memdesc:a1824ade6bc5ba90e9188de3bd2b400c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone the object by making a copy of it and returning the copy.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#a1824ade6bc5ba90e9188de3bd2b400c7">More...</a><br /></td></tr>
<tr class="separator:a1824ade6bc5ba90e9188de3bd2b400c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ddfb19d04d8ad8ca182728a2729006"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a81ddfb19d04d8ad8ca182728a2729006">CloneTowers</a> (uint32_t startTower, uint32_t endTower) const override</td></tr>
<tr class="memdesc:a81ddfb19d04d8ad8ca182728a2729006"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a copy of the DCRTPoly, but it includes only a sequential subset of the towers that the original holds.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#a81ddfb19d04d8ad8ca182728a2729006">More...</a><br /></td></tr>
<tr class="separator:a81ddfb19d04d8ad8ca182728a2729006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addb77b8b4292fee64c2eb4bf77d34f7a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#addb77b8b4292fee64c2eb4bf77d34f7a">CloneEmpty</a> () const override</td></tr>
<tr class="memdesc:addb77b8b4292fee64c2eb4bf77d34f7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone the object, but have it contain nothing.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#addb77b8b4292fee64c2eb4bf77d34f7a">More...</a><br /></td></tr>
<tr class="separator:addb77b8b4292fee64c2eb4bf77d34f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68b76f72afeb1471f7bafe8315059976"><td class="memItemLeft" align="right" valign="top"><a id="a68b76f72afeb1471f7bafe8315059976"></a>
virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a68b76f72afeb1471f7bafe8315059976">CloneParametersOnly</a> () const override</td></tr>
<tr class="memdesc:a68b76f72afeb1471f7bafe8315059976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone method creates a new DCRTPoly and clones only the params. The tower values are empty. The tower values can be filled by another process/function or initializer list. <br /></td></tr>
<tr class="separator:a68b76f72afeb1471f7bafe8315059976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad0f93665a2538b35dc21982d8f8170"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a4ad0f93665a2538b35dc21982d8f8170">CloneWithNoise</a> (const <a class="el" href="classlbcrypto_1_1DiscreteGaussianGeneratorImpl.html">DiscreteGaussianGeneratorImpl</a>&lt; VecType &gt; &amp;dgg, Format format=EVALUATION) const override</td></tr>
<tr class="memdesc:a4ad0f93665a2538b35dc21982d8f8170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone with noise. This method creates a new DCRTPoly and clones the params. The tower values will be filled up with noise based on the discrete gaussian.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#a4ad0f93665a2538b35dc21982d8f8170">More...</a><br /></td></tr>
<tr class="separator:a4ad0f93665a2538b35dc21982d8f8170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5eea005286d9f396b3f7b561a90423a"><td class="memItemLeft" align="right" valign="top"><a id="af5eea005286d9f396b3f7b561a90423a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#af5eea005286d9f396b3f7b561a90423a">~DCRTPolyImpl</a> ()</td></tr>
<tr class="memdesc:af5eea005286d9f396b3f7b561a90423a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:af5eea005286d9f396b3f7b561a90423a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de4e1a07f58874a6f03f9de8cca63c2"><td class="memItemLeft" align="right" valign="top">virtual Integer &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a3de4e1a07f58874a6f03f9de8cca63c2">at</a> (usint i) override</td></tr>
<tr class="memdesc:a3de4e1a07f58874a6f03f9de8cca63c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get interpolated value of elements at all tower index i. Note this operation is computationally intense.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#a3de4e1a07f58874a6f03f9de8cca63c2">More...</a><br /></td></tr>
<tr class="separator:a3de4e1a07f58874a6f03f9de8cca63c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6aa123972c763b7e7885db48dfe33b4"><td class="memItemLeft" align="right" valign="top"><a id="af6aa123972c763b7e7885db48dfe33b4"></a>
virtual const Integer &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>at</b> (usint i) const override</td></tr>
<tr class="separator:af6aa123972c763b7e7885db48dfe33b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a240aacc87126a12e6b6dd6e6503b0fa1"><td class="memItemLeft" align="right" valign="top">virtual Integer &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a240aacc87126a12e6b6dd6e6503b0fa1">operator[]</a> (usint i) override</td></tr>
<tr class="memdesc:a240aacc87126a12e6b6dd6e6503b0fa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get interpolated value of element at index i. Note this operation is computationally intense.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#a240aacc87126a12e6b6dd6e6503b0fa1">More...</a><br /></td></tr>
<tr class="separator:a240aacc87126a12e6b6dd6e6503b0fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af16b8daf4bf3cffd00fc5fa2c69b2650"><td class="memItemLeft" align="right" valign="top"><a id="af16b8daf4bf3cffd00fc5fa2c69b2650"></a>
virtual const Integer &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (usint i) const override</td></tr>
<tr class="separator:af16b8daf4bf3cffd00fc5fa2c69b2650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a943ae946b1541b8968e008e8f5c9d839"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a943ae946b1541b8968e008e8f5c9d839">GetElementAtIndex</a> (usint i) const override</td></tr>
<tr class="memdesc:a943ae946b1541b8968e008e8f5c9d839"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get method of individual tower of elements. Note this behavior is different than poly.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#a943ae946b1541b8968e008e8f5c9d839">More...</a><br /></td></tr>
<tr class="separator:a943ae946b1541b8968e008e8f5c9d839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5123c286785633ed7726dda3a2de9e9"><td class="memItemLeft" align="right" valign="top">virtual usint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#ac5123c286785633ed7726dda3a2de9e9">GetNumOfElements</a> () const override</td></tr>
<tr class="memdesc:ac5123c286785633ed7726dda3a2de9e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get method of the number of component elements, also known as the number of towers.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#ac5123c286785633ed7726dda3a2de9e9">More...</a><br /></td></tr>
<tr class="separator:ac5123c286785633ed7726dda3a2de9e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60dc86e2084a250d002f47c7581a9990"><td class="memItemLeft" align="right" valign="top">virtual const std::vector&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyType</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a60dc86e2084a250d002f47c7581a9990">GetAllElements</a> () const override</td></tr>
<tr class="memdesc:a60dc86e2084a250d002f47c7581a9990"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get method that returns a vector of all component elements.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#a60dc86e2084a250d002f47c7581a9990">More...</a><br /></td></tr>
<tr class="separator:a60dc86e2084a250d002f47c7581a9990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afceb52d627d4e7c5c03efaf5a1144bb3"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#afceb52d627d4e7c5c03efaf5a1144bb3">BaseDecompose</a> (usint baseBits, bool evalModeAnswer=true) const override</td></tr>
<tr class="memdesc:afceb52d627d4e7c5c03efaf5a1144bb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the element as <img class="formulaInl" alt="$ \sum\limits{i=0}^{\lfloor {\log q/base} \rfloor} {(base^i u_i)} $" src="form_0.png"/> and return the vector of <img class="formulaInl" alt="$ \left\{u_0, u_1,...,u_{\lfloor {\log q/base} \rfloor} \right\} \in R_{{base}^{\lceil {\log q/base} \rceil}} $" src="form_1.png"/>; This is used as a subroutine in the relinearization procedure.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#afceb52d627d4e7c5c03efaf5a1144bb3">More...</a><br /></td></tr>
<tr class="separator:afceb52d627d4e7c5c03efaf5a1144bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af44c8da870103210cc33abb50446f44a"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#af44c8da870103210cc33abb50446f44a">PowersOfBase</a> (usint baseBits) const override</td></tr>
<tr class="memdesc:af44c8da870103210cc33abb50446f44a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a vector of <a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyImpl</a>'s as <img class="formulaInl" alt="$ \left\{x, {base}*x, {base}^2*x, ..., {base}^{\lfloor {\log q/{base}} \rfloor} \right\}*x $" src="form_3.png"/>, where <img class="formulaInl" alt="$ x $" src="form_4.png"/> is the current <a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyImpl</a> object; used as a subroutine in the relinearization procedure to get powers of a certain "base" for the secret key element.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#af44c8da870103210cc33abb50446f44a">More...</a><br /></td></tr>
<tr class="separator:af44c8da870103210cc33abb50446f44a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde6e16e5192893c3aa1fd24e23826ce"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#adde6e16e5192893c3aa1fd24e23826ce">CRTDecompose</a> (uint32_t baseBits=0) const override</td></tr>
<tr class="separator:adde6e16e5192893c3aa1fd24e23826ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a194ec63fd9ff31e9bde2974268525ba9"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a194ec63fd9ff31e9bde2974268525ba9">operator=</a> (const <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a> &amp;rhs) override</td></tr>
<tr class="memdesc:a194ec63fd9ff31e9bde2974268525ba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment Operator.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#a194ec63fd9ff31e9bde2974268525ba9">More...</a><br /></td></tr>
<tr class="separator:a194ec63fd9ff31e9bde2974268525ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd56802ffaaabf5f8b8e1ebaec49a529"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#abd56802ffaaabf5f8b8e1ebaec49a529">operator=</a> (<a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a> &amp;&amp;rhs) override</td></tr>
<tr class="memdesc:abd56802ffaaabf5f8b8e1ebaec49a529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move Assignment Operator.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#abd56802ffaaabf5f8b8e1ebaec49a529">More...</a><br /></td></tr>
<tr class="separator:abd56802ffaaabf5f8b8e1ebaec49a529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2758f06a1075c396b73344ed3a13a734"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a2758f06a1075c396b73344ed3a13a734">operator=</a> (std::initializer_list&lt; uint64_t &gt; rhs) override</td></tr>
<tr class="memdesc:a2758f06a1075c396b73344ed3a13a734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initalizer list.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#a2758f06a1075c396b73344ed3a13a734">More...</a><br /></td></tr>
<tr class="separator:a2758f06a1075c396b73344ed3a13a734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4423d9b9a6034d499e45c4f15ba969d5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a4423d9b9a6034d499e45c4f15ba969d5">operator=</a> (uint64_t val) override</td></tr>
<tr class="memdesc:a4423d9b9a6034d499e45c4f15ba969d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment Operator. The usint val will be set at index zero and all other indices will be set to zero.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#a4423d9b9a6034d499e45c4f15ba969d5">More...</a><br /></td></tr>
<tr class="separator:a4423d9b9a6034d499e45c4f15ba969d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a5a9c1ab6486c7dcd7dd57d6a225872"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a1a5a9c1ab6486c7dcd7dd57d6a225872">operator=</a> (const std::vector&lt; int64_t &gt; &amp;rhs) override</td></tr>
<tr class="memdesc:a1a5a9c1ab6486c7dcd7dd57d6a225872"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a Poly from a vector of signed integers (used for trapdoor sampling)  <a href="classlbcrypto_1_1DCRTPolyImpl.html#a1a5a9c1ab6486c7dcd7dd57d6a225872">More...</a><br /></td></tr>
<tr class="separator:a1a5a9c1ab6486c7dcd7dd57d6a225872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b32d39e39dba41cc4d8b70c3c93acf0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a1b32d39e39dba41cc4d8b70c3c93acf0">operator=</a> (const std::vector&lt; int32_t &gt; &amp;rhs) override</td></tr>
<tr class="memdesc:a1b32d39e39dba41cc4d8b70c3c93acf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a Poly from a vector of signed integers (used for trapdoor sampling)  <a href="classlbcrypto_1_1DCRTPolyImpl.html#a1b32d39e39dba41cc4d8b70c3c93acf0">More...</a><br /></td></tr>
<tr class="separator:a1b32d39e39dba41cc4d8b70c3c93acf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50eb6a2455f926c4a1963b4a59459d7c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a50eb6a2455f926c4a1963b4a59459d7c">operator=</a> (std::initializer_list&lt; std::string &gt; rhs) override</td></tr>
<tr class="memdesc:a50eb6a2455f926c4a1963b4a59459d7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initalizer list.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#a50eb6a2455f926c4a1963b4a59459d7c">More...</a><br /></td></tr>
<tr class="separator:a50eb6a2455f926c4a1963b4a59459d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52f5c45054cfb7fa5587e5f2ba961cde"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a52f5c45054cfb7fa5587e5f2ba961cde">operator-</a> () const override</td></tr>
<tr class="memdesc:a52f5c45054cfb7fa5587e5f2ba961cde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary minus on a element.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#a52f5c45054cfb7fa5587e5f2ba961cde">More...</a><br /></td></tr>
<tr class="separator:a52f5c45054cfb7fa5587e5f2ba961cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d217014f2f8e5075ab2b7d211ffae9"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a38d217014f2f8e5075ab2b7d211ffae9">operator==</a> (const <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a> &amp;rhs) const override</td></tr>
<tr class="memdesc:a38d217014f2f8e5075ab2b7d211ffae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#a38d217014f2f8e5075ab2b7d211ffae9">More...</a><br /></td></tr>
<tr class="separator:a38d217014f2f8e5075ab2b7d211ffae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afccab6ba0d328ddb7edcafe133e5d1dc"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#afccab6ba0d328ddb7edcafe133e5d1dc">operator+=</a> (const <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a> &amp;rhs) override</td></tr>
<tr class="memdesc:afccab6ba0d328ddb7edcafe133e5d1dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an entry-wise addition over all elements of each tower with the towers of the element on the right hand side.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#afccab6ba0d328ddb7edcafe133e5d1dc">More...</a><br /></td></tr>
<tr class="separator:afccab6ba0d328ddb7edcafe133e5d1dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa965df981061d0f6390293612613b8a1"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#aa965df981061d0f6390293612613b8a1">operator-=</a> (const <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a> &amp;rhs) override</td></tr>
<tr class="memdesc:aa965df981061d0f6390293612613b8a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an entry-wise subtraction over all elements of each tower with the towers of the element on the right hand side.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#aa965df981061d0f6390293612613b8a1">More...</a><br /></td></tr>
<tr class="separator:aa965df981061d0f6390293612613b8a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7336e935f2a0cd14d6bcfc8a8a2f373"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#ae7336e935f2a0cd14d6bcfc8a8a2f373">AutomorphismTransform</a> (const usint &amp;i) const override</td></tr>
<tr class="memdesc:ae7336e935f2a0cd14d6bcfc8a8a2f373"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permutes coefficients in a polynomial. Moves the ith index to the first one, it only supports odd indices.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#ae7336e935f2a0cd14d6bcfc8a8a2f373">More...</a><br /></td></tr>
<tr class="separator:ae7336e935f2a0cd14d6bcfc8a8a2f373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f3f1e018b1687961203d6af9b7b1c6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a77f3f1e018b1687961203d6af9b7b1c6">AutomorphismTransform</a> (usint i, const std::vector&lt; usint &gt; &amp;map) const override</td></tr>
<tr class="memdesc:a77f3f1e018b1687961203d6af9b7b1c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an automorphism transform operation using precomputed bit reversal indices.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#a77f3f1e018b1687961203d6af9b7b1c6">More...</a><br /></td></tr>
<tr class="separator:a77f3f1e018b1687961203d6af9b7b1c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35d2fdfaa1eafe1f0f42e380e5356afd"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a35d2fdfaa1eafe1f0f42e380e5356afd">Transpose</a> () const override</td></tr>
<tr class="memdesc:a35d2fdfaa1eafe1f0f42e380e5356afd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose the ring element using the automorphism operation.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#a35d2fdfaa1eafe1f0f42e380e5356afd">More...</a><br /></td></tr>
<tr class="separator:a35d2fdfaa1eafe1f0f42e380e5356afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a3cea10ad195e8b3408da102f0ec9b7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a9a3cea10ad195e8b3408da102f0ec9b7">Plus</a> (const <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a> &amp;element) const override</td></tr>
<tr class="memdesc:a9a3cea10ad195e8b3408da102f0ec9b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an addition operation and returns the result.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#a9a3cea10ad195e8b3408da102f0ec9b7">More...</a><br /></td></tr>
<tr class="separator:a9a3cea10ad195e8b3408da102f0ec9b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90ee91a0f67930426467c8287b86f476"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a90ee91a0f67930426467c8287b86f476">Times</a> (const <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a> &amp;element) const override</td></tr>
<tr class="memdesc:a90ee91a0f67930426467c8287b86f476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a multiplication operation and returns the result.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#a90ee91a0f67930426467c8287b86f476">More...</a><br /></td></tr>
<tr class="separator:a90ee91a0f67930426467c8287b86f476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9094f635ef1078a91ffae5c4520e6615"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a9094f635ef1078a91ffae5c4520e6615">Minus</a> (const <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a> &amp;element) const override</td></tr>
<tr class="memdesc:a9094f635ef1078a91ffae5c4520e6615"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a subtraction operation and returns the result.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#a9094f635ef1078a91ffae5c4520e6615">More...</a><br /></td></tr>
<tr class="separator:a9094f635ef1078a91ffae5c4520e6615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af531265d23d28fc85776bff0789e5205"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#af531265d23d28fc85776bff0789e5205">Plus</a> (const Integer &amp;element) const override</td></tr>
<tr class="memdesc:af531265d23d28fc85776bff0789e5205"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar addition - add an element to the first index of each tower.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#af531265d23d28fc85776bff0789e5205">More...</a><br /></td></tr>
<tr class="separator:af531265d23d28fc85776bff0789e5205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c0a6d0fe477043cceba2adaa95afa9a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a3c0a6d0fe477043cceba2adaa95afa9a">Plus</a> (const vector&lt; Integer &gt; &amp;element) const override</td></tr>
<tr class="memdesc:a3c0a6d0fe477043cceba2adaa95afa9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar addition for elements in CRT format. CRT elements are represented as vector of integer elements which correspond to the represented number modulo the primes in the tower chain (in same order).  <a href="classlbcrypto_1_1DCRTPolyImpl.html#a3c0a6d0fe477043cceba2adaa95afa9a">More...</a><br /></td></tr>
<tr class="separator:a3c0a6d0fe477043cceba2adaa95afa9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade9a9e38b6c5b4e0a445f1526bb731d6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#ade9a9e38b6c5b4e0a445f1526bb731d6">Minus</a> (const Integer &amp;element) const override</td></tr>
<tr class="memdesc:ade9a9e38b6c5b4e0a445f1526bb731d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar subtraction - subtract an element to all entries.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#ade9a9e38b6c5b4e0a445f1526bb731d6">More...</a><br /></td></tr>
<tr class="separator:ade9a9e38b6c5b4e0a445f1526bb731d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23a9e333f86b9f21ef1cca2e1f1e2280"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a23a9e333f86b9f21ef1cca2e1f1e2280">Minus</a> (const vector&lt; Integer &gt; &amp;element) const override</td></tr>
<tr class="memdesc:a23a9e333f86b9f21ef1cca2e1f1e2280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar subtraction for elements in CRT format. CRT elements are represented as vector of integer elements which correspond to the represented number modulo the primes in the tower chain (in same order).  <a href="classlbcrypto_1_1DCRTPolyImpl.html#a23a9e333f86b9f21ef1cca2e1f1e2280">More...</a><br /></td></tr>
<tr class="separator:a23a9e333f86b9f21ef1cca2e1f1e2280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90ef011a1f427c25add508227dcdda34"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a90ef011a1f427c25add508227dcdda34">Times</a> (const Integer &amp;element) const override</td></tr>
<tr class="memdesc:a90ef011a1f427c25add508227dcdda34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar multiplication - multiply all entries.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#a90ef011a1f427c25add508227dcdda34">More...</a><br /></td></tr>
<tr class="separator:a90ef011a1f427c25add508227dcdda34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187ab86229c1ecc9f372fd76886426eb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a187ab86229c1ecc9f372fd76886426eb">Times</a> (bigintnat::NativeInteger::SignedNativeInt element) const override</td></tr>
<tr class="memdesc:a187ab86229c1ecc9f372fd76886426eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar multiplication - multiply by a signed integer.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#a187ab86229c1ecc9f372fd76886426eb">More...</a><br /></td></tr>
<tr class="separator:a187ab86229c1ecc9f372fd76886426eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee610929568e5beb855316a0642365b3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#aee610929568e5beb855316a0642365b3">Times</a> (int64_t element) const override</td></tr>
<tr class="memdesc:aee610929568e5beb855316a0642365b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar multiplication - multiply by a signed integer.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#aee610929568e5beb855316a0642365b3">More...</a><br /></td></tr>
<tr class="separator:aee610929568e5beb855316a0642365b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d4f4516563a969449fa4ea833961264"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a9d4f4516563a969449fa4ea833961264">Times</a> (const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;element) const override</td></tr>
<tr class="memdesc:a9d4f4516563a969449fa4ea833961264"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar multiplication by an integer represented in CRT Basis.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#a9d4f4516563a969449fa4ea833961264">More...</a><br /></td></tr>
<tr class="separator:a9d4f4516563a969449fa4ea833961264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab46382f79a885c1c1df2d5036795f77"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#aab46382f79a885c1c1df2d5036795f77">Times</a> (const std::vector&lt; Integer &gt; &amp;element) const override</td></tr>
<tr class="memdesc:aab46382f79a885c1c1df2d5036795f77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar modular multiplication by an integer represented in CRT Basis.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#aab46382f79a885c1c1df2d5036795f77">More...</a><br /></td></tr>
<tr class="separator:aab46382f79a885c1c1df2d5036795f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b406c67506cb08ee38ef69c004daff3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a5b406c67506cb08ee38ef69c004daff3">Negate</a> () const override</td></tr>
<tr class="memdesc:a5b406c67506cb08ee38ef69c004daff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a negation operation and returns the result.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#a5b406c67506cb08ee38ef69c004daff3">More...</a><br /></td></tr>
<tr class="separator:a5b406c67506cb08ee38ef69c004daff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f25491a1471ffb6b028cd06082cd7f"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#ad5f25491a1471ffb6b028cd06082cd7f">operator+=</a> (const Integer &amp;element) override</td></tr>
<tr class="memdesc:ad5f25491a1471ffb6b028cd06082cd7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs += operation with a BigInteger and returns the result.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#ad5f25491a1471ffb6b028cd06082cd7f">More...</a><br /></td></tr>
<tr class="separator:ad5f25491a1471ffb6b028cd06082cd7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0946e79b8bfd1bb65600b0a203b8899"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#aa0946e79b8bfd1bb65600b0a203b8899">operator-=</a> (const Integer &amp;element) override</td></tr>
<tr class="memdesc:aa0946e79b8bfd1bb65600b0a203b8899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a subtraction operation and returns the result.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#aa0946e79b8bfd1bb65600b0a203b8899">More...</a><br /></td></tr>
<tr class="separator:aa0946e79b8bfd1bb65600b0a203b8899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63a5c2efe731d3835f1cbfcbfde7c0ca"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a63a5c2efe731d3835f1cbfcbfde7c0ca">operator*=</a> (const Integer &amp;element) override</td></tr>
<tr class="memdesc:a63a5c2efe731d3835f1cbfcbfde7c0ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a multiplication operation and returns the result.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#a63a5c2efe731d3835f1cbfcbfde7c0ca">More...</a><br /></td></tr>
<tr class="separator:a63a5c2efe731d3835f1cbfcbfde7c0ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc02a96815782bfe2dc8562ed5985030"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#abc02a96815782bfe2dc8562ed5985030">operator*=</a> (const <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a> &amp;element) override</td></tr>
<tr class="memdesc:abc02a96815782bfe2dc8562ed5985030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an multiplication operation and returns the result.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#abc02a96815782bfe2dc8562ed5985030">More...</a><br /></td></tr>
<tr class="separator:abc02a96815782bfe2dc8562ed5985030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f16ebd27ef359ce367fc8d6669c1a67"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a4f16ebd27ef359ce367fc8d6669c1a67">ElementAtIndex</a> (usint i) override</td></tr>
<tr class="memdesc:a4f16ebd27ef359ce367fc8d6669c1a67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get value of element at index i.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#a4f16ebd27ef359ce367fc8d6669c1a67">More...</a><br /></td></tr>
<tr class="separator:a4f16ebd27ef359ce367fc8d6669c1a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd897dd2c899f77b863fefce1eb8c7eb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#acd897dd2c899f77b863fefce1eb8c7eb">MultiplicativeInverse</a> () const override</td></tr>
<tr class="memdesc:acd897dd2c899f77b863fefce1eb8c7eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a multiplicative inverse operation and returns the result.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#acd897dd2c899f77b863fefce1eb8c7eb">More...</a><br /></td></tr>
<tr class="separator:acd897dd2c899f77b863fefce1eb8c7eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60547fcb7ba2bda5861b637483c4b8a7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a60547fcb7ba2bda5861b637483c4b8a7">SetElementAtIndex</a> (usint index, const <a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyType</a> &amp;element) override</td></tr>
<tr class="memdesc:a60547fcb7ba2bda5861b637483c4b8a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets element at index.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#a60547fcb7ba2bda5861b637483c4b8a7">More...</a><br /></td></tr>
<tr class="separator:a60547fcb7ba2bda5861b637483c4b8a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd0741c2089400d7fa3a0c388cc78a2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a9fd0741c2089400d7fa3a0c388cc78a2">SetElementAtIndex</a> (usint index, <a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyType</a> &amp;&amp;element) override</td></tr>
<tr class="memdesc:a9fd0741c2089400d7fa3a0c388cc78a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets element at index.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#a9fd0741c2089400d7fa3a0c388cc78a2">More...</a><br /></td></tr>
<tr class="separator:a9fd0741c2089400d7fa3a0c388cc78a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1ca2ce8d57875993f650f3a9b229ef0"><td class="memItemLeft" align="right" valign="top"><a id="aa1ca2ce8d57875993f650f3a9b229ef0"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#aa1ca2ce8d57875993f650f3a9b229ef0">SetValuesToZero</a> () override</td></tr>
<tr class="memdesc:aa1ca2ce8d57875993f650f3a9b229ef0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all values of element to zero. <br /></td></tr>
<tr class="separator:aa1ca2ce8d57875993f650f3a9b229ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbab85648499a5954a8ae8f92ea4f8e7"><td class="memItemLeft" align="right" valign="top"><a id="afbab85648499a5954a8ae8f92ea4f8e7"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#afbab85648499a5954a8ae8f92ea4f8e7">AddILElementOne</a> () override</td></tr>
<tr class="memdesc:afbab85648499a5954a8ae8f92ea4f8e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds "1" to every entry in every tower. <br /></td></tr>
<tr class="separator:afbab85648499a5954a8ae8f92ea4f8e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa27a69b9e199e7ad7edb7d88adc44528"><td class="memItemLeft" align="right" valign="top"><a id="aa27a69b9e199e7ad7edb7d88adc44528"></a>
virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#aa27a69b9e199e7ad7edb7d88adc44528">AddRandomNoise</a> (const Integer &amp;modulus) const override</td></tr>
<tr class="memdesc:aa27a69b9e199e7ad7edb7d88adc44528"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add uniformly random values to all components except for the first one. <br /></td></tr>
<tr class="separator:aa27a69b9e199e7ad7edb7d88adc44528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13383a02ee6a007a1c4cf5ea07c3c707"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a13383a02ee6a007a1c4cf5ea07c3c707">MakeSparse</a> (const uint32_t &amp;wFactor) override</td></tr>
<tr class="memdesc:a13383a02ee6a007a1c4cf5ea07c3c707"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make DCRTPoly Sparse. Sets every index of each tower not equal to zero mod the wFactor to zero.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#a13383a02ee6a007a1c4cf5ea07c3c707">More...</a><br /></td></tr>
<tr class="separator:a13383a02ee6a007a1c4cf5ea07c3c707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4b6a822c5551bf0f23b61e1426d26e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#abc4b6a822c5551bf0f23b61e1426d26e">IsEmpty</a> () const override</td></tr>
<tr class="memdesc:abc4b6a822c5551bf0f23b61e1426d26e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if ALL the tower(s) are empty.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#abc4b6a822c5551bf0f23b61e1426d26e">More...</a><br /></td></tr>
<tr class="separator:abc4b6a822c5551bf0f23b61e1426d26e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fb19feee8eb5d6e468e8a07941391dd"><td class="memItemLeft" align="right" valign="top"><a id="a6fb19feee8eb5d6e468e8a07941391dd"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a6fb19feee8eb5d6e468e8a07941391dd">DropLastElement</a> () override</td></tr>
<tr class="memdesc:a6fb19feee8eb5d6e468e8a07941391dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drops the last element in the double-CRT representation. The resulting DCRTPoly element will have one less tower. <br /></td></tr>
<tr class="separator:a6fb19feee8eb5d6e468e8a07941391dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefc561b3187210cd07785dd013430a70"><td class="memItemLeft" align="right" valign="top"><a id="aefc561b3187210cd07785dd013430a70"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#aefc561b3187210cd07785dd013430a70">DropLastElements</a> (size_t i) override</td></tr>
<tr class="memdesc:aefc561b3187210cd07785dd013430a70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drops the last i elements in the double-CRT representation. <br /></td></tr>
<tr class="separator:aefc561b3187210cd07785dd013430a70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a250b81c51dea6af83acf0fd2fc14f365"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a250b81c51dea6af83acf0fd2fc14f365">DropLastElementAndScale</a> (const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;QlQlInvModqlDivqlModq, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;QlQlInvModqlDivqlModqPrecon, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;qlInvModq, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;qlInvModqPrecon) override</td></tr>
<tr class="memdesc:a250b81c51dea6af83acf0fd2fc14f365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drops the last element in the double-CRT representation and scales down by the last CRT modulus. The resulting DCRTPoly element will have one less tower.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#a250b81c51dea6af83acf0fd2fc14f365">More...</a><br /></td></tr>
<tr class="separator:a250b81c51dea6af83acf0fd2fc14f365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a785eaff12419d594ce3255d16894c58f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a785eaff12419d594ce3255d16894c58f">ModReduce</a> (const <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &amp;t, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;tModqPrecon, const <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &amp;negtInvModq, const <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &amp;negtInvModqPrecon, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;qlInvModq, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;qlInvModqPrecon) override</td></tr>
<tr class="memdesc:a785eaff12419d594ce3255d16894c58f"><td class="mdescLeft">&#160;</td><td class="mdescRight">ModReduces reduces the DCRTPoly element's composite modulus by dropping the last modulus from the chain of moduli as well as dropping the last tower.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#a785eaff12419d594ce3255d16894c58f">More...</a><br /></td></tr>
<tr class="separator:a785eaff12419d594ce3255d16894c58f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10aa386efd097ac88b00c6670f147023"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyLargeType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a10aa386efd097ac88b00c6670f147023">CRTInterpolate</a> () const override</td></tr>
<tr class="memdesc:a10aa386efd097ac88b00c6670f147023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolates the DCRTPoly to an Poly based on the Chinese Remainder Transform Interpolation. and then returns a Poly with that single element.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#a10aa386efd097ac88b00c6670f147023">More...</a><br /></td></tr>
<tr class="separator:a10aa386efd097ac88b00c6670f147023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adad9e934179e25717302ba73b59dbe37"><td class="memItemLeft" align="right" valign="top"><a id="adad9e934179e25717302ba73b59dbe37"></a>
virtual <a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>DecryptionCRTInterpolate</b> (PlaintextModulus ptm) const override</td></tr>
<tr class="separator:adad9e934179e25717302ba73b59dbe37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46545e0028127936c8383a13425de51a"><td class="memItemLeft" align="right" valign="top"><a id="a46545e0028127936c8383a13425de51a"></a>
virtual <a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ToNativePoly</b> () const override</td></tr>
<tr class="separator:a46545e0028127936c8383a13425de51a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac03600bc778887c747ac27e74704ccf5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyLargeType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#ac03600bc778887c747ac27e74704ccf5">CRTInterpolateIndex</a> (usint i) const override</td></tr>
<tr class="memdesc:ac03600bc778887c747ac27e74704ccf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolates the DCRTPoly to an Poly based on the Chinese Remainder Transform Interpolation, only at element index i, all other elements are zero. and then returns a Poly with that single element.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#ac03600bc778887c747ac27e74704ccf5">More...</a><br /></td></tr>
<tr class="separator:ac03600bc778887c747ac27e74704ccf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d3e755fea7654aa9b3e7bd14e42a8d"><td class="memItemLeft" align="right" valign="top">virtual Integer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a63d3e755fea7654aa9b3e7bd14e42a8d">GetWorkingModulus</a> () const override</td></tr>
<tr class="memdesc:a63d3e755fea7654aa9b3e7bd14e42a8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and returns the product of primes in the current moduli chain. Compared to GetModulus, which always returns the product of all primes in the crypto parameters, this method will return a different modulus, based on the towers/moduli that are currently in the chain (some towers are dropped along the way).  <a href="classlbcrypto_1_1DCRTPolyImpl.html#a63d3e755fea7654aa9b3e7bd14e42a8d">More...</a><br /></td></tr>
<tr class="separator:a63d3e755fea7654aa9b3e7bd14e42a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae44d26cfeab8b34089756e00aaa2c090"><td class="memItemLeft" align="right" valign="top">virtual shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#ae44d26cfeab8b34089756e00aaa2c090">GetExtendedCRTBasis</a> (std::shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt; paramsP) const override</td></tr>
<tr class="memdesc:ae44d26cfeab8b34089756e00aaa2c090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the element parameters for DCRTPoly elements in an extended CRT basis, which is the concatenation of the towers currently in "this" DCRTPoly, and the moduli in ParamsP.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#ae44d26cfeab8b34089756e00aaa2c090">More...</a><br /></td></tr>
<tr class="separator:ae44d26cfeab8b34089756e00aaa2c090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14326698ef430e239dba7f45ccf3d6f6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a14326698ef430e239dba7f45ccf3d6f6">ApproxSwitchCRTBasis</a> (const std::shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt; paramsQ, const std::shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt; paramsP, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;QHatInvModq, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;QHatInvModqPrecon, const std::vector&lt; std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;&gt; &amp;QHatModp, const std::vector&lt; DoubleNativeInt &gt; &amp;modpBarrettMu) const override</td></tr>
<tr class="memdesc:a14326698ef430e239dba7f45ccf3d6f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs approximate CRT basis switching: {X}_{Q} -&gt; {X'}_{P} X' = X + alpha*Q for small alpha {Q} = {q_1,...,q_l} {P} = {p_1,...,p_k}.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#a14326698ef430e239dba7f45ccf3d6f6">More...</a><br /></td></tr>
<tr class="separator:a14326698ef430e239dba7f45ccf3d6f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69e00186798396fd951b0ed45ce73dba"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a69e00186798396fd951b0ed45ce73dba">ApproxModUp</a> (const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt; paramsQ, const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt; paramsP, const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt; paramsQP, const vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;QHatInvModq, const vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;QHatInvModqPrecon, const vector&lt; vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;&gt; &amp;QHatModp, const vector&lt; DoubleNativeInt &gt; &amp;modpBarrettMu) override</td></tr>
<tr class="memdesc:a69e00186798396fd951b0ed45ce73dba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs approximate modulus raising: {X}_{Q} -&gt; {X'}_{Q,P}. X' = X + alpha*Q for small alpha {Q} = {q_1,...,q_l} {P} = {p_1,...,p_k}.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#a69e00186798396fd951b0ed45ce73dba">More...</a><br /></td></tr>
<tr class="separator:a69e00186798396fd951b0ed45ce73dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f6322433bd3e832bd1405435bcc1fd"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#ac1f6322433bd3e832bd1405435bcc1fd">ApproxModDown</a> (const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt; paramsQ, const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt; paramsP, const vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;PInvModq, const vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;PInvModqPrecon, const vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;PHatInvModp, const vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;PHatInvModpPrecon, const vector&lt; vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;&gt; &amp;PHatModq, const vector&lt; DoubleNativeInt &gt; &amp;modqBarrettMu, const vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;tInvModp=vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;(), const vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;tInvModpPrecon=vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;(), const <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &amp;t=0, const vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;tModqPrecon=vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;()) const override</td></tr>
<tr class="memdesc:ac1f6322433bd3e832bd1405435bcc1fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs approximate modulus reduction: {X}_{Q,P} -&gt; {\approx(X/P)}_{Q}. {Q} = {q_1,...,q_l} {P} = {p_1,...,p_k}.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#ac1f6322433bd3e832bd1405435bcc1fd">More...</a><br /></td></tr>
<tr class="separator:ac1f6322433bd3e832bd1405435bcc1fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84c8c9ac3d8593ad61784f4b9d9624cc"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a84c8c9ac3d8593ad61784f4b9d9624cc">SwitchCRTBasis</a> (const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt; paramsP, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;QHatInvModq, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;QHatInvModqPrecon, const std::vector&lt; std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;&gt; &amp;QHatModp, const std::vector&lt; std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;&gt; &amp;alphaQModp, const std::vector&lt; DoubleNativeInt &gt; &amp;modpBarrettMu, const std::vector&lt; double &gt; &amp;qInv) const override</td></tr>
<tr class="memdesc:a84c8c9ac3d8593ad61784f4b9d9624cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs CRT basis switching: {X}_{Q} -&gt; {X}_{P} {Q} = {q_1,...,q_l} {P} = {p_1,...,p_k}.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#a84c8c9ac3d8593ad61784f4b9d9624cc">More...</a><br /></td></tr>
<tr class="separator:a84c8c9ac3d8593ad61784f4b9d9624cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a7994711f8054391c3b4e243882aab1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a5a7994711f8054391c3b4e243882aab1">ExpandCRTBasis</a> (const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt; paramsQP, const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt; paramsP, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;QHatInvModq, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;QHatInvModqPrecon, const std::vector&lt; std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;&gt; &amp;QHatModp, const std::vector&lt; std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;&gt; &amp;alphaQModp, const std::vector&lt; DoubleNativeInt &gt; &amp;modpBarrettMu, const std::vector&lt; double &gt; &amp;qInv, Format resultFormat=EVALUATION) override</td></tr>
<tr class="memdesc:a5a7994711f8054391c3b4e243882aab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs modulus raising: {X}_{Q} -&gt; {X}_{Q,P} {Q} = {q_1,...,q_l} {P} = {p_1,...,p_k}.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#a5a7994711f8054391c3b4e243882aab1">More...</a><br /></td></tr>
<tr class="separator:a5a7994711f8054391c3b4e243882aab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac519a50276b7a54a86ba4b1dd0bb8e30"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#ac519a50276b7a54a86ba4b1dd0bb8e30">ScaleAndRound</a> (const <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &amp;t, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;tQHatInvModqDivqModt, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;tQHatInvModqDivqModtPrecon, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;tQHatInvModqBDivqModt, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;tQHatInvModqBDivqModtPrecon, const std::vector&lt; double &gt; &amp;tQHatInvModqDivqFrac, const std::vector&lt; double &gt; &amp;tQHatInvModqBDivqFrac) const override</td></tr>
<tr class="memdesc:ac519a50276b7a54a86ba4b1dd0bb8e30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs scale and round: {X}_{Q} -&gt; {\round(t/Q*X)}_t {Q} = {q_1,...,q_l} {P} = {p_1,...,p_k}.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#ac519a50276b7a54a86ba4b1dd0bb8e30">More...</a><br /></td></tr>
<tr class="separator:ac519a50276b7a54a86ba4b1dd0bb8e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada478575a2529b4106ee5ce77d59ad8a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#ada478575a2529b4106ee5ce77d59ad8a">ApproxScaleAndRound</a> (const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt; paramsP, const std::vector&lt; std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;&gt; &amp;tPSHatInvModsDivsModp, const std::vector&lt; DoubleNativeInt &gt; &amp;modpBarretMu) const override</td></tr>
<tr class="memdesc:ada478575a2529b4106ee5ce77d59ad8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes approximate scale and round: {X}_{Q,P} -&gt; {\approx{t/Q * X}}_{P} {Q} = {q_1,...,q_l} {P} = {p_1,...,p_k}.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#ada478575a2529b4106ee5ce77d59ad8a">More...</a><br /></td></tr>
<tr class="separator:ada478575a2529b4106ee5ce77d59ad8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9869928c9d44c9624efd0813322282f9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a9869928c9d44c9624efd0813322282f9">ScaleAndRound</a> (const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt; paramsP, const std::vector&lt; std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;&gt; &amp;tPSHatInvModsDivsModp, const std::vector&lt; double &gt; &amp;tPSHatInvModsDivsFrac, const std::vector&lt; DoubleNativeInt &gt; &amp;modpBarretMu) const override</td></tr>
<tr class="memdesc:a9869928c9d44c9624efd0813322282f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes scale and round: {X}_{Q,P} -&gt; {t/Q * X}_{P} {Q} = {q_1,...,q_l} {P} = {p_1,...,p_k}.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#a9869928c9d44c9624efd0813322282f9">More...</a><br /></td></tr>
<tr class="separator:a9869928c9d44c9624efd0813322282f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe11386ec43bee605053b5440867a51d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#afe11386ec43bee605053b5440867a51d">ScaleAndRound</a> (const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;moduliQ, const <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &amp;t, const <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &amp;tgamma, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;tgammaQHatModq, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;tgammaQHatModqPrecon, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;negInvqModtgamma, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;negInvqModtgammaPrecon) const override</td></tr>
<tr class="memdesc:afe11386ec43bee605053b5440867a51d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes scale and round for fast rounding: {X}_{Q} -&gt; {\round(t/Q * X)}_t {Q} = {q_1,...,q_l}.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#afe11386ec43bee605053b5440867a51d">More...</a><br /></td></tr>
<tr class="separator:afe11386ec43bee605053b5440867a51d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac17034a9563956a162c6d3f3c80bd4e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#aac17034a9563956a162c6d3f3c80bd4e">FastBaseConvqToBskMontgomery</a> (const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt; paramsBsk, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;moduliQ, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;moduliBsk, const std::vector&lt; DoubleNativeInt &gt; &amp;modbskBarrettMu, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;mtildeQHatInvModq, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;mtildeQHatInvModqPrecon, const std::vector&lt; std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;&gt; &amp;QHatModbsk, const std::vector&lt; uint16_t &gt; &amp;QHatModmtilde, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;QModbsk, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;QModbskPrecon, const uint16_t &amp;negQInvModmtilde, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;mtildeInvModbsk, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;mtildeInvModbskPrecon) override</td></tr>
<tr class="memdesc:aac17034a9563956a162c6d3f3c80bd4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expands basis: {X}_{Q} -&gt; {X}_{Q,Bsk,mtilde} mtilde is a redundant modulus used to remove q overflows generated from fast conversion. Outputs the resulting polynomial in CRT/RNS {Q} = {q_1,...,q_l} {Bsk} = {bsk_1,...,bsk_k}.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#aac17034a9563956a162c6d3f3c80bd4e">More...</a><br /></td></tr>
<tr class="separator:aac17034a9563956a162c6d3f3c80bd4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ebeafa37c47d074c2ed333c6ffbc960"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a7ebeafa37c47d074c2ed333c6ffbc960">FastRNSFloorq</a> (const <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &amp;t, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;moduliQ, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;moduliBsk, const std::vector&lt; DoubleNativeInt &gt; &amp;modbskBarrettMu, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;tQHatInvModq, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;tQHatInvModqPrecon, const std::vector&lt; std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;&gt; &amp;QHatModbsk, const std::vector&lt; std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;&gt; &amp;qInvModbsk, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;tQInvModbsk, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;tQInvModbskPrecon) override</td></tr>
<tr class="memdesc:a7ebeafa37c47d074c2ed333c6ffbc960"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes scale and floor: {X}_{Q,Bsk} -&gt; {\floor{t/Q * X}}_{Bsk} {Q} = {q_1,...,q_l} {Bsk} = {bsk_1,...,bsk_k} Outputs the resulting polynomial in CRT/RNS.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#a7ebeafa37c47d074c2ed333c6ffbc960">More...</a><br /></td></tr>
<tr class="separator:a7ebeafa37c47d074c2ed333c6ffbc960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a175720c325d466f6eb7505f65035b849"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a175720c325d466f6eb7505f65035b849">FastBaseConvSK</a> (const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;moduliQ, const std::vector&lt; DoubleNativeInt &gt; &amp;modqBarrettMu, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;moduliBsk, const std::vector&lt; DoubleNativeInt &gt; &amp;modbskBarrettMu, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;BHatInvModb, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;BHatInvModbPrecon, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;BHatModmsk, const <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &amp;BInvModmsk, const <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &amp;BInvModmskPrecon, const std::vector&lt; std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;&gt; &amp;BHatModq, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;BModq, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;BModqPrecon) override</td></tr>
<tr class="memdesc:a175720c325d466f6eb7505f65035b849"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts basis: {X}_{Q,Bsk} -&gt; {X}_{Bsk} {Q} = {q_1,...,q_l} {Bsk} = {bsk_1,...,bsk_k} using Shenoy Kumaresan method. Outputs the resulting polynomial in CRT/RNS.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#a175720c325d466f6eb7505f65035b849">More...</a><br /></td></tr>
<tr class="separator:a175720c325d466f6eb7505f65035b849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d3c67522ed393eb3855cd4133c552d"><td class="memItemLeft" align="right" valign="top"><a id="a28d3c67522ed393eb3855cd4133c552d"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a28d3c67522ed393eb3855cd4133c552d">SwitchFormat</a> () override</td></tr>
<tr class="memdesc:a28d3c67522ed393eb3855cd4133c552d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert from Coefficient to CRT or vice versa; calls FFT and inverse FFT. <br /></td></tr>
<tr class="separator:a28d3c67522ed393eb3855cd4133c552d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5760813c7513606ea0cf28015639297e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a5760813c7513606ea0cf28015639297e">SwitchModulus</a> (const Integer &amp;modulus, const Integer &amp;rootOfUnity, const Integer &amp;modulusArb=Integer(0), const Integer &amp;rootOfUnityArb=Integer(0)) override</td></tr>
<tr class="memdesc:a5760813c7513606ea0cf28015639297e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switch modulus and adjust the values.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#a5760813c7513606ea0cf28015639297e">More...</a><br /></td></tr>
<tr class="separator:a5760813c7513606ea0cf28015639297e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38e9a3306642a95e2a6debae131f234b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a38e9a3306642a95e2a6debae131f234b">SwitchModulusAtIndex</a> (usint index, const Integer &amp;modulus, const Integer &amp;rootOfUnity) override</td></tr>
<tr class="memdesc:a38e9a3306642a95e2a6debae131f234b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switch modulus at tower i and adjust the values.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#a38e9a3306642a95e2a6debae131f234b">More...</a><br /></td></tr>
<tr class="separator:a38e9a3306642a95e2a6debae131f234b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a344d2b7f16a8aa10a4006dfd972a78e1"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a344d2b7f16a8aa10a4006dfd972a78e1">InverseExists</a> () const override</td></tr>
<tr class="memdesc:a344d2b7f16a8aa10a4006dfd972a78e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if inverse exists.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#a344d2b7f16a8aa10a4006dfd972a78e1">More...</a><br /></td></tr>
<tr class="separator:a344d2b7f16a8aa10a4006dfd972a78e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a214892eae601551e99859e161ddc56eb"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a214892eae601551e99859e161ddc56eb">Norm</a> () const override</td></tr>
<tr class="memdesc:a214892eae601551e99859e161ddc56eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the infinity norm, basically the largest value in the ring element.  <a href="classlbcrypto_1_1DCRTPolyImpl.html#a214892eae601551e99859e161ddc56eb">More...</a><br /></td></tr>
<tr class="separator:a214892eae601551e99859e161ddc56eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f559c813c01042365be05670de883ad"><td class="memTemplParams" colspan="2"><a id="a6f559c813c01042365be05670de883ad"></a>
template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a6f559c813c01042365be05670de883ad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>save</b> (Archive &amp;ar, std::uint32_t const version) const</td></tr>
<tr class="separator:a6f559c813c01042365be05670de883ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57daa9cafda7c3abcb414df77f4a809e"><td class="memTemplParams" colspan="2"><a id="a57daa9cafda7c3abcb414df77f4a809e"></a>
template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a57daa9cafda7c3abcb414df77f4a809e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>load</b> (Archive &amp;ar, std::uint32_t const version)</td></tr>
<tr class="separator:a57daa9cafda7c3abcb414df77f4a809e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d669b41f0c70c6c6d865efe785523d5"><td class="memItemLeft" align="right" valign="top"><a id="a8d669b41f0c70c6c6d865efe785523d5"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>SerializedObjectName</b> () const override</td></tr>
<tr class="separator:a8d669b41f0c70c6c6d865efe785523d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classlbcrypto_1_1DCRTPolyInterface')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a></td></tr>
<tr class="memitem:a6cdf654d89986d28366885e364d80080 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a6cdf654d89986d28366885e364d80080">GetDerived</a> ()</td></tr>
<tr class="memdesc:a6cdf654d89986d28366885e364d80080 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Derived object, this is apart of the CRTP software design pattern it allows the base class (this one) to implement methods that call the derived objects implementation.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a6cdf654d89986d28366885e364d80080">More...</a><br /></td></tr>
<tr class="separator:a6cdf654d89986d28366885e364d80080 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d67b375b98e88fb78392f2d214d5458 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a4d67b375b98e88fb78392f2d214d5458">GetDerived</a> () const</td></tr>
<tr class="separator:a4d67b375b98e88fb78392f2d214d5458 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8aaf7680a031550d84687c9d9c0ae1a inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memItemLeft" align="right" valign="top">const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#ac8aaf7680a031550d84687c9d9c0ae1a">GetParams</a> () const</td></tr>
<tr class="memdesc:ac8aaf7680a031550d84687c9d9c0ae1a inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the parameters of the element.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#ac8aaf7680a031550d84687c9d9c0ae1a">More...</a><br /></td></tr>
<tr class="separator:ac8aaf7680a031550d84687c9d9c0ae1a inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c59a54a3117891aaf660f5d2f0bea2 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memItemLeft" align="right" valign="top">virtual usint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a40c59a54a3117891aaf660f5d2f0bea2">GetCyclotomicOrder</a> () const</td></tr>
<tr class="memdesc:a40c59a54a3117891aaf660f5d2f0bea2 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the element's cyclotomic order  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a40c59a54a3117891aaf660f5d2f0bea2">More...</a><br /></td></tr>
<tr class="separator:a40c59a54a3117891aaf660f5d2f0bea2 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20fe813cfd6a8f469a5f585d9b1adc42 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memItemLeft" align="right" valign="top">virtual usint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a20fe813cfd6a8f469a5f585d9b1adc42">GetRingDimension</a> () const</td></tr>
<tr class="memdesc:a20fe813cfd6a8f469a5f585d9b1adc42 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the element's ring dimension  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a20fe813cfd6a8f469a5f585d9b1adc42">More...</a><br /></td></tr>
<tr class="separator:a20fe813cfd6a8f469a5f585d9b1adc42 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20af925ea09544588f834f8021d68f9a inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memItemLeft" align="right" valign="top">const BigIntType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a20af925ea09544588f834f8021d68f9a">GetModulus</a> () const</td></tr>
<tr class="memdesc:a20af925ea09544588f834f8021d68f9a inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the element's modulus  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a20af925ea09544588f834f8021d68f9a">More...</a><br /></td></tr>
<tr class="separator:a20af925ea09544588f834f8021d68f9a inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a131ad02f83ced06622e6d8e00fb6c2 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memItemLeft" align="right" valign="top">const BigIntType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a5a131ad02f83ced06622e6d8e00fb6c2">GetOriginalModulus</a> () const</td></tr>
<tr class="memdesc:a5a131ad02f83ced06622e6d8e00fb6c2 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the element's original modulus, derived from Poly  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a5a131ad02f83ced06622e6d8e00fb6c2">More...</a><br /></td></tr>
<tr class="separator:a5a131ad02f83ced06622e6d8e00fb6c2 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c943dd0618aeb63c915250be84c10cd inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memItemLeft" align="right" valign="top">virtual const BigIntType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a0c943dd0618aeb63c915250be84c10cd">GetRootOfUnity</a> () const</td></tr>
<tr class="memdesc:a0c943dd0618aeb63c915250be84c10cd inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the element's root of unity.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a0c943dd0618aeb63c915250be84c10cd">More...</a><br /></td></tr>
<tr class="separator:a0c943dd0618aeb63c915250be84c10cd inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add0c94d87832fec8fa4c2c60aa1fd23e inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memItemLeft" align="right" valign="top">virtual usint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#add0c94d87832fec8fa4c2c60aa1fd23e">GetLength</a> () const</td></tr>
<tr class="memdesc:add0c94d87832fec8fa4c2c60aa1fd23e inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get method for length of each component element. NOTE assumes all components are the same size. (Ring Dimension)  <a href="classlbcrypto_1_1DCRTPolyInterface.html#add0c94d87832fec8fa4c2c60aa1fd23e">More...</a><br /></td></tr>
<tr class="separator:add0c94d87832fec8fa4c2c60aa1fd23e inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f373c9110cff8599393a6fc47390bb inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memItemLeft" align="right" valign="top">virtual usint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a66f373c9110cff8599393a6fc47390bb">GetNumOfElements</a> () const=0</td></tr>
<tr class="memdesc:a66f373c9110cff8599393a6fc47390bb inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get method of the number of component elements, also known as the number of towers.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a66f373c9110cff8599393a6fc47390bb">More...</a><br /></td></tr>
<tr class="separator:a66f373c9110cff8599393a6fc47390bb inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d5dbd1bbfb043b71fa773b9d3f7f08 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memItemLeft" align="right" valign="top">virtual const std::vector&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">TowerType</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a93d5dbd1bbfb043b71fa773b9d3f7f08">GetAllElements</a> () const=0</td></tr>
<tr class="memdesc:a93d5dbd1bbfb043b71fa773b9d3f7f08 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get method that returns a vector of all component elements.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a93d5dbd1bbfb043b71fa773b9d3f7f08">More...</a><br /></td></tr>
<tr class="separator:a93d5dbd1bbfb043b71fa773b9d3f7f08 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b5764dee7d4a77f0a8832d94ba37f5 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memItemLeft" align="right" valign="top">virtual Format&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a09b5764dee7d4a77f0a8832d94ba37f5">GetFormat</a> () const</td></tr>
<tr class="memdesc:a09b5764dee7d4a77f0a8832d94ba37f5 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get method of the format.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a09b5764dee7d4a77f0a8832d94ba37f5">More...</a><br /></td></tr>
<tr class="separator:a09b5764dee7d4a77f0a8832d94ba37f5 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98d4c5817cba2c2b2b9188c05870e39f inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a98d4c5817cba2c2b2b9188c05870e39f">operator-</a> () const=0</td></tr>
<tr class="memdesc:a98d4c5817cba2c2b2b9188c05870e39f inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary minus on a element.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a98d4c5817cba2c2b2b9188c05870e39f">More...</a><br /></td></tr>
<tr class="separator:a98d4c5817cba2c2b2b9188c05870e39f inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb429befd3061e3283b65cc0a5cadf2 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memItemLeft" align="right" valign="top"><a id="a3eb429befd3061e3283b65cc0a5cadf2"></a>
virtual const <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator+=</b> (const BigIntType &amp;element)=0</td></tr>
<tr class="separator:a3eb429befd3061e3283b65cc0a5cadf2 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae624e9a0fb904bdee4c7b536e12d6808 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#ae624e9a0fb904bdee4c7b536e12d6808">operator-=</a> (const BigIntType &amp;element)=0</td></tr>
<tr class="memdesc:ae624e9a0fb904bdee4c7b536e12d6808 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a subtraction operation and returns the result.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#ae624e9a0fb904bdee4c7b536e12d6808">More...</a><br /></td></tr>
<tr class="separator:ae624e9a0fb904bdee4c7b536e12d6808 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77fa4c8b73acda9b59dc034519d592db inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a77fa4c8b73acda9b59dc034519d592db">Transpose</a> () const</td></tr>
<tr class="memdesc:a77fa4c8b73acda9b59dc034519d592db inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose the ring element using the automorphism operation.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a77fa4c8b73acda9b59dc034519d592db">More...</a><br /></td></tr>
<tr class="separator:a77fa4c8b73acda9b59dc034519d592db inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca7c97cd5997160bf1542c7310b66a01 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#aca7c97cd5997160bf1542c7310b66a01">Plus</a> (const BigIntType &amp;element) const=0</td></tr>
<tr class="memdesc:aca7c97cd5997160bf1542c7310b66a01 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar addition - add an element to the first index of each tower.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#aca7c97cd5997160bf1542c7310b66a01">More...</a><br /></td></tr>
<tr class="separator:aca7c97cd5997160bf1542c7310b66a01 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8653434b7b187397033f19812921785 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#ad8653434b7b187397033f19812921785">Plus</a> (const vector&lt; BigIntType &gt; &amp;element) const=0</td></tr>
<tr class="memdesc:ad8653434b7b187397033f19812921785 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar addition for elements in CRT format. CRT elements are represented as vector of integer elements which correspond to the represented number modulo the primes in the tower chain (in same order).  <a href="classlbcrypto_1_1DCRTPolyInterface.html#ad8653434b7b187397033f19812921785">More...</a><br /></td></tr>
<tr class="separator:ad8653434b7b187397033f19812921785 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe20fce440768599da3a2edeb27ced9f inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#abe20fce440768599da3a2edeb27ced9f">Times</a> (const BigIntType &amp;element) const=0</td></tr>
<tr class="memdesc:abe20fce440768599da3a2edeb27ced9f inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar multiplication - multiply all entries.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#abe20fce440768599da3a2edeb27ced9f">More...</a><br /></td></tr>
<tr class="separator:abe20fce440768599da3a2edeb27ced9f inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6fd62f7cc5222c6ab8719f0d5a2c8c1 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#ad6fd62f7cc5222c6ab8719f0d5a2c8c1">Times</a> (const std::vector&lt; BigIntType &gt; &amp;element) const=0</td></tr>
<tr class="memdesc:ad6fd62f7cc5222c6ab8719f0d5a2c8c1 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar modular multiplication by an integer represented in CRT Basis.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#ad6fd62f7cc5222c6ab8719f0d5a2c8c1">More...</a><br /></td></tr>
<tr class="separator:ad6fd62f7cc5222c6ab8719f0d5a2c8c1 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dfadd41ee3fc03df8375b1548e619ec inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a1dfadd41ee3fc03df8375b1548e619ec">Minus</a> (const BigIntType &amp;element) const=0</td></tr>
<tr class="memdesc:a1dfadd41ee3fc03df8375b1548e619ec inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar subtraction - subtract an element to all entries.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a1dfadd41ee3fc03df8375b1548e619ec">More...</a><br /></td></tr>
<tr class="separator:a1dfadd41ee3fc03df8375b1548e619ec inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acebbf62af47212eb1ff94d727924ee98 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#acebbf62af47212eb1ff94d727924ee98">Minus</a> (const vector&lt; BigIntType &gt; &amp;element) const=0</td></tr>
<tr class="memdesc:acebbf62af47212eb1ff94d727924ee98 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar subtraction for elements in CRT format. CRT elements are represented as vector of integer elements which correspond to the represented number modulo the primes in the tower chain (in same order).  <a href="classlbcrypto_1_1DCRTPolyInterface.html#acebbf62af47212eb1ff94d727924ee98">More...</a><br /></td></tr>
<tr class="separator:acebbf62af47212eb1ff94d727924ee98 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c299cc747f5176cdf79912089e0238d inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a9c299cc747f5176cdf79912089e0238d">MultiplyAndRound</a> (const BigIntType &amp;p, const BigIntType &amp;q) const</td></tr>
<tr class="memdesc:a9c299cc747f5176cdf79912089e0238d inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar multiplication followed by division and rounding operation - operation on all entries.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a9c299cc747f5176cdf79912089e0238d">More...</a><br /></td></tr>
<tr class="separator:a9c299cc747f5176cdf79912089e0238d inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a509bf1d5399f63247aa1af0aa1ebd4df inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a509bf1d5399f63247aa1af0aa1ebd4df">DivideAndRound</a> (const BigIntType &amp;q) const</td></tr>
<tr class="memdesc:a509bf1d5399f63247aa1af0aa1ebd4df inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar division followed by rounding operation - operation on all entries.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a509bf1d5399f63247aa1af0aa1ebd4df">More...</a><br /></td></tr>
<tr class="separator:a509bf1d5399f63247aa1af0aa1ebd4df inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6975f0cd6039ceeb1a4ad954519954f2 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a6975f0cd6039ceeb1a4ad954519954f2">Negate</a> () const=0</td></tr>
<tr class="memdesc:a6975f0cd6039ceeb1a4ad954519954f2 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a negation operation and returns the result.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a6975f0cd6039ceeb1a4ad954519954f2">More...</a><br /></td></tr>
<tr class="separator:a6975f0cd6039ceeb1a4ad954519954f2 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a649ce1d2b14105bd41e6a33caf7912a2 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a649ce1d2b14105bd41e6a33caf7912a2">operator*=</a> (const BigIntType &amp;element)=0</td></tr>
<tr class="memdesc:a649ce1d2b14105bd41e6a33caf7912a2 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a multiplication operation and returns the result.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a649ce1d2b14105bd41e6a33caf7912a2">More...</a><br /></td></tr>
<tr class="separator:a649ce1d2b14105bd41e6a33caf7912a2 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1426c1b052a5ae4b9ccc1b0d738dec1 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#aa1426c1b052a5ae4b9ccc1b0d738dec1">MultiplicativeInverse</a> () const=0</td></tr>
<tr class="memdesc:aa1426c1b052a5ae4b9ccc1b0d738dec1 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a multiplicative inverse operation and returns the result.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#aa1426c1b052a5ae4b9ccc1b0d738dec1">More...</a><br /></td></tr>
<tr class="separator:aa1426c1b052a5ae4b9ccc1b0d738dec1 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad10296261f590b69a2efd23a6b57e698 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#ad10296261f590b69a2efd23a6b57e698">ModByTwo</a> () const</td></tr>
<tr class="memdesc:ad10296261f590b69a2efd23a6b57e698 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a modulus by 2 operation. Returns the least significant bit.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#ad10296261f590b69a2efd23a6b57e698">More...</a><br /></td></tr>
<tr class="separator:ad10296261f590b69a2efd23a6b57e698 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae234c1d7db46ab3ed963d0ef1257d39b inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#ae234c1d7db46ab3ed963d0ef1257d39b">Mod</a> (const BigIntType &amp;modulus) const</td></tr>
<tr class="memdesc:ae234c1d7db46ab3ed963d0ef1257d39b inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modulus - perform a modulus operation. Does proper mapping of [-modulus/2, modulus/2) to [0, modulus)  <a href="classlbcrypto_1_1DCRTPolyInterface.html#ae234c1d7db46ab3ed963d0ef1257d39b">More...</a><br /></td></tr>
<tr class="separator:ae234c1d7db46ab3ed963d0ef1257d39b inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af35691c5c689c9804b87ad18e08269ba inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memItemLeft" align="right" valign="top">virtual const VecType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#af35691c5c689c9804b87ad18e08269ba">GetValues</a> () const</td></tr>
<tr class="memdesc:af35691c5c689c9804b87ad18e08269ba inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get method that should not be used.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#af35691c5c689c9804b87ad18e08269ba">More...</a><br /></td></tr>
<tr class="separator:af35691c5c689c9804b87ad18e08269ba inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1288c458ea53efc64df24b1162b35ddc inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a1288c458ea53efc64df24b1162b35ddc">SetValues</a> (const VecType &amp;values, Format format)</td></tr>
<tr class="memdesc:a1288c458ea53efc64df24b1162b35ddc inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set method that should not be used, will throw an error.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a1288c458ea53efc64df24b1162b35ddc">More...</a><br /></td></tr>
<tr class="separator:a1288c458ea53efc64df24b1162b35ddc inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec031b96c902996ebb986097e7919442 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#aec031b96c902996ebb986097e7919442">AddRandomNoise</a> (const BigIntType &amp;modulus) const</td></tr>
<tr class="memdesc:aec031b96c902996ebb986097e7919442 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add uniformly random values to all components except for the first one.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#aec031b96c902996ebb986097e7919442">More...</a><br /></td></tr>
<tr class="separator:aec031b96c902996ebb986097e7919442 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a278d9399c70da14dd2984df93749d881 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a278d9399c70da14dd2984df93749d881">IsEmpty</a> () const=0</td></tr>
<tr class="memdesc:a278d9399c70da14dd2984df93749d881 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if ALL the tower(s) are empty.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a278d9399c70da14dd2984df93749d881">More...</a><br /></td></tr>
<tr class="separator:a278d9399c70da14dd2984df93749d881 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a498cdac8c2f3f8dbbe9fccc9b8d5de87 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyLargeType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a498cdac8c2f3f8dbbe9fccc9b8d5de87">CRTInterpolate</a> () const=0</td></tr>
<tr class="memdesc:a498cdac8c2f3f8dbbe9fccc9b8d5de87 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolates the DCRTPoly to an Poly based on the Chinese Remainder Transform Interpolation. and then returns a Poly with that single element.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a498cdac8c2f3f8dbbe9fccc9b8d5de87">More...</a><br /></td></tr>
<tr class="separator:a498cdac8c2f3f8dbbe9fccc9b8d5de87 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d2b7e3f78ba01d71c1ea9425ea908f9 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1PolyImpl.html">TowerType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a0d2b7e3f78ba01d71c1ea9425ea908f9">ToNativePoly</a> () const=0</td></tr>
<tr class="memdesc:a0d2b7e3f78ba01d71c1ea9425ea908f9 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the values are small enough this is used for efficiency.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a0d2b7e3f78ba01d71c1ea9425ea908f9">More...</a><br /></td></tr>
<tr class="separator:a0d2b7e3f78ba01d71c1ea9425ea908f9 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb38c09cf2d6bc44acce65cd6d3cc064 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memItemLeft" align="right" valign="top">virtual BigIntType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#abb38c09cf2d6bc44acce65cd6d3cc064">GetWorkingModulus</a> () const=0</td></tr>
<tr class="memdesc:abb38c09cf2d6bc44acce65cd6d3cc064 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and returns the product of primes in the current moduli chain. Compared to GetModulus, which always returns the product of all primes in the crypto parameters, this method will return a different modulus, based on the towers/moduli that are currently in the chain (some towers are dropped along the way).  <a href="classlbcrypto_1_1DCRTPolyInterface.html#abb38c09cf2d6bc44acce65cd6d3cc064">More...</a><br /></td></tr>
<tr class="separator:abb38c09cf2d6bc44acce65cd6d3cc064 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5154189bc463d2babe5f6128b09b85d inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memItemLeft" align="right" valign="top">virtual shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#ae5154189bc463d2babe5f6128b09b85d">GetExtendedCRTBasis</a> (std::shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt; paramsP) const=0</td></tr>
<tr class="memdesc:ae5154189bc463d2babe5f6128b09b85d inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the element parameters for DCRTPoly elements in an extended CRT basis, which is the concatenation of the towers currently in "this" DCRTPoly, and the moduli in ParamsP.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#ae5154189bc463d2babe5f6128b09b85d">More...</a><br /></td></tr>
<tr class="separator:ae5154189bc463d2babe5f6128b09b85d inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac03b0bd8ca326b7936dc04122b31c6df inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#ac03b0bd8ca326b7936dc04122b31c6df">ApproxSwitchCRTBasis</a> (const std::shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt; paramsQ, const std::shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt; paramsP, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;QHatInvModq, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;QHatInvModqPrecon, const std::vector&lt; std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;&gt; &amp;QHatModp, const std::vector&lt; DoubleNativeInt &gt; &amp;modpBarrettMu) const=0</td></tr>
<tr class="memdesc:ac03b0bd8ca326b7936dc04122b31c6df inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs approximate CRT basis switching: {X}_{Q} -&gt; {X'}_{P} X' = X + alpha*Q for small alpha {Q} = {q_1,...,q_l} {P} = {p_1,...,p_k}.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#ac03b0bd8ca326b7936dc04122b31c6df">More...</a><br /></td></tr>
<tr class="separator:ac03b0bd8ca326b7936dc04122b31c6df inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a562cc4ae452f8a957ce7cb6fab67904e inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a562cc4ae452f8a957ce7cb6fab67904e">ApproxModUp</a> (const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt; paramsQ, const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt; paramsP, const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt; paramsQP, const vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;QHatInvModq, const vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;QHatInvModqPrecon, const vector&lt; vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;&gt; &amp;QHatModp, const vector&lt; DoubleNativeInt &gt; &amp;modpBarrettMu)=0</td></tr>
<tr class="memdesc:a562cc4ae452f8a957ce7cb6fab67904e inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs approximate modulus raising: {X}_{Q} -&gt; {X'}_{Q,P}. X' = X + alpha*Q for small alpha {Q} = {q_1,...,q_l} {P} = {p_1,...,p_k}.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a562cc4ae452f8a957ce7cb6fab67904e">More...</a><br /></td></tr>
<tr class="separator:a562cc4ae452f8a957ce7cb6fab67904e inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af143d9876962db6a0ec4cfba0362c16e inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#af143d9876962db6a0ec4cfba0362c16e">ApproxModDown</a> (const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt; paramsQ, const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt; paramsP, const vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;PInvModq, const vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;PInvModqPrecon, const vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;PHatInvModp, const vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;PHatInvModpPrecon, const vector&lt; vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;&gt; &amp;PHatModq, const vector&lt; DoubleNativeInt &gt; &amp;modqBarrettMu, const vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;tInvModp, const vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;tInvModpPrecon, const <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &amp;t, const vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;tModqPrecon) const=0</td></tr>
<tr class="memdesc:af143d9876962db6a0ec4cfba0362c16e inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs approximate modulus reduction: {X}_{Q,P} -&gt; {\approx(X/P)}_{Q}. {Q} = {q_1,...,q_l} {P} = {p_1,...,p_k}.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#af143d9876962db6a0ec4cfba0362c16e">More...</a><br /></td></tr>
<tr class="separator:af143d9876962db6a0ec4cfba0362c16e inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e3f3fcb29277339a655424ce674a60c inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a0e3f3fcb29277339a655424ce674a60c">SwitchCRTBasis</a> (const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt; paramsP, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;QHatInvModq, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;QHatInvModqPrecon, const std::vector&lt; std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;&gt; &amp;QHatModp, const std::vector&lt; std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;&gt; &amp;alphaQModp, const std::vector&lt; DoubleNativeInt &gt; &amp;modpBarrettMu, const std::vector&lt; double &gt; &amp;qInv) const=0</td></tr>
<tr class="memdesc:a0e3f3fcb29277339a655424ce674a60c inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs CRT basis switching: {X}_{Q} -&gt; {X}_{P} {Q} = {q_1,...,q_l} {P} = {p_1,...,p_k}.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a0e3f3fcb29277339a655424ce674a60c">More...</a><br /></td></tr>
<tr class="separator:a0e3f3fcb29277339a655424ce674a60c inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f9144151b30ee7218e8d855930d640 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a41f9144151b30ee7218e8d855930d640">ExpandCRTBasis</a> (const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt; paramsQP, const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt; paramsP, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;QHatInvModq, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;QHatInvModqPrecon, const std::vector&lt; std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;&gt; &amp;QHatModp, const std::vector&lt; std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;&gt; &amp;alphaQModp, const std::vector&lt; DoubleNativeInt &gt; &amp;modpBarrettMu, const std::vector&lt; double &gt; &amp;qInv, Format resultFormat)=0</td></tr>
<tr class="memdesc:a41f9144151b30ee7218e8d855930d640 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs modulus raising: {X}_{Q} -&gt; {X}_{Q,P} {Q} = {q_1,...,q_l} {P} = {p_1,...,p_k}.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a41f9144151b30ee7218e8d855930d640">More...</a><br /></td></tr>
<tr class="separator:a41f9144151b30ee7218e8d855930d640 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbe955b6be2cf993ee95a7ced916a2eb inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#afbe955b6be2cf993ee95a7ced916a2eb">ScaleAndRound</a> (const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt; paramsP, const std::vector&lt; std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;&gt; &amp;tPSHatInvModsDivsModp, const std::vector&lt; double &gt; &amp;tPSHatInvModsDivsFrac, const std::vector&lt; DoubleNativeInt &gt; &amp;modpBarretMu) const=0</td></tr>
<tr class="memdesc:afbe955b6be2cf993ee95a7ced916a2eb inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes scale and round: {X}_{Q,P} -&gt; {t/Q * X}_{P} {Q} = {q_1,...,q_l} {P} = {p_1,...,p_k}.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#afbe955b6be2cf993ee95a7ced916a2eb">More...</a><br /></td></tr>
<tr class="separator:afbe955b6be2cf993ee95a7ced916a2eb inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca90f477f7a3ebdd52dcacbb49f7f74 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a7ca90f477f7a3ebdd52dcacbb49f7f74">ApproxScaleAndRound</a> (const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt; paramsP, const std::vector&lt; std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;&gt; &amp;tPSHatInvModsDivsModp, const std::vector&lt; DoubleNativeInt &gt; &amp;modpBarretMu) const=0</td></tr>
<tr class="memdesc:a7ca90f477f7a3ebdd52dcacbb49f7f74 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes approximate scale and round: {X}_{Q,P} -&gt; {\approx{t/Q * X}}_{P} {Q} = {q_1,...,q_l} {P} = {p_1,...,p_k}.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a7ca90f477f7a3ebdd52dcacbb49f7f74">More...</a><br /></td></tr>
<tr class="separator:a7ca90f477f7a3ebdd52dcacbb49f7f74 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eca50ec338533d004b18584cd6ab157 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a8eca50ec338533d004b18584cd6ab157">FastBaseConvqToBskMontgomery</a> (const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt; paramsBsk, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;moduliQ, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;moduliBsk, const std::vector&lt; DoubleNativeInt &gt; &amp;modbskBarrettMu, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;mtildeQHatInvModq, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;mtildeQHatInvModqPrecon, const std::vector&lt; std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;&gt; &amp;QHatModbsk, const std::vector&lt; uint16_t &gt; &amp;QHatModmtilde, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;QModbsk, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;QModbskPrecon, const uint16_t &amp;negQInvModmtilde, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;mtildeInvModbsk, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;mtildeInvModbskPrecon)=0</td></tr>
<tr class="memdesc:a8eca50ec338533d004b18584cd6ab157 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expands basis: {X}_{Q} -&gt; {X}_{Q,Bsk,mtilde} mtilde is a redundant modulus used to remove q overflows generated from fast conversion. Outputs the resulting polynomial in CRT/RNS {Q} = {q_1,...,q_l} {Bsk} = {bsk_1,...,bsk_k}.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a8eca50ec338533d004b18584cd6ab157">More...</a><br /></td></tr>
<tr class="separator:a8eca50ec338533d004b18584cd6ab157 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c38037e64d065fd8240883700f25764 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a0c38037e64d065fd8240883700f25764">SwitchModulus</a> (const BigIntType &amp;modulus, const BigIntType &amp;rootOfUnity, const BigIntType &amp;modulusArb, const BigIntType &amp;rootOfUnityArb)</td></tr>
<tr class="memdesc:a0c38037e64d065fd8240883700f25764 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switch modulus and adjust the values.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a0c38037e64d065fd8240883700f25764">More...</a><br /></td></tr>
<tr class="separator:a0c38037e64d065fd8240883700f25764 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5756e146673e846bc8ebaf4e3139472 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#ae5756e146673e846bc8ebaf4e3139472">SwitchModulusAtIndex</a> (usint index, const BigIntType &amp;modulus, const BigIntType &amp;rootOfUnity)=0</td></tr>
<tr class="memdesc:ae5756e146673e846bc8ebaf4e3139472 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switch modulus at tower i and adjust the values.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#ae5756e146673e846bc8ebaf4e3139472">More...</a><br /></td></tr>
<tr class="separator:ae5756e146673e846bc8ebaf4e3139472 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d84bf03f20db3d0b46a40efb7d9f746 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a6d84bf03f20db3d0b46a40efb7d9f746">InverseExists</a> () const=0</td></tr>
<tr class="memdesc:a6d84bf03f20db3d0b46a40efb7d9f746 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if inverse exists.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a6d84bf03f20db3d0b46a40efb7d9f746">More...</a><br /></td></tr>
<tr class="separator:a6d84bf03f20db3d0b46a40efb7d9f746 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dce2c859629115a2453bb8726e8e137 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a4dce2c859629115a2453bb8726e8e137">Norm</a> () const=0</td></tr>
<tr class="memdesc:a4dce2c859629115a2453bb8726e8e137 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the infinity norm, basically the largest value in the ring element.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a4dce2c859629115a2453bb8726e8e137">More...</a><br /></td></tr>
<tr class="separator:a4dce2c859629115a2453bb8726e8e137 inherit pub_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classlbcrypto_1_1ILElement"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classlbcrypto_1_1ILElement')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classlbcrypto_1_1ILElement.html">lbcrypto::ILElement&lt; DCRTPolyImpl&lt; VecType &gt;, VecType &gt;</a></td></tr>
<tr class="memitem:a70b85d0a6aea66ace2c983618ac8a489 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#a70b85d0a6aea66ace2c983618ac8a489">Clone</a> () const=0</td></tr>
<tr class="memdesc:a70b85d0a6aea66ace2c983618ac8a489 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone the object by making a copy of it and returning the copy.  <a href="classlbcrypto_1_1ILElement.html#a70b85d0a6aea66ace2c983618ac8a489">More...</a><br /></td></tr>
<tr class="separator:a70b85d0a6aea66ace2c983618ac8a489 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a6b897331d1265eb815e6d50d295037 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#a0a6b897331d1265eb815e6d50d295037">CloneEmpty</a> () const=0</td></tr>
<tr class="memdesc:a0a6b897331d1265eb815e6d50d295037 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone the object, but have it contain nothing.  <a href="classlbcrypto_1_1ILElement.html#a0a6b897331d1265eb815e6d50d295037">More...</a><br /></td></tr>
<tr class="separator:a0a6b897331d1265eb815e6d50d295037 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a7aeb078733436bf1071b5127f79a7 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#a77a7aeb078733436bf1071b5127f79a7">CloneParametersOnly</a> () const=0</td></tr>
<tr class="memdesc:a77a7aeb078733436bf1071b5127f79a7 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clones the element's parameters, leaves vector initialized to 0.  <a href="classlbcrypto_1_1ILElement.html#a77a7aeb078733436bf1071b5127f79a7">More...</a><br /></td></tr>
<tr class="separator:a77a7aeb078733436bf1071b5127f79a7 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1538c0112d2d4dfba9eec22118b22cc inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memItemLeft" align="right" valign="top"><a id="aa1538c0112d2d4dfba9eec22118b22cc"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#aa1538c0112d2d4dfba9eec22118b22cc">~ILElement</a> ()</td></tr>
<tr class="memdesc:aa1538c0112d2d4dfba9eec22118b22cc inherit pub_methods_classlbcrypto_1_1ILElement"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard destructor. <br /></td></tr>
<tr class="separator:aa1538c0112d2d4dfba9eec22118b22cc inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac59b8d3af7b29f7225ee37dc83214e79 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#ac59b8d3af7b29f7225ee37dc83214e79">operator!=</a> (const <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt; &amp;element) const</td></tr>
<tr class="memdesc:ac59b8d3af7b29f7225ee37dc83214e79 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator. Compares values of element to be compared to.  <a href="classlbcrypto_1_1ILElement.html#ac59b8d3af7b29f7225ee37dc83214e79">More...</a><br /></td></tr>
<tr class="separator:ac59b8d3af7b29f7225ee37dc83214e79 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad335f96c10a85a9c1c969bd8366123 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#a7ad335f96c10a85a9c1c969bd8366123">DivideAndRound</a> (const IntType &amp;q) const=0</td></tr>
<tr class="memdesc:a7ad335f96c10a85a9c1c969bd8366123 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar division followed by rounding operation - operation on all entries.  <a href="classlbcrypto_1_1ILElement.html#a7ad335f96c10a85a9c1c969bd8366123">More...</a><br /></td></tr>
<tr class="separator:a7ad335f96c10a85a9c1c969bd8366123 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ae88a999b925e069bfb4d92c68bfd6 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#a40ae88a999b925e069bfb4d92c68bfd6">MultiplyAndRound</a> (const IntType &amp;p, const IntType &amp;q) const=0</td></tr>
<tr class="memdesc:a40ae88a999b925e069bfb4d92c68bfd6 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar multiplication followed by division and rounding operation - operation on all entries.  <a href="classlbcrypto_1_1ILElement.html#a40ae88a999b925e069bfb4d92c68bfd6">More...</a><br /></td></tr>
<tr class="separator:a40ae88a999b925e069bfb4d92c68bfd6 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a344cbaf3a5cb2119a728d5588446cf5c inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#a344cbaf3a5cb2119a728d5588446cf5c">Mod</a> (const IntType &amp;modulus) const=0</td></tr>
<tr class="memdesc:a344cbaf3a5cb2119a728d5588446cf5c inherit pub_methods_classlbcrypto_1_1ILElement"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mod - perform a modulus operation. Does proper mapping of [-modulus/2, modulus/2) to [0, modulus).  <a href="classlbcrypto_1_1ILElement.html#a344cbaf3a5cb2119a728d5588446cf5c">More...</a><br /></td></tr>
<tr class="separator:a344cbaf3a5cb2119a728d5588446cf5c inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e39b2a1a1ef24df9de8974acad76c43 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#a4e39b2a1a1ef24df9de8974acad76c43">SetFormat</a> (const Format format)</td></tr>
<tr class="memdesc:a4e39b2a1a1ef24df9de8974acad76c43 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the format/representation of the element.  <a href="classlbcrypto_1_1ILElement.html#a4e39b2a1a1ef24df9de8974acad76c43">More...</a><br /></td></tr>
<tr class="separator:a4e39b2a1a1ef24df9de8974acad76c43 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ac8abc06c60939774e8f69e0d20e50d85"><td class="memItemLeft" align="right" valign="top"><a id="ac8abc06c60939774e8f69e0d20e50d85"></a>
static const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>GetElementName</b> ()</td></tr>
<tr class="separator:ac8abc06c60939774e8f69e0d20e50d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2ae9129d3670d5e19ce32739f7593bd"><td class="memItemLeft" align="right" valign="top"><a id="ab2ae9129d3670d5e19ce32739f7593bd"></a>
static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>SerializedVersion</b> ()</td></tr>
<tr class="separator:ab2ae9129d3670d5e19ce32739f7593bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classlbcrypto_1_1DCRTPolyInterface"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classlbcrypto_1_1DCRTPolyInterface')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a></td></tr>
<tr class="memitem:a707b00f0957b9401a58e4f143bf7cb34 inherit pub_static_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memItemLeft" align="right" valign="top">static function&lt; <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt;()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a707b00f0957b9401a58e4f143bf7cb34">Allocator</a> (const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt; params, Format format)</td></tr>
<tr class="memdesc:a707b00f0957b9401a58e4f143bf7cb34 inherit pub_static_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create lambda that allocates a zeroed element for the case when it is called from a templated class.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a707b00f0957b9401a58e4f143bf7cb34">More...</a><br /></td></tr>
<tr class="separator:a707b00f0957b9401a58e4f143bf7cb34 inherit pub_static_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae22cd32bfb9e99d19fa87cba5c4c9c2b inherit pub_static_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memItemLeft" align="right" valign="top">static function&lt; <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt;()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#ae22cd32bfb9e99d19fa87cba5c4c9c2b">MakeDiscreteGaussianCoefficientAllocator</a> (shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt; params, Format resultFormat, double stddev)</td></tr>
<tr class="memdesc:ae22cd32bfb9e99d19fa87cba5c4c9c2b inherit pub_static_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classAllocator.html">Allocator</a> for discrete uniform distribution.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#ae22cd32bfb9e99d19fa87cba5c4c9c2b">More...</a><br /></td></tr>
<tr class="separator:ae22cd32bfb9e99d19fa87cba5c4c9c2b inherit pub_static_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b2b29ed26d54b371f8bbe545292cd90 inherit pub_static_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memItemLeft" align="right" valign="top">static function&lt; <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt;()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a4b2b29ed26d54b371f8bbe545292cd90">MakeDiscreteUniformAllocator</a> (shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt; params, Format format)</td></tr>
<tr class="memdesc:a4b2b29ed26d54b371f8bbe545292cd90 inherit pub_static_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classAllocator.html">Allocator</a> for discrete uniform distribution.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a4b2b29ed26d54b371f8bbe545292cd90">More...</a><br /></td></tr>
<tr class="separator:a4b2b29ed26d54b371f8bbe545292cd90 inherit pub_static_methods_classlbcrypto_1_1DCRTPolyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ad9a2e13ad0af59b1ef7d8384e11d63ce"><td class="memItemLeft" align="right" valign="top"><a id="ad9a2e13ad0af59b1ef7d8384e11d63ce"></a>
std::vector&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_vectors</b></td></tr>
<tr class="separator:ad9a2e13ad0af59b1ef7d8384e11d63ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classlbcrypto_1_1DCRTPolyInterface"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classlbcrypto_1_1DCRTPolyInterface')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a></td></tr>
<tr class="memitem:a320385e8cacd3ad54e5efce7da035326 inherit pro_attribs_classlbcrypto_1_1DCRTPolyInterface"><td class="memItemLeft" align="right" valign="top"><a id="a320385e8cacd3ad54e5efce7da035326"></a>
shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_params</b></td></tr>
<tr class="separator:a320385e8cacd3ad54e5efce7da035326 inherit pro_attribs_classlbcrypto_1_1DCRTPolyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e83ca2233fb4f86c81f81bd0ef7bf3 inherit pro_attribs_classlbcrypto_1_1DCRTPolyInterface"><td class="memItemLeft" align="right" valign="top"><a id="a63e83ca2233fb4f86c81f81bd0ef7bf3"></a>
Format&#160;</td><td class="memItemRight" valign="bottom"><b>m_format</b></td></tr>
<tr class="separator:a63e83ca2233fb4f86c81f81bd0ef7bf3 inherit pro_attribs_classlbcrypto_1_1DCRTPolyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename VecType&gt;<br />
class lbcrypto::DCRTPolyImpl&lt; VecType &gt;</h3>

<p>Ideal lattice for the double-CRT representation. The implementation contains a vector of underlying native-integer lattices The double-CRT representation of polynomials is a common optimization for lattice encryption operations. Basically, it allows large-modulus polynomials to be represented as multiple smaller-modulus polynomials. The double-CRT representations are discussed theoretically here: </p>
<ul>
<li>Gentry C., Halevi S., Smart N.P. (2012) Homomorphic Evaluation of the AES Circuit. In: Safavi-Naini R., Canetti R. (eds) Advances in Cryptology – CRYPTO 2012. Lecture Notes in Computer Science, vol 7417. Springer, Berlin, Heidelberg </li>
</ul>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="add4d65132a6acb62c693c04feab9daba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add4d65132a6acb62c693c04feab9daba">&#9670;&nbsp;</a></span>DCRTPolyImpl() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::<a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a> </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Format&#160;</td>
          <td class="paramname"><em>format</em> = <code>EVALUATION</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>initializeElementToZero</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor that initializes parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>parameter set required for DCRTPoly. </td></tr>
    <tr><td class="paramname">format</td><td>the input format fixed to EVALUATION. Format is a enum type that indicates if the polynomial is in Evaluation representation or Coefficient representation. It is defined in <a class="el" href="inttypes_8h_source.html">inttypes.h</a>. </td></tr>
    <tr><td class="paramname">initializeElementToZero</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afb81b8f38fa7176e7748cce5ed23f800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb81b8f38fa7176e7748cce5ed23f800">&#9670;&nbsp;</a></span>DCRTPolyImpl() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::<a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a> </td>
          <td>(</td>
          <td class="paramtype">const DggType &amp;&#160;</td>
          <td class="paramname"><em>dgg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Format&#160;</td>
          <td class="paramname"><em>format</em> = <code>EVALUATION</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor based on discrete Gaussian generator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;dgg</td><td>the input discrete Gaussian generator. The dgg will be the seed to populate the towers of the DCRTPoly with random numbers. </td></tr>
    <tr><td class="paramname">params</td><td>parameter set required for DCRTPoly. </td></tr>
    <tr><td class="paramname">format</td><td>the input format fixed to EVALUATION. Format is a enum type that indicates if the polynomial is in Evaluation representation or Coefficient representation. It is defined in <a class="el" href="inttypes_8h_source.html">inttypes.h</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a05dc5796dac3425cf2d69052d878a118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05dc5796dac3425cf2d69052d878a118">&#9670;&nbsp;</a></span>DCRTPolyImpl() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::<a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a> </td>
          <td>(</td>
          <td class="paramtype">const BugType &amp;&#160;</td>
          <td class="paramname"><em>bug</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Format&#160;</td>
          <td class="paramname"><em>format</em> = <code>EVALUATION</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor based on binary distribution generator. This is not implemented. Will throw an error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;bug</td><td>the input binary uniform generator. The bug will be the seed to populate the towers of the DCRTPoly with random numbers. </td></tr>
    <tr><td class="paramname">params</td><td>parameter set required for DCRTPoly. </td></tr>
    <tr><td class="paramname">format</td><td>the input format fixed to EVALUATION. Format is a enum type that indicates if the polynomial is in Evaluation representation or Coefficient representation. It is defined in <a class="el" href="inttypes_8h_source.html">inttypes.h</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab5680d4bac624abac0bd4fa01fc92d28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5680d4bac624abac0bd4fa01fc92d28">&#9670;&nbsp;</a></span>DCRTPolyImpl() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::<a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a> </td>
          <td>(</td>
          <td class="paramtype">const TugType &amp;&#160;</td>
          <td class="paramname"><em>tug</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Format&#160;</td>
          <td class="paramname"><em>format</em> = <code>EVALUATION</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>h</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor based on ternary distribution generator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;tug</td><td>the input ternary uniform generator. The bug will be the seed to populate the towers of the DCRTPoly with random numbers. </td></tr>
    <tr><td class="paramname">params</td><td>parameter set required for DCRTPoly. </td></tr>
    <tr><td class="paramname">format</td><td>the input format fixed to EVALUATION. Format is a enum type that indicates if the polynomial is in Evaluation representation or Coefficient representation. It is defined in <a class="el" href="inttypes_8h_source.html">inttypes.h</a>. </td></tr>
    <tr><td class="paramname">h</td><td>- Hamming weight for sparse ternary distribution (by default, when h = 0, the distribution is NOT sparse) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f8f7f7a99b19297e4c62b91854bd6c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f8f7f7a99b19297e4c62b91854bd6c5">&#9670;&nbsp;</a></span>DCRTPolyImpl() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::<a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a> </td>
          <td>(</td>
          <td class="paramtype">DugType &amp;&#160;</td>
          <td class="paramname"><em>dug</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Format&#160;</td>
          <td class="paramname"><em>format</em> = <code>EVALUATION</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor based on discrete uniform generator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;dug</td><td>the input discrete Uniform Generator. </td></tr>
    <tr><td class="paramname">params</td><td>the input params. </td></tr>
    <tr><td class="paramname">&amp;format</td><td>the input format fixed to EVALUATION. Format is a enum type that indicates if the polynomial is in Evaluation representation or Coefficient representation. It is defined in <a class="el" href="inttypes_8h_source.html">inttypes.h</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b75d1bd3d12a62767dd859d6e3862fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b75d1bd3d12a62767dd859d6e3862fb">&#9670;&nbsp;</a></span>DCRTPolyImpl() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::<a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyLargeType</a> &amp;&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt;&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct using a single Poly. The Poly is copied into every tower. Each tower will be reduced to it's corresponding modulus via GetModuli(at tower index). The format is derived from the passed in Poly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;element</td><td>Poly to build other towers from. </td></tr>
    <tr><td class="paramname">params</td><td>parameter set required for DCRTPoly. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae944168601d7fcda3791a1c10aee559d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae944168601d7fcda3791a1c10aee559d">&#9670;&nbsp;</a></span>DCRTPolyImpl() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::<a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyType</a> &amp;&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt;&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct using a single PolyType. The PolyType is copied into every tower. Each tower will be reduced to it's corresponding modulus via GetModuli(at tower index). The format is derived from the passed in PolyType. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;element</td><td>Poly to build other towers from. </td></tr>
    <tr><td class="paramname">params</td><td>parameter set required for DCRTPoly. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a88a11d784c029c0ce3c1a0953721d488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88a11d784c029c0ce3c1a0953721d488">&#9670;&nbsp;</a></span>DCRTPolyImpl() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::<a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>elements</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct using an tower of ILVectro2ns. The params and format for the DCRTPoly will be derived from the towers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;towers</td><td>vector of Polys which correspond to each tower of DCRTPoly. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac19166c5d8d28697457b50309e314159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac19166c5d8d28697457b50309e314159">&#9670;&nbsp;</a></span>DCRTPolyImpl() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::<a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a> &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;element</td><td>DCRTPoly to copy from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4d760fe59b028b74c26f230c85ae77cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d760fe59b028b74c26f230c85ae77cc">&#9670;&nbsp;</a></span>DCRTPolyImpl() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::<a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;&amp;element</td><td>DCRTPoly to move from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac1f6322433bd3e832bd1405435bcc1fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1f6322433bd3e832bd1405435bcc1fd">&#9670;&nbsp;</a></span>ApproxModDown()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt; <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::ApproxModDown </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt;&#160;</td>
          <td class="paramname"><em>paramsQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt;&#160;</td>
          <td class="paramname"><em>paramsP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>PInvModq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>PInvModqPrecon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>PHatInvModp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>PHatInvModpPrecon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>PHatModq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; DoubleNativeInt &gt; &amp;&#160;</td>
          <td class="paramname"><em>modqBarrettMu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tInvModp</em> = <code>vector&lt;<a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a>&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tInvModpPrecon</em> = <code>vector&lt;<a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a>&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tModqPrecon</em> = <code>vector&lt;<a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs approximate modulus reduction: {X}_{Q,P} -&gt; {\approx(X/P)}_{Q}. {Q} = {q_1,...,q_l} {P} = {p_1,...,p_k}. </p>
<p>Brief algorithm: 1) use <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a14326698ef430e239dba7f45ccf3d6f6" title="Performs approximate CRT basis switching: {X}_{Q} -&gt; {X&#39;}_{P} X&#39; = X + alpha*Q for small alpha {Q} = ...">DCRTPoly::ApproxSwitchCRTBasis</a> : {X}_{P} -&gt; {X'}_{Q} 2) compute : {(X-X') * P^{-1}}_{Q}</p>
<p>Source: "A full RNS variant of approximate homomorphic encryption" by Cheon, et. al.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;paramsQ</td><td>parameters for the CRT basis {q_1,...,q_l} </td></tr>
    <tr><td class="paramname">&amp;paramsP</td><td>parameters for the CRT basis {p_1,...,p_k} </td></tr>
    <tr><td class="paramname">&amp;PInvModq</td><td>precomputed values for (P^{-1} mod q_j) </td></tr>
    <tr><td class="paramname">&amp;PInvModqPrecon</td><td>NTL-specific precomputations </td></tr>
    <tr><td class="paramname">&amp;PHatInvModp</td><td>precomputed values for [(P/p_j)^{-1}]_{p_j} </td></tr>
    <tr><td class="paramname">&amp;PHatInvModpPrecon</td><td>NTL-specific precomputations </td></tr>
    <tr><td class="paramname">&amp;PHatModq</td><td>precomputed values for [P/p_j]_{q_i} </td></tr>
    <tr><td class="paramname">&amp;modqBarrettMu</td><td>128-bit Barrett reduction precomputed values for q_i </td></tr>
    <tr><td class="paramname">&amp;tInvModp</td><td>precomputed values for [t^{-1}]_{p_j} used in BGVrns </td></tr>
    <tr><td class="paramname">t</td><td>often corresponds to the plaintext modulus used in BGVrns </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the representation of {\approx(X/P)}_{Q} </dd></dl>

</div>
</div>
<a id="a69e00186798396fd951b0ed45ce73dba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69e00186798396fd951b0ed45ce73dba">&#9670;&nbsp;</a></span>ApproxModUp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::ApproxModUp </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt;&#160;</td>
          <td class="paramname"><em>paramsQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt;&#160;</td>
          <td class="paramname"><em>paramsP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt;&#160;</td>
          <td class="paramname"><em>paramsQP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>QHatInvModq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>QHatInvModqPrecon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>QHatModp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; DoubleNativeInt &gt; &amp;&#160;</td>
          <td class="paramname"><em>modpBarrettMu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs approximate modulus raising: {X}_{Q} -&gt; {X'}_{Q,P}. X' = X + alpha*Q for small alpha {Q} = {q_1,...,q_l} {P} = {p_1,...,p_k}. </p>
<p>Brief algorithm: {X}_{Q} -&gt; {X'}_Q : trivial {X}_{Q} -&gt; {X'}_P : use <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a14326698ef430e239dba7f45ccf3d6f6" title="Performs approximate CRT basis switching: {X}_{Q} -&gt; {X&#39;}_{P} X&#39; = X + alpha*Q for small alpha {Q} = ...">DCRTPoly::ApproxSwitchCRTBasis</a></p>
<p>Source: "A full RNS variant of approximate homomorphic encryption" by Cheon, et. al.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;paramsQ</td><td>parameters for the CRT basis {q_1,...,q_l} </td></tr>
    <tr><td class="paramname">&amp;paramsP</td><td>parameters for the CRT basis {p_1,...,p_k} </td></tr>
    <tr><td class="paramname">&amp;QHatInvModq</td><td>precomputed values for [(Q/q_i)^{-1}]_{q_i} </td></tr>
    <tr><td class="paramname">&amp;QHatInvModqPrecon</td><td>NTL-specific precomputations </td></tr>
    <tr><td class="paramname">&amp;QHatModp</td><td>precomputed values for [Q/q_i]_{p_j} </td></tr>
    <tr><td class="paramname">&amp;modpBarrettMu</td><td>128-bit Barrett reduction precomputed values for p_j </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the representation of {X + alpha*Q} in basis {Q,P}. </dd></dl>

</div>
</div>
<a id="ada478575a2529b4106ee5ce77d59ad8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada478575a2529b4106ee5ce77d59ad8a">&#9670;&nbsp;</a></span>ApproxScaleAndRound()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt; <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::ApproxScaleAndRound </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt;&#160;</td>
          <td class="paramname"><em>paramsP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>tPSHatInvModsDivsModp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; DoubleNativeInt &gt; &amp;&#160;</td>
          <td class="paramname"><em>modpBarretMu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes approximate scale and round: {X}_{Q,P} -&gt; {\approx{t/Q * X}}_{P} {Q} = {q_1,...,q_l} {P} = {p_1,...,p_k}. </p>
<p>Brief algorithm: Let S = {Q,P} 1) [\sum_k x_k * alpha_k]_{p_j} 2) alpha_k = [Floor[t*P*[[SHatInv_k]_{s_k}/s_k]]_{p_j}</p>
<p>Source: Halevi S., Polyakov Y., and Shoup V. An Improved RNS Variant of the BFV Homomorphic Encryption Scheme. Cryptology ePrint Archive, Report 2018/117. (<a href="https://eprint.iacr.org/2018/117">https://eprint.iacr.org/2018/117</a>)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;paramsP</td><td>parameters for the CRT basis {p_1,...,p_k} </td></tr>
    <tr><td class="paramname">&amp;tPSHatInvModsDivsModp</td><td>precomputed values for [\floor[t*P*[[SHatInv_k]_{s_k}/s_k]]_{p_j} </td></tr>
    <tr><td class="paramname">&amp;modpBarretMu</td><td>128-bit Barrett reduction precomputed values for p_j </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result {\approx{t/Q * X}}_{P} </dd></dl>

</div>
</div>
<a id="a14326698ef430e239dba7f45ccf3d6f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14326698ef430e239dba7f45ccf3d6f6">&#9670;&nbsp;</a></span>ApproxSwitchCRTBasis()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt; <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::ApproxSwitchCRTBasis </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt;&#160;</td>
          <td class="paramname"><em>paramsQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt;&#160;</td>
          <td class="paramname"><em>paramsP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>QHatInvModq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>QHatInvModqPrecon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>QHatModp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; DoubleNativeInt &gt; &amp;&#160;</td>
          <td class="paramname"><em>modpBarrettMu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs approximate CRT basis switching: {X}_{Q} -&gt; {X'}_{P} X' = X + alpha*Q for small alpha {Q} = {q_1,...,q_l} {P} = {p_1,...,p_k}. </p>
<p>Brief algorithm: [X']_{p_j} = [\sum_i([x_i*(Q/q_i)^{-1}]_{q_i}*(Q/q_i)]_{p_j}</p>
<p>Source: "A full RNS variant of approximate homomorphic encryption" by Cheon, et. al.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;paramsQ</td><td>parameters for the CRT basis {q_1,...,q_l} </td></tr>
    <tr><td class="paramname">&amp;paramsP</td><td>parameters for the CRT basis {p_1,...,p_k} </td></tr>
    <tr><td class="paramname">&amp;QHatinvModq</td><td>precomputed values for [(Q/q_i)^{-1}]_{q_i} </td></tr>
    <tr><td class="paramname">&amp;QHatinvModqPrecon</td><td>NTL-specific precomputations </td></tr>
    <tr><td class="paramname">&amp;QHatModp</td><td>precomputed values for [Q/q_i]_{p_j} </td></tr>
    <tr><td class="paramname">&amp;modpBarrettMu</td><td>128-bit Barrett reduction precomputed values </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the representation of {X + alpha*Q} in basis {P}. </dd></dl>

</div>
</div>
<a id="a3de4e1a07f58874a6f03f9de8cca63c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3de4e1a07f58874a6f03f9de8cca63c2">&#9670;&nbsp;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt;::Integer &amp; <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::at </td>
          <td>(</td>
          <td class="paramtype">usint&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get interpolated value of elements at all tower index i. Note this operation is computationally intense. </p>
<dl class="section return"><dt>Returns</dt><dd>interpolated value at index i. </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a51c801b6fd516206b274d90163dd4bf1">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>.</p>

</div>
</div>
<a id="ae7336e935f2a0cd14d6bcfc8a8a2f373"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7336e935f2a0cd14d6bcfc8a8a2f373">&#9670;&nbsp;</a></span>AutomorphismTransform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a> <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::AutomorphismTransform </td>
          <td>(</td>
          <td class="paramtype">const usint &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Permutes coefficients in a polynomial. Moves the ith index to the first one, it only supports odd indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;i</td><td>is the element to perform the automorphism transform with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the automorphism transform. </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a703db5691aa73e9b2988b07376017219">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>.</p>

</div>
</div>
<a id="a77f3f1e018b1687961203d6af9b7b1c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77f3f1e018b1687961203d6af9b7b1c6">&#9670;&nbsp;</a></span>AutomorphismTransform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a> <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::AutomorphismTransform </td>
          <td>(</td>
          <td class="paramtype">usint&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; usint &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs an automorphism transform operation using precomputed bit reversal indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;i</td><td>is the element to perform the automorphism transform with. </td></tr>
    <tr><td class="paramname">&amp;map</td><td>a vector with precomputed indices </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the automorphism transform. </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a5805c88f6af7bb50febbfe8d436298ab">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>.</p>

</div>
</div>
<a id="afceb52d627d4e7c5c03efaf5a1144bb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afceb52d627d4e7c5c03efaf5a1144bb3">&#9670;&nbsp;</a></span>BaseDecompose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt; &gt; <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::BaseDecompose </td>
          <td>(</td>
          <td class="paramtype">usint&#160;</td>
          <td class="paramname"><em>baseBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>evalModeAnswer</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the element as <img class="formulaInl" alt="$ \sum\limits{i=0}^{\lfloor {\log q/base} \rfloor} {(base^i u_i)} $" src="form_0.png"/> and return the vector of <img class="formulaInl" alt="$ \left\{u_0, u_1,...,u_{\lfloor {\log q/base} \rfloor} \right\} \in R_{{base}^{\lceil {\log q/base} \rceil}} $" src="form_1.png"/>; This is used as a subroutine in the relinearization procedure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseBits</td><td>is the number of bits in the base, i.e., <img class="formulaInl" alt="$ base = 2^{baseBits} $" src="form_2.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the pointer where the base decomposition vector is stored </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#af494504657264b13c00a15bc27810dba">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>.</p>

</div>
</div>
<a id="a1824ade6bc5ba90e9188de3bd2b400c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1824ade6bc5ba90e9188de3bd2b400c7">&#9670;&nbsp;</a></span>Clone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a> <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::Clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clone the object by making a copy of it and returning the copy. </p>
<dl class="section return"><dt>Returns</dt><dd>new Element </dd></dl>

</div>
</div>
<a id="addb77b8b4292fee64c2eb4bf77d34f7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addb77b8b4292fee64c2eb4bf77d34f7a">&#9670;&nbsp;</a></span>CloneEmpty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a> <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::CloneEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clone the object, but have it contain nothing. </p>
<dl class="section return"><dt>Returns</dt><dd>new Element </dd></dl>

</div>
</div>
<a id="a81ddfb19d04d8ad8ca182728a2729006"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81ddfb19d04d8ad8ca182728a2729006">&#9670;&nbsp;</a></span>CloneTowers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a> <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::CloneTowers </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>startTower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>endTower</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a copy of the DCRTPoly, but it includes only a sequential subset of the towers that the original holds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startTower</td><td>The index number of the first tower to clone </td></tr>
    <tr><td class="paramname">endTower</td><td>The index number of the last tower to clone </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new Element </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a122a57c82a7aa913148ef673fdfb74aa">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>.</p>

</div>
</div>
<a id="a4ad0f93665a2538b35dc21982d8f8170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ad0f93665a2538b35dc21982d8f8170">&#9670;&nbsp;</a></span>CloneWithNoise()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt; <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::CloneWithNoise </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlbcrypto_1_1DiscreteGaussianGeneratorImpl.html">DiscreteGaussianGeneratorImpl</a>&lt; VecType &gt; &amp;&#160;</td>
          <td class="paramname"><em>dgg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Format&#160;</td>
          <td class="paramname"><em>format</em> = <code>EVALUATION</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clone with noise. This method creates a new DCRTPoly and clones the params. The tower values will be filled up with noise based on the discrete gaussian. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;dgg</td><td>the input discrete Gaussian generator. The dgg will be the seed to populate the towers of the DCRTPoly with random numbers. </td></tr>
    <tr><td class="paramname">format</td><td>the input format fixed to EVALUATION. Format is a enum type that indicates if the polynomial is in Evaluation representation or Coefficient representation. It is defined in <a class="el" href="inttypes_8h_source.html">inttypes.h</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classlbcrypto_1_1ILElement.html#a45e2e2a2bacd65456e0ce82aaf33e23e">lbcrypto::ILElement&lt; DCRTPolyImpl&lt; VecType &gt;, VecType &gt;</a>.</p>

</div>
</div>
<a id="adde6e16e5192893c3aa1fd24e23826ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adde6e16e5192893c3aa1fd24e23826ce">&#9670;&nbsp;</a></span>CRTDecompose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt; &gt; <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::CRTDecompose </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseBits</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>CRT basis decomposition of c as [c qi/q]_qi</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;baseBits</td><td>bits in the base for additional digit decomposition if base &gt; 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the pointer where the resulting vector is stored </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#afa5771dde254b6445a252714933504bb">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>.</p>

</div>
</div>
<a id="a10aa386efd097ac88b00c6670f147023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10aa386efd097ac88b00c6670f147023">&#9670;&nbsp;</a></span>CRTInterpolate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt;::<a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyLargeType</a> <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::CRTInterpolate</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interpolates the DCRTPoly to an Poly based on the Chinese Remainder Transform Interpolation. and then returns a Poly with that single element. </p>
<dl class="section return"><dt>Returns</dt><dd>the interpolated ring element as a Poly object. </dd></dl>

</div>
</div>
<a id="ac03600bc778887c747ac27e74704ccf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac03600bc778887c747ac27e74704ccf5">&#9670;&nbsp;</a></span>CRTInterpolateIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt;::<a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyLargeType</a> <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::CRTInterpolateIndex </td>
          <td>(</td>
          <td class="paramtype">usint&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interpolates the DCRTPoly to an Poly based on the Chinese Remainder Transform Interpolation, only at element index i, all other elements are zero. and then returns a Poly with that single element. </p>
<dl class="section return"><dt>Returns</dt><dd>the interpolated ring element as a Poly object. </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a8a1dc378f31930ed354ef77ed7351d9b">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>.</p>

</div>
</div>
<a id="a250b81c51dea6af83acf0fd2fc14f365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a250b81c51dea6af83acf0fd2fc14f365">&#9670;&nbsp;</a></span>DropLastElementAndScale()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::DropLastElementAndScale </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>QlQlInvModqlDivqlModq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>QlQlInvModqlDivqlModqPrecon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>qlInvModq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>qlInvModqPrecon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drops the last element in the double-CRT representation and scales down by the last CRT modulus. The resulting DCRTPoly element will have one less tower. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;QlQlInvModqlDivqlModq</td><td>precomputed values for [Q^(l)*[Q^(l)^{-1}]_{q_l}/q_l]_{q_i} </td></tr>
    <tr><td class="paramname">&amp;QlQlInvModqlDivqlModqPrecon</td><td>NTL-specific precomputations </td></tr>
    <tr><td class="paramname">&amp;qlInvModq</td><td>precomputed values for [q_l^{-1}]_{q_i} </td></tr>
    <tr><td class="paramname">&amp;qlInvModqPrecon</td><td>NTL-specific precomputations </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a454428f6f25cca22c8194788c549a5f6">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html#af66a8858b3583ee1410099cd9c745db3">lbcrypto::HexlDCRTPoly&lt; VecType &gt;</a>, and <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html#af66a8858b3583ee1410099cd9c745db3">lbcrypto::HexlDCRTPoly&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="a4f16ebd27ef359ce367fc8d6669c1a67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f16ebd27ef359ce367fc8d6669c1a67">&#9670;&nbsp;</a></span>ElementAtIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyImpl</a>&lt; <a class="el" href="classbigintnat_1_1NativeVector.html">NativeVector</a> &gt; &amp; <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::ElementAtIndex </td>
          <td>(</td>
          <td class="paramtype">usint&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get value of element at index i. </p>
<dl class="section return"><dt>Returns</dt><dd>value at index i. </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a8a68eccc6f73da3f18aa3d493db9209d">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>.</p>

</div>
</div>
<a id="a5a7994711f8054391c3b4e243882aab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a7994711f8054391c3b4e243882aab1">&#9670;&nbsp;</a></span>ExpandCRTBasis()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::ExpandCRTBasis </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt;&#160;</td>
          <td class="paramname"><em>paramsQP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt;&#160;</td>
          <td class="paramname"><em>paramsP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>QHatInvModq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>QHatInvModqPrecon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>QHatModp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>alphaQModp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; DoubleNativeInt &gt; &amp;&#160;</td>
          <td class="paramname"><em>modpBarrettMu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>qInv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Format&#160;</td>
          <td class="paramname"><em>resultFormat</em> = <code>EVALUATION</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs modulus raising: {X}_{Q} -&gt; {X}_{Q,P} {Q} = {q_1,...,q_l} {P} = {p_1,...,p_k}. </p>
<p>Brief algorithm: {X}_{Q} -&gt; {X}_P : use <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a84c8c9ac3d8593ad61784f4b9d9624cc" title="Performs CRT basis switching: {X}_{Q} -&gt; {X}_{P} {Q} = {q_1,...,q_l} {P} = {p_1,.....">DCRTPoly::SwitchCRTBasis</a> combine {X}_{Q} and {X}_{P} Outputs the resulting polynomial in CRT/RNS</p>
<p>Source: Halevi S., Polyakov Y., and Shoup V. An Improved RNS Variant of the BFV Homomorphic Encryption Scheme. Cryptology ePrint Archive, Report 2018/117. (<a href="https://eprint.iacr.org/2018/117">https://eprint.iacr.org/2018/117</a>)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;paramsQP</td><td>parameters for the CRT basis {q_1,...,q_l,p_1,...,p_k} </td></tr>
    <tr><td class="paramname">&amp;paramsP</td><td>parameters for the CRT basis {p_1,...,p_k} </td></tr>
    <tr><td class="paramname">&amp;QHatInvModq</td><td>precomputed values for [QInv_i]_{q_i} </td></tr>
    <tr><td class="paramname">&amp;QHatInvModqPrecon</td><td>NTL-specific precomputations </td></tr>
    <tr><td class="paramname">&amp;QHatModp</td><td>precomputed values for [QHat_i]_{p_j} </td></tr>
    <tr><td class="paramname">&amp;alphaQModp</td><td>precomputed values for [alpha*Q]_{p_j} </td></tr>
    <tr><td class="paramname">&amp;modpBarrettMu</td><td>128-bit Barrett reduction precomputed values for p_j @params &amp;qInv precomputed values for 1/q_i </td></tr>
    <tr><td class="paramname">resultFormat</td><td>Specifies the format we want the result to be in </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aac17034a9563956a162c6d3f3c80bd4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac17034a9563956a162c6d3f3c80bd4e">&#9670;&nbsp;</a></span>FastBaseConvqToBskMontgomery()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::FastBaseConvqToBskMontgomery </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt;&#160;</td>
          <td class="paramname"><em>paramsBsk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>moduliQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>moduliBsk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; DoubleNativeInt &gt; &amp;&#160;</td>
          <td class="paramname"><em>modbskBarrettMu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mtildeQHatInvModq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mtildeQHatInvModqPrecon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>QHatModbsk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint16_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>QHatModmtilde</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>QModbsk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>QModbskPrecon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t &amp;&#160;</td>
          <td class="paramname"><em>negQInvModmtilde</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mtildeInvModbsk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mtildeInvModbskPrecon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expands basis: {X}_{Q} -&gt; {X}_{Q,Bsk,mtilde} mtilde is a redundant modulus used to remove q overflows generated from fast conversion. Outputs the resulting polynomial in CRT/RNS {Q} = {q_1,...,q_l} {Bsk} = {bsk_1,...,bsk_k}. </p>
<p>Source: Jean-Claude Bajard and Julien Eynard and Anwar Hasan and Vincent Zucca. A Full RNS Variant of FV like Somewhat Homomorphic Encryption Schemes. Cryptology ePrint Archive: Report 2016/510. (<a href="https://eprint.iacr.org/2016/510">https://eprint.iacr.org/2016/510</a>)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">paramsBsk</td><td>container of Bsk moduli and roots on unity </td></tr>
    <tr><td class="paramname">&amp;moduliQ</td><td>basis {Q} = {q_1,q_2,...,q_l} </td></tr>
    <tr><td class="paramname">&amp;moduliBsk</td><td>basis {Bsk U mtilde} ... </td></tr>
    <tr><td class="paramname">&amp;modbskBarrettMu</td><td>128-bit Barrett reduction precomputed values for bsk_j </td></tr>
    <tr><td class="paramname">&amp;mtildeQHatInvModq</td><td>[mtilde*(Q/q_i)^{-1}]_{q_i} </td></tr>
    <tr><td class="paramname">&amp;mtildeQHatInvModqPrecon</td><td>NTL-specific precomputations </td></tr>
    <tr><td class="paramname">&amp;QHatModbsk</td><td>[Q/q_i]_{bsk_j} </td></tr>
    <tr><td class="paramname">&amp;QHatModmtilde</td><td>[Q/q_i]_{mtilde} </td></tr>
    <tr><td class="paramname">&amp;QModbsk</td><td>[Q]_{bsk_j} </td></tr>
    <tr><td class="paramname">&amp;QModbskPrecon</td><td>NTL-specific precomputations </td></tr>
    <tr><td class="paramname">&amp;negQInvModmtilde</td><td>[-Q^{-1}]_{mtilde} </td></tr>
    <tr><td class="paramname">&amp;mtildeInvModbsk</td><td>[mtilde^{-1}]_{bsk_j} </td></tr>
    <tr><td class="paramname">&amp;mtildeInvModbskPrecon</td><td>NTL-specific precomputations </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a175720c325d466f6eb7505f65035b849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a175720c325d466f6eb7505f65035b849">&#9670;&nbsp;</a></span>FastBaseConvSK()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::FastBaseConvSK </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>moduliQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; DoubleNativeInt &gt; &amp;&#160;</td>
          <td class="paramname"><em>modqBarrettMu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>moduliBsk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; DoubleNativeInt &gt; &amp;&#160;</td>
          <td class="paramname"><em>modbskBarrettMu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>BHatInvModb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>BHatInvModbPrecon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>BHatModmsk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &amp;&#160;</td>
          <td class="paramname"><em>BInvModmsk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &amp;&#160;</td>
          <td class="paramname"><em>BInvModmskPrecon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>BHatModq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>BModq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>BModqPrecon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts basis: {X}_{Q,Bsk} -&gt; {X}_{Bsk} {Q} = {q_1,...,q_l} {Bsk} = {bsk_1,...,bsk_k} using Shenoy Kumaresan method. Outputs the resulting polynomial in CRT/RNS. </p>
<p>Source: Jean-Claude Bajard and Julien Eynard and Anwar Hasan and Vincent Zucca. A Full RNS Variant of FV like Somewhat Homomorphic Encryption Schemes. Cryptology ePrint Archive: Report 2016/510. (<a href="https://eprint.iacr.org/2016/510">https://eprint.iacr.org/2016/510</a>)</p>
<p>Note in the source paper, B is referred to by M.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;moduliQ</td><td>basis Q = {q_1,...,q_l} </td></tr>
    <tr><td class="paramname">&amp;modqBarrettMu</td><td>precomputed Barrett Mu for q_i </td></tr>
    <tr><td class="paramname">&amp;moduliBsk</td><td>basis {Bsk} = {bsk_1,...,bsk_k} </td></tr>
    <tr><td class="paramname">&amp;modbskBarrettMu</td><td>precomputed Barrett Mu for bsk_j </td></tr>
    <tr><td class="paramname">&amp;BHatInvModb</td><td>[(B/b_j)^{-1}]_{b_j} </td></tr>
    <tr><td class="paramname">&amp;BHatInvModbPrecon</td><td><a class="el" href="namespaceNTL.html">NTL</a> precomptations for [(B/b_j)^{-1}]_{b_j} </td></tr>
    <tr><td class="paramname">&amp;BHatModmsk</td><td>[B/b_j]_{msk} </td></tr>
    <tr><td class="paramname">&amp;BInvModmsk</td><td>[B^{-1}]_{msk} </td></tr>
    <tr><td class="paramname">&amp;BInvModmskPrecon</td><td><a class="el" href="namespaceNTL.html">NTL</a> precomptation for [B^{-1}]_{msk} </td></tr>
    <tr><td class="paramname">&amp;BHatModq</td><td>[B/b_j]_{q_i} </td></tr>
    <tr><td class="paramname">&amp;BModq</td><td>[B]_{q_i} </td></tr>
    <tr><td class="paramname">&amp;BModqPrecon</td><td><a class="el" href="namespaceNTL.html">NTL</a> precomptations for [B]_{q_i} </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#adb8755ad950dc46a5400facfa3f39c32">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>.</p>

</div>
</div>
<a id="a7ebeafa37c47d074c2ed333c6ffbc960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ebeafa37c47d074c2ed333c6ffbc960">&#9670;&nbsp;</a></span>FastRNSFloorq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::FastRNSFloorq </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>moduliQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>moduliBsk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; DoubleNativeInt &gt; &amp;&#160;</td>
          <td class="paramname"><em>modbskBarrettMu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tQHatInvModq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tQHatInvModqPrecon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>QHatModbsk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>qInvModbsk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tQInvModbsk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tQInvModbskPrecon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes scale and floor: {X}_{Q,Bsk} -&gt; {\floor{t/Q * X}}_{Bsk} {Q} = {q_1,...,q_l} {Bsk} = {bsk_1,...,bsk_k} Outputs the resulting polynomial in CRT/RNS. </p>
<p>Source: Jean-Claude Bajard and Julien Eynard and Anwar Hasan and Vincent Zucca. A Full RNS Variant of FV like Somewhat Homomorphic Encryption Schemes. Cryptology ePrint Archive: Report 2016/510. (<a href="https://eprint.iacr.org/2016/510">https://eprint.iacr.org/2016/510</a>)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;t</td><td>plaintext modulus </td></tr>
    <tr><td class="paramname">&amp;moduliQ</td><td>{Q} = {q_1,...,q_l} </td></tr>
    <tr><td class="paramname">&amp;moduliBsk</td><td>{Bsk} = {bsk_1,...,bsk_k} </td></tr>
    <tr><td class="paramname">&amp;modbskBarrettMu</td><td>128-bit Barrett reduction precomputed values for bsk_j </td></tr>
    <tr><td class="paramname">&amp;tQHatInvModq</td><td>[(Q/q_i)^{-1}]_{q_i} </td></tr>
    <tr><td class="paramname">&amp;tQHatInvModqPrecon</td><td>NTL-specific precomputations </td></tr>
    <tr><td class="paramname">&amp;QHatModbsk</td><td>[Q/q_i]_{bsk_i} </td></tr>
    <tr><td class="paramname">&amp;qInvModbsk</td><td>[(q_i)^{-1}]_{bsk_j} </td></tr>
    <tr><td class="paramname">&amp;tQInvModbsk</td><td>[t*Q^{-1}]_{bsk_j} </td></tr>
    <tr><td class="paramname">&amp;tQInvModbskPrecon</td><td>NTL-specific precomputations </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a79ab7c03584ce526f115af9f8690519c">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>.</p>

</div>
</div>
<a id="a60dc86e2084a250d002f47c7581a9990"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60dc86e2084a250d002f47c7581a9990">&#9670;&nbsp;</a></span>GetAllElements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; typename <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt;::<a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyType</a> &gt; &amp; <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::GetAllElements</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get method that returns a vector of all component elements. </p>
<dl class="section return"><dt>Returns</dt><dd>a vector of the component elements. </dd></dl>

</div>
</div>
<a id="a943ae946b1541b8968e008e8f5c9d839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a943ae946b1541b8968e008e8f5c9d839">&#9670;&nbsp;</a></span>GetElementAtIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt;::<a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyType</a> &amp; <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::GetElementAtIndex </td>
          <td>(</td>
          <td class="paramtype">usint&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get method of individual tower of elements. Note this behavior is different than poly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>index of tower to be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the returned tower </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a62144e300a0691110a99511b9f21617b">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>.</p>

</div>
</div>
<a id="ae44d26cfeab8b34089756e00aaa2c090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae44d26cfeab8b34089756e00aaa2c090">&#9670;&nbsp;</a></span>GetExtendedCRTBasis()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt; typename <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt;::<a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt; <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::GetExtendedCRTBasis </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt;&#160;</td>
          <td class="paramname"><em>paramsP</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the element parameters for DCRTPoly elements in an extended CRT basis, which is the concatenation of the towers currently in "this" DCRTPoly, and the moduli in ParamsP. </p>
<dl class="section return"><dt>Returns</dt><dd>element parameters of the extended basis. </dd></dl>

</div>
</div>
<a id="ac5123c286785633ed7726dda3a2de9e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5123c286785633ed7726dda3a2de9e9">&#9670;&nbsp;</a></span>GetNumOfElements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">usint <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::GetNumOfElements</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get method of the number of component elements, also known as the number of towers. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of component elements. </dd></dl>

</div>
</div>
<a id="a63d3e755fea7654aa9b3e7bd14e42a8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63d3e755fea7654aa9b3e7bd14e42a8d">&#9670;&nbsp;</a></span>GetWorkingModulus()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt;::Integer <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::GetWorkingModulus</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes and returns the product of primes in the current moduli chain. Compared to GetModulus, which always returns the product of all primes in the crypto parameters, this method will return a different modulus, based on the towers/moduli that are currently in the chain (some towers are dropped along the way). </p>
<dl class="section return"><dt>Returns</dt><dd>the product of moduli in the current towers. </dd></dl>

</div>
</div>
<a id="a344d2b7f16a8aa10a4006dfd972a78e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a344d2b7f16a8aa10a4006dfd972a78e1">&#9670;&nbsp;</a></span>InverseExists()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::InverseExists</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if inverse exists. </p>
<dl class="section return"><dt>Returns</dt><dd>is the Boolean representation of the existence of multiplicative inverse. </dd></dl>

</div>
</div>
<a id="abc4b6a822c5551bf0f23b61e1426d26e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc4b6a822c5551bf0f23b61e1426d26e">&#9670;&nbsp;</a></span>IsEmpty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::IsEmpty</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if ALL the tower(s) are empty. </p>
<dl class="section return"><dt>Returns</dt><dd>true if all towers are empty </dd></dl>

</div>
</div>
<a id="a13383a02ee6a007a1c4cf5ea07c3c707"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13383a02ee6a007a1c4cf5ea07c3c707">&#9670;&nbsp;</a></span>MakeSparse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::MakeSparse </td>
          <td>(</td>
          <td class="paramtype">const uint32_t &amp;&#160;</td>
          <td class="paramname"><em>wFactor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make DCRTPoly Sparse. Sets every index of each tower not equal to zero mod the wFactor to zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;wFactor</td><td>ratio between the sparse and none-sparse values. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a4c06761fc369968fe907d8aaea9596fc">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>.</p>

</div>
</div>
<a id="a9094f635ef1078a91ffae5c4520e6615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9094f635ef1078a91ffae5c4520e6615">&#9670;&nbsp;</a></span>Minus() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt; <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::Minus </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a> &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a subtraction operation and returns the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;element</td><td>is the element to subtract from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the subtraction. </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a3ec584b5d32386e4f3682bb8a386aa6b">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>.</p>

</div>
</div>
<a id="ade9a9e38b6c5b4e0a445f1526bb731d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade9a9e38b6c5b4e0a445f1526bb731d6">&#9670;&nbsp;</a></span>Minus() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt; <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::Minus </td>
          <td>(</td>
          <td class="paramtype">const Integer &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scalar subtraction - subtract an element to all entries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;element</td><td>is the element to subtract entry-wise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the return value of the minus operation. </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1ILElement.html#aceb6e03c9b3106a45c13f3488bdaf403">lbcrypto::ILElement&lt; DCRTPolyImpl&lt; VecType &gt;, VecType &gt;</a>.</p>

</div>
</div>
<a id="a23a9e333f86b9f21ef1cca2e1f1e2280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23a9e333f86b9f21ef1cca2e1f1e2280">&#9670;&nbsp;</a></span>Minus() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt; <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::Minus </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; Integer &gt; &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scalar subtraction for elements in CRT format. CRT elements are represented as vector of integer elements which correspond to the represented number modulo the primes in the tower chain (in same order). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;element</td><td>is the element to subtract entry-wise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the subtraction operation. </dd></dl>

</div>
</div>
<a id="a785eaff12419d594ce3255d16894c58f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a785eaff12419d594ce3255d16894c58f">&#9670;&nbsp;</a></span>ModReduce()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::ModReduce </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tModqPrecon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &amp;&#160;</td>
          <td class="paramname"><em>negtInvModq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &amp;&#160;</td>
          <td class="paramname"><em>negtInvModqPrecon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>qlInvModq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>qlInvModqPrecon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ModReduces reduces the DCRTPoly element's composite modulus by dropping the last modulus from the chain of moduli as well as dropping the last tower. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;t</td><td>is the plaintextModulus used for the DCRTPoly </td></tr>
    <tr><td class="paramname">&amp;tModqPrecon</td><td>NTL-specific precomputations for [t]_{q_i} </td></tr>
    <tr><td class="paramname">&amp;negtInvModq</td><td>precomputed values for [-t^{-1}]_{q_i} </td></tr>
    <tr><td class="paramname">&amp;negtInvModqPrecon</td><td>NTL-specific precomputations for [-t^{-1}]_{q_i} </td></tr>
    <tr><td class="paramname">&amp;qlInvModq</td><td>precomputed values for [q_{l}^{-1}]_{q_i} </td></tr>
    <tr><td class="paramname">&amp;qlInvModqPrecon</td><td>NTL-specific precomputations for [q_{l}^{-1}]_{q_i}</td></tr>
  </table>
  </dd>
</dl>
<p>Used for BGVrns modulus switching This function performs ModReduce on ciphertext element and private key element. The algorithm computes ct' &lt;- round( ct/qt ).</p>
<p>Modulus reduction reduces a ciphertext from modulus q to a smaller modulus q/qt where qt is generally the last moduli of the tower. ModReduce is written for <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html" title="Ideal lattice for the double-CRT representation. The implementation contains a vector of underlying n...">DCRTPolyImpl</a> and it drops the last tower while updating the necessary parameters.</p>
<p>The rounding is actually computed as a flooring by computing delta such that delta = -ct mod qt and delta = 0 [t]</p>
<p>The steps taken here are as follows:</p><ol type="1">
<li>compute delta &lt;- -ct/ptm mod qt</li>
<li>compute delta &lt;- ptm*delta in Z. E.g., all of delta's integer coefficients can be in the range [-ptm*qt/2, ptm*qt/2).</li>
<li>let d' = c + delta mod q/qt. By construction, d' is divisible by qt and congruent to 0 mod ptm.</li>
<li>output (d'/q') in R(q/q'). </li>
</ol>

<p>Implements <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a25e133a2c25996be14600e54605b8bc4">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>.</p>

</div>
</div>
<a id="acd897dd2c899f77b863fefce1eb8c7eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd897dd2c899f77b863fefce1eb8c7eb">&#9670;&nbsp;</a></span>MultiplicativeInverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt; <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::MultiplicativeInverse</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a multiplicative inverse operation and returns the result. </p>
<dl class="section return"><dt>Returns</dt><dd>is the result of the multiplicative inverse. </dd></dl>

</div>
</div>
<a id="a5b406c67506cb08ee38ef69c004daff3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b406c67506cb08ee38ef69c004daff3">&#9670;&nbsp;</a></span>Negate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt; <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::Negate</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a negation operation and returns the result. </p>
<dl class="section return"><dt>Returns</dt><dd>is the result of the negation. </dd></dl>

</div>
</div>
<a id="a214892eae601551e99859e161ddc56eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a214892eae601551e99859e161ddc56eb">&#9670;&nbsp;</a></span>Norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::Norm</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the infinity norm, basically the largest value in the ring element. </p>
<dl class="section return"><dt>Returns</dt><dd>is the largest value in the ring element. </dd></dl>

</div>
</div>
<a id="abc02a96815782bfe2dc8562ed5985030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc02a96815782bfe2dc8562ed5985030">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt; &amp; <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a> &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs an multiplication operation and returns the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;element</td><td>is the element to multiply with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the multiplication. </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#afc908662a421a5f61b9d555cf4feaa51">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>.</p>

</div>
</div>
<a id="a63a5c2efe731d3835f1cbfcbfde7c0ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63a5c2efe731d3835f1cbfcbfde7c0ca">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt; &amp; <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const Integer &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a multiplication operation and returns the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;element</td><td>is the element to multiply by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the multiplication. </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1ILElement.html#abb0670789e94757db373df45ff9067cd">lbcrypto::ILElement&lt; DCRTPolyImpl&lt; VecType &gt;, VecType &gt;</a>.</p>

</div>
</div>
<a id="afccab6ba0d328ddb7edcafe133e5d1dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afccab6ba0d328ddb7edcafe133e5d1dc">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt; &amp; <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs an entry-wise addition over all elements of each tower with the towers of the element on the right hand side. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;rhs</td><td>is the element to add with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the addition. </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a126c7febc3ab3bc45522ef94bf835e7c">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>.</p>

</div>
</div>
<a id="ad5f25491a1471ffb6b028cd06082cd7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5f25491a1471ffb6b028cd06082cd7f">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a>&amp; <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const Integer &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs += operation with a BigInteger and returns the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;element</td><td>is the element to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the addition. </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1ILElement.html#ad5763872f5ef073a213c3d7564bb1359">lbcrypto::ILElement&lt; DCRTPolyImpl&lt; VecType &gt;, VecType &gt;</a>.</p>

</div>
</div>
<a id="a52f5c45054cfb7fa5587e5f2ba961cde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52f5c45054cfb7fa5587e5f2ba961cde">&#9670;&nbsp;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a> <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::operator- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unary minus on a element. </p>
<dl class="section return"><dt>Returns</dt><dd>additive inverse of the an element. </dd></dl>

</div>
</div>
<a id="aa965df981061d0f6390293612613b8a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa965df981061d0f6390293612613b8a1">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt; &amp; <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs an entry-wise subtraction over all elements of each tower with the towers of the element on the right hand side. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;rhs</td><td>is the element to subtract from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the addition. </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a06ac6a37ad6be0a9055cb9dbedd2a9bc">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>.</p>

</div>
</div>
<a id="aa0946e79b8bfd1bb65600b0a203b8899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0946e79b8bfd1bb65600b0a203b8899">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a>&amp; <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const Integer &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a subtraction operation and returns the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;element</td><td>is the element to subtract from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the subtraction. </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1ILElement.html#ae7b6b8e3c0fe6e82a736e0697a381856">lbcrypto::ILElement&lt; DCRTPolyImpl&lt; VecType &gt;, VecType &gt;</a>.</p>

</div>
</div>
<a id="a194ec63fd9ff31e9bde2974268525ba9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a194ec63fd9ff31e9bde2974268525ba9">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt; &amp; <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment Operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;rhs</td><td>the copied element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting element. </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a6c3acffd584a927600c188a32626b7c5">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html#a5e16cfe8143c71fc16b199f6e66ad626">lbcrypto::HexlDCRTPoly&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="a1b32d39e39dba41cc4d8b70c3c93acf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b32d39e39dba41cc4d8b70c3c93acf0">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt; &amp; <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a Poly from a vector of signed integers (used for trapdoor sampling) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;rhs</td><td>the vector to set the <a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyImpl</a> to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting <a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyImpl</a>. </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a0cfedcf2b29c343daf88b24a3c52613d">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html#a32f69739e67857b9f647e49c8036b616">lbcrypto::HexlDCRTPoly&lt; VecType &gt;</a>, and <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html#a32f69739e67857b9f647e49c8036b616">lbcrypto::HexlDCRTPoly&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="a1a5a9c1ab6486c7dcd7dd57d6a225872"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a5a9c1ab6486c7dcd7dd57d6a225872">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt; &amp; <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a Poly from a vector of signed integers (used for trapdoor sampling) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;rhs</td><td>the vector to set the <a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyImpl</a> to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting <a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyImpl</a>. </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a2ecc645e7b55894a3f94280b41e9f982">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html#ac9b1f3ddb28c85c6eed67756727026bd">lbcrypto::HexlDCRTPoly&lt; VecType &gt;</a>, and <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html#ac9b1f3ddb28c85c6eed67756727026bd">lbcrypto::HexlDCRTPoly&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="abd56802ffaaabf5f8b8e1ebaec49a529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd56802ffaaabf5f8b8e1ebaec49a529">&#9670;&nbsp;</a></span>operator=() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt; &amp; <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move Assignment Operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;rhs</td><td>the copied element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting element. </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a7b97ec6ea90493c8c4ef7e77bf7f4800">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html#af905877cd082d61e2092211ce8d8daa8">lbcrypto::HexlDCRTPoly&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="a50eb6a2455f926c4a1963b4a59459d7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50eb6a2455f926c4a1963b4a59459d7c">&#9670;&nbsp;</a></span>operator=() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt; &amp; <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initalizer list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;rhs</td><td>the list to set the <a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyImpl</a> to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting <a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyImpl</a>. </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#af06c30c5d62fb3b177a9eecacc1e7e0e">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html#a5977421f361f0fbfb3c4514036453a6c">lbcrypto::HexlDCRTPoly&lt; VecType &gt;</a>, and <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html#a5977421f361f0fbfb3c4514036453a6c">lbcrypto::HexlDCRTPoly&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="a2758f06a1075c396b73344ed3a13a734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2758f06a1075c396b73344ed3a13a734">&#9670;&nbsp;</a></span>operator=() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt; &amp; <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; uint64_t &gt;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initalizer list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;rhs</td><td>the list to initalized the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting element. </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a3c21084ea80bc73c22800792f78efa26">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html#af5f92cd8de1c2158c048379eb3a7d936">lbcrypto::HexlDCRTPoly&lt; VecType &gt;</a>, and <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html#af5f92cd8de1c2158c048379eb3a7d936">lbcrypto::HexlDCRTPoly&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="a4423d9b9a6034d499e45c4f15ba969d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4423d9b9a6034d499e45c4f15ba969d5">&#9670;&nbsp;</a></span>operator=() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt; &amp; <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment Operator. The usint val will be set at index zero and all other indices will be set to zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>is the usint to assign to index zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting vector. </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#afa510d16766774ae7e15c52f08db2b82">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html#aaeb069d4a0538c0bc7e54a8d43ab9cc9">lbcrypto::HexlDCRTPoly&lt; VecType &gt;</a>, and <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html#aaeb069d4a0538c0bc7e54a8d43ab9cc9">lbcrypto::HexlDCRTPoly&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="a38d217014f2f8e5075ab2b7d211ffae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38d217014f2f8e5075ab2b7d211ffae9">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;rhs</td><td>is the specified element to be compared with this element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this element represents the same values as the specified element, false otherwise </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a845271828e9e902a65840752b3fdcc16">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>.</p>

</div>
</div>
<a id="a240aacc87126a12e6b6dd6e6503b0fa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a240aacc87126a12e6b6dd6e6503b0fa1">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt;::Integer &amp; <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">usint&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get interpolated value of element at index i. Note this operation is computationally intense. </p>
<dl class="section return"><dt>Returns</dt><dd>interpolated value at index i. </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a02b0f63b9b363fe509e449ca9fe9e24f">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>.</p>

</div>
</div>
<a id="a9a3cea10ad195e8b3408da102f0ec9b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a3cea10ad195e8b3408da102f0ec9b7">&#9670;&nbsp;</a></span>Plus() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt; <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::Plus </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a> &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs an addition operation and returns the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;element</td><td>is the element to add with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the addition. </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a0c1193a99a15b71b7eb3b544b53b827e">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>.</p>

</div>
</div>
<a id="af531265d23d28fc85776bff0789e5205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af531265d23d28fc85776bff0789e5205">&#9670;&nbsp;</a></span>Plus() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt; <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::Plus </td>
          <td>(</td>
          <td class="paramtype">const Integer &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scalar addition - add an element to the first index of each tower. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;element</td><td>is the element to add entry-wise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the addition operation. </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1ILElement.html#a07683b181b31fb853a4988a7f35bc776">lbcrypto::ILElement&lt; DCRTPolyImpl&lt; VecType &gt;, VecType &gt;</a>.</p>

</div>
</div>
<a id="a3c0a6d0fe477043cceba2adaa95afa9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c0a6d0fe477043cceba2adaa95afa9a">&#9670;&nbsp;</a></span>Plus() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt; <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::Plus </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; Integer &gt; &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scalar addition for elements in CRT format. CRT elements are represented as vector of integer elements which correspond to the represented number modulo the primes in the tower chain (in same order). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;element</td><td>is the element to add entry-wise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the addition operation. </dd></dl>

</div>
</div>
<a id="af44c8da870103210cc33abb50446f44a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af44c8da870103210cc33abb50446f44a">&#9670;&nbsp;</a></span>PowersOfBase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt; &gt; <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::PowersOfBase </td>
          <td>(</td>
          <td class="paramtype">usint&#160;</td>
          <td class="paramname"><em>baseBits</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a vector of <a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyImpl</a>'s as <img class="formulaInl" alt="$ \left\{x, {base}*x, {base}^2*x, ..., {base}^{\lfloor {\log q/{base}} \rfloor} \right\}*x $" src="form_3.png"/>, where <img class="formulaInl" alt="$ x $" src="form_4.png"/> is the current <a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyImpl</a> object; used as a subroutine in the relinearization procedure to get powers of a certain "base" for the secret key element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseBits</td><td>is the number of bits in the base, i.e., <img class="formulaInl" alt="$ base = 2^{baseBits} $" src="form_2.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the pointer where the base decomposition vector is stored </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a15120f3c80902a9a3e8fa080d23bd484">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>.</p>

</div>
</div>
<a id="ac519a50276b7a54a86ba4b1dd0bb8e30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac519a50276b7a54a86ba4b1dd0bb8e30">&#9670;&nbsp;</a></span>ScaleAndRound() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyImpl</a>&lt; <a class="el" href="classbigintnat_1_1NativeVector.html">NativeVector</a> &gt; <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::ScaleAndRound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tQHatInvModqDivqModt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tQHatInvModqDivqModtPrecon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tQHatInvModqBDivqModt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tQHatInvModqBDivqModtPrecon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>tQHatInvModqDivqFrac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>tQHatInvModqBDivqFrac</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs scale and round: {X}_{Q} -&gt; {\round(t/Q*X)}_t {Q} = {q_1,...,q_l} {P} = {p_1,...,p_k}. </p>
<p>Brief algorithm: [\sum_i x_i*[t*QHatInv_i/q_i]_t + Round(\sum_i x_i*{t*QHatInv_i/q_i})]_t</p>
<p>Source: Halevi S., Polyakov Y., and Shoup V. An Improved RNS Variant of the BFV Homomorphic Encryption Scheme. Cryptology ePrint Archive, Report 2018/117. (<a href="https://eprint.iacr.org/2018/117">https://eprint.iacr.org/2018/117</a>)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;t</td><td>often corresponds to the plaintext modulus </td></tr>
    <tr><td class="paramname">&amp;tQHatInvModqDivqModt</td><td>precomputed values for [Floor{t*QHatInv_i/q_i}]_t </td></tr>
    <tr><td class="paramname">&amp;tQHatInvModqDivqModtPrecon</td><td>NTL-specific precomputations </td></tr>
    <tr><td class="paramname">&amp;tQHatInvModqBDivqModt</td><td>precomputed values for [Floor{t*QHatInv_i*B/q_i}]_t used when CRT moduli are 45..60 bits long </td></tr>
    <tr><td class="paramname">&amp;tQHatInvBDivqModtPrecon</td><td>NTL-specific precomputations used when CRT moduli are 45..60 bits long </td></tr>
    <tr><td class="paramname">&amp;tQHatInvModqDivqFrac</td><td>precomputed values for Frac{t*QHatInv_i/q_i} </td></tr>
    <tr><td class="paramname">&amp;tQHatInvBDivqFrac</td><td>precomputed values for Frac{t*QHatInv_i*B/q_i} used when CRT moduli are 45..60 bits long </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of computation as a polynomial with native 64-bit coefficients </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#ab60fd67b9cdf8d1dc877432a9c198e98">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>.</p>

</div>
</div>
<a id="a9869928c9d44c9624efd0813322282f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9869928c9d44c9624efd0813322282f9">&#9670;&nbsp;</a></span>ScaleAndRound() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt; <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::ScaleAndRound </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt;&#160;</td>
          <td class="paramname"><em>paramsP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>tPSHatInvModsDivsModp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>tPSHatInvModsDivsFrac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; DoubleNativeInt &gt; &amp;&#160;</td>
          <td class="paramname"><em>modpBarretMu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes scale and round: {X}_{Q,P} -&gt; {t/Q * X}_{P} {Q} = {q_1,...,q_l} {P} = {p_1,...,p_k}. </p>
<p>Brief algorithm: Let S = {Q,P} 1) [\sum_k x_k * alpha_k + Round(\sum_k beta_k * x_k)]_{p_j} 2) alpha_k = [Floor[t*P*[[SHatInv_k]_{s_k}/s_k]]_{p_j} 3) beta_k = {t*P*[[SHatInv_k]_{s_k}/s_k}</p>
<p>Source: Halevi S., Polyakov Y., and Shoup V. An Improved RNS Variant of the BFV Homomorphic Encryption Scheme. Cryptology ePrint Archive, Report 2018/117. (<a href="https://eprint.iacr.org/2018/117">https://eprint.iacr.org/2018/117</a>)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;paramsP</td><td>parameters for the CRT basis {p_1,...,p_k} </td></tr>
    <tr><td class="paramname">&amp;tPSHatInvModsDivsModp</td><td>precomputed values for [\floor[t*P*[[SHatInv_k]_{s_k}/s_k]]_{p_j} </td></tr>
    <tr><td class="paramname">&amp;tPSHatInvModsDivsFrac</td><td>precomputed values for {t*P*[[SHatInv_k]_{s_k}/s_k} </td></tr>
    <tr><td class="paramname">&amp;modpBarretMu</td><td>128-bit Barrett reduction precomputed values for p_j </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result {t/Q * X}_{P} </dd></dl>

</div>
</div>
<a id="afe11386ec43bee605053b5440867a51d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe11386ec43bee605053b5440867a51d">&#9670;&nbsp;</a></span>ScaleAndRound() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyImpl</a>&lt; <a class="el" href="classbigintnat_1_1NativeVector.html">NativeVector</a> &gt; <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::ScaleAndRound </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>moduliQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &amp;&#160;</td>
          <td class="paramname"><em>tgamma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tgammaQHatModq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tgammaQHatModqPrecon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>negInvqModtgamma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>negInvqModtgammaPrecon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes scale and round for fast rounding: {X}_{Q} -&gt; {\round(t/Q * X)}_t {Q} = {q_1,...,q_l}. </p>
<p>Brief algorithm:</p>
<p>Source: Jean-Claude Bajard and Julien Eynard and Anwar Hasan and Vincent Zucca. A Full RNS Variant of FV like Somewhat Homomorphic Encryption Schemes. Cryptology ePrint Archive: Report 2016/510. (<a href="https://eprint.iacr.org/2016/510">https://eprint.iacr.org/2016/510</a>)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;moduliQ</td><td>moduli {q_1,...,q_l} </td></tr>
    <tr><td class="paramname">&amp;t</td><td>often corresponds to the plaintext modulus </td></tr>
    <tr><td class="paramname">&amp;tgamma</td><td>t * gamma : t * 2^26 reduction </td></tr>
    <tr><td class="paramname">&amp;tgammaQHatModq</td><td>[t*gamma*(Q/q_i)]_{q_i} </td></tr>
    <tr><td class="paramname">&amp;tgammaQHatModqPrecon</td><td>NTL-specific precomputations </td></tr>
    <tr><td class="paramname">&amp;negInvqModtgamma</td><td>[-q^{-1}]_{t*gamma} </td></tr>
    <tr><td class="paramname">&amp;negInvqModtgammaPrecon</td><td>NTL-specific precomputations </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a474f08ad683cb2d196024fc0a0a34b1f">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>.</p>

</div>
</div>
<a id="a60547fcb7ba2bda5861b637483c4b8a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60547fcb7ba2bda5861b637483c4b8a7">&#9670;&nbsp;</a></span>SetElementAtIndex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::SetElementAtIndex </td>
          <td>(</td>
          <td class="paramtype">usint&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyType</a> &amp;&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets element at index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>where the element should be set </td></tr>
    <tr><td class="paramname">element</td><td>The element to store </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#af0e661fe12826ed9369943c5d8aec138">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>.</p>

</div>
</div>
<a id="a9fd0741c2089400d7fa3a0c388cc78a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fd0741c2089400d7fa3a0c388cc78a2">&#9670;&nbsp;</a></span>SetElementAtIndex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::SetElementAtIndex </td>
          <td>(</td>
          <td class="paramtype">usint&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyType</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets element at index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>where the element should be set </td></tr>
    <tr><td class="paramname">element</td><td>The element to store </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a5b6d970d2568f0f712d39d20021eee2d">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>.</p>

</div>
</div>
<a id="a84c8c9ac3d8593ad61784f4b9d9624cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84c8c9ac3d8593ad61784f4b9d9624cc">&#9670;&nbsp;</a></span>SwitchCRTBasis()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt; <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::SwitchCRTBasis </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt;&#160;</td>
          <td class="paramname"><em>paramsP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>QHatInvModq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>QHatInvModqPrecon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>QHatModp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>alphaQModp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; DoubleNativeInt &gt; &amp;&#160;</td>
          <td class="paramname"><em>modpBarrettMu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>qInv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs CRT basis switching: {X}_{Q} -&gt; {X}_{P} {Q} = {q_1,...,q_l} {P} = {p_1,...,p_k}. </p>
<p>Brief algorithm: 1) X=\sum_i[x_i*(Q/q_i)^{-1}]_{q_i}*(Q/q_i)-alpha*Q 2) compute round[[x_i*(Q/q_i)^{-1}]_{q_i} / q_i] to find alpha 3) [X]_{p_j}=[\sum_i[x_i*(Q/q_i)^{-1}]_{q_i}*(Q/q_i)]_{p_j}-[alpha*Q]_{p_j}</p>
<p>Source: Halevi S., Polyakov Y., and Shoup V. An Improved RNS Variant of the BFV Homomorphic Encryption Scheme. Cryptology ePrint Archive, Report 2018/117. (<a href="https://eprint.iacr.org/2018/117">https://eprint.iacr.org/2018/117</a>)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;paramsP</td><td>parameters for the CRT basis {p_1,...,p_k} </td></tr>
    <tr><td class="paramname">&amp;QHatInvModq</td><td>precomputed values for [(Q/q_i)^{-1}]_{q_i} </td></tr>
    <tr><td class="paramname">&amp;QHatInvModqPrecon</td><td>NTL-specific precomputations </td></tr>
    <tr><td class="paramname">&amp;QHatModp</td><td>precomputed values for [Q/q_i]_{p_j} </td></tr>
    <tr><td class="paramname">&amp;alphaQModp</td><td>precomputed values for [alpha*Q]_{p_j} </td></tr>
    <tr><td class="paramname">&amp;modpBarrettMu</td><td>128-bit Barrett reduction precomputed values for p_j @params &amp;qInv precomputed values for 1/q_i </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the representation of {X}_{P} </dd></dl>

</div>
</div>
<a id="a5760813c7513606ea0cf28015639297e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5760813c7513606ea0cf28015639297e">&#9670;&nbsp;</a></span>SwitchModulus()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::SwitchModulus </td>
          <td>(</td>
          <td class="paramtype">const Integer &amp;&#160;</td>
          <td class="paramname"><em>modulus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Integer &amp;&#160;</td>
          <td class="paramname"><em>rootOfUnity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Integer &amp;&#160;</td>
          <td class="paramname"><em>modulusArb</em> = <code>Integer(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Integer &amp;&#160;</td>
          <td class="paramname"><em>rootOfUnityArb</em> = <code>Integer(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Switch modulus and adjust the values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;modulus</td><td>is the modulus to be set </td></tr>
    <tr><td class="paramname">&amp;rootOfUnity</td><td>is the corresponding root of unity for the modulus </td></tr>
    <tr><td class="paramname">&amp;modulusArb</td><td>is the modulus used for arbitrary cyclotomics CRT </td></tr>
    <tr><td class="paramname">&amp;rootOfUnityArb</td><td>is the corresponding root of unity for the modulus ASSUMPTION: This method assumes that the caller provides the correct rootOfUnity for the modulus </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classlbcrypto_1_1ILElement.html#a58eafec82f5f68c4e9efcf37324c0d03">lbcrypto::ILElement&lt; DCRTPolyImpl&lt; VecType &gt;, VecType &gt;</a>.</p>

</div>
</div>
<a id="a38e9a3306642a95e2a6debae131f234b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38e9a3306642a95e2a6debae131f234b">&#9670;&nbsp;</a></span>SwitchModulusAtIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::SwitchModulusAtIndex </td>
          <td>(</td>
          <td class="paramtype">usint&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Integer &amp;&#160;</td>
          <td class="paramname"><em>modulus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Integer &amp;&#160;</td>
          <td class="paramname"><em>rootOfUnity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Switch modulus at tower i and adjust the values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>is the index for the tower </td></tr>
    <tr><td class="paramname">&amp;modulus</td><td>is the modulus to be set </td></tr>
    <tr><td class="paramname">&amp;rootOfUnity</td><td>is the corresponding root of unity for the modulus ASSUMPTION: This method assumes that the caller provides the correct rootOfUnity for the modulus </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a187ab86229c1ecc9f372fd76886426eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a187ab86229c1ecc9f372fd76886426eb">&#9670;&nbsp;</a></span>Times() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt; <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::Times </td>
          <td>(</td>
          <td class="paramtype">bigintnat::NativeInteger::SignedNativeInt&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scalar multiplication - multiply by a signed integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;element</td><td>is the element to multiply entry-wise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the return value of the times operation. </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#acee8bc36b405189c3be42b0ef2417625">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>.</p>

</div>
</div>
<a id="a90ee91a0f67930426467c8287b86f476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90ee91a0f67930426467c8287b86f476">&#9670;&nbsp;</a></span>Times() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt; <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::Times </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a> &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a multiplication operation and returns the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;element</td><td>is the element to multiply with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the multiplication. </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a12e87746e6b870e0e23c7196cd0d6e1d">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>.</p>

</div>
</div>
<a id="a90ef011a1f427c25add508227dcdda34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90ef011a1f427c25add508227dcdda34">&#9670;&nbsp;</a></span>Times() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt; <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::Times </td>
          <td>(</td>
          <td class="paramtype">const Integer &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scalar multiplication - multiply all entries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;element</td><td>is the element to multiply entry-wise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the return value of the times operation. </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1ILElement.html#ace67acbcf4ed67ce68a02e1565159af4">lbcrypto::ILElement&lt; DCRTPolyImpl&lt; VecType &gt;, VecType &gt;</a>.</p>

</div>
</div>
<a id="aab46382f79a885c1c1df2d5036795f77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab46382f79a885c1c1df2d5036795f77">&#9670;&nbsp;</a></span>Times() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt; <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::Times </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Integer &gt; &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scalar modular multiplication by an integer represented in CRT Basis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;element</td><td>is the element to multiply entry-wise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the return value of the times operation. </dd></dl>

</div>
</div>
<a id="a9d4f4516563a969449fa4ea833961264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d4f4516563a969449fa4ea833961264">&#9670;&nbsp;</a></span>Times() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyImpl</a>&lt; VecType &gt; <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::Times </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scalar multiplication by an integer represented in CRT Basis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;element</td><td>is the element to multiply entry-wise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the return value of the times operation. </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a8ede9b43e16d3baae6c37e796db1d86a">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>.</p>

</div>
</div>
<a id="aee610929568e5beb855316a0642365b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee610929568e5beb855316a0642365b3">&#9670;&nbsp;</a></span>Times() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a> <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::Times </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scalar multiplication - multiply by a signed integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;element</td><td>is the element to multiply entry-wise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the return value of the times operation. </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a0418bd87a1822e8f47b56ac4a8dbb560">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>.</p>

</div>
</div>
<a id="a35d2fdfaa1eafe1f0f42e380e5356afd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35d2fdfaa1eafe1f0f42e380e5356afd">&#9670;&nbsp;</a></span>Transpose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">DCRTPolyType</a> <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html">lbcrypto::DCRTPolyImpl</a>&lt; VecType &gt;::Transpose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transpose the ring element using the automorphism operation. </p>
<dl class="section return"><dt>Returns</dt><dd>is the result of the transposition. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/core/include/lattice/<a class="el" href="dcrtpoly_8h_source.html">dcrtpoly.h</a></li>
<li>src/core/lib/lattice/dcrtpoly.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Dec 15 2021 18:59:47 for PALISADE Lattice Crypto Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
