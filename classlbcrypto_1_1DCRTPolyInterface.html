<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PALISADE Lattice Crypto Library: lbcrypto::DCRTPolyInterface&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PALISADE Lattice Crypto Library
   &#160;<span id="projectnumber">1.11.5</span>
   </div>
   <div id="projectbrief">A lattice crypto library for software engineers by software engineers.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelbcrypto.html">lbcrypto</a></li><li class="navelem"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">DCRTPolyInterface</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classlbcrypto_1_1DCRTPolyInterface-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">lbcrypto::DCRTPolyInterface&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for lbcrypto::DCRTPolyInterface&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classlbcrypto_1_1DCRTPolyInterface__inherit__graph.png" border="0" usemap="#lbcrypto_1_1DCRTPolyInterface_3_01DerivedType_00_01BigVecType_00_01LilVecType_00_01RNSContainerType_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="lbcrypto_1_1DCRTPolyInterface_3_01DerivedType_00_01BigVecType_00_01LilVecType_00_01RNSContainerType_01_4_inherit__map" id="lbcrypto_1_1DCRTPolyInterface_3_01DerivedType_00_01BigVecType_00_01LilVecType_00_01RNSContainerType_01_4_inherit__map">
<area shape="rect" title=" " alt="" coords="5,169,243,225"/>
<area shape="rect" href="classlbcrypto_1_1ILElement.html" title=" " alt="" coords="23,80,225,121"/>
<area shape="rect" href="classlbcrypto_1_1Serializable.html" title="Base class for PALISADE serialization." alt="" coords="45,5,203,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for lbcrypto::DCRTPolyInterface&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classlbcrypto_1_1DCRTPolyInterface__coll__graph.png" border="0" usemap="#lbcrypto_1_1DCRTPolyInterface_3_01DerivedType_00_01BigVecType_00_01LilVecType_00_01RNSContainerType_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="lbcrypto_1_1DCRTPolyInterface_3_01DerivedType_00_01BigVecType_00_01LilVecType_00_01RNSContainerType_01_4_coll__map" id="lbcrypto_1_1DCRTPolyInterface_3_01DerivedType_00_01BigVecType_00_01LilVecType_00_01RNSContainerType_01_4_coll__map">
<area shape="rect" title=" " alt="" coords="537,46,775,102"/>
<area shape="rect" href="classlbcrypto_1_1ILElement.html" title=" " alt="" coords="213,5,416,47"/>
<area shape="rect" href="classlbcrypto_1_1Serializable.html" title="Base class for PALISADE serialization." alt="" coords="5,13,164,39"/>
<area shape="rect" title=" " alt="" coords="235,71,394,112"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a74dfeac425705028c00cad2ebd141417"><td class="memItemLeft" align="right" valign="top"><a id="a74dfeac425705028c00cad2ebd141417"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>BigIntType</b> = typename BigVecType::Integer</td></tr>
<tr class="separator:a74dfeac425705028c00cad2ebd141417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd98e3f4f38664fb55e89031a0ae527"><td class="memItemLeft" align="right" valign="top"><a id="a7cd98e3f4f38664fb55e89031a0ae527"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Params</b> = <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">ILDCRTParams</a>&lt; BigIntType &gt;</td></tr>
<tr class="separator:a7cd98e3f4f38664fb55e89031a0ae527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8d7bac4f3bb9d538d175ea4a3f72d42"><td class="memItemLeft" align="right" valign="top"><a id="aa8d7bac4f3bb9d538d175ea4a3f72d42"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>LilIntType</b> = typename LilVecType::Integer</td></tr>
<tr class="separator:aa8d7bac4f3bb9d538d175ea4a3f72d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6115a3c9848efe0e7eb0f03a571ab62"><td class="memItemLeft" align="right" valign="top"><a id="ad6115a3c9848efe0e7eb0f03a571ab62"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>TowerType</b> = RNSContainerType&lt; LilVecType &gt;</td></tr>
<tr class="separator:ad6115a3c9848efe0e7eb0f03a571ab62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb5c47ff7d9e720e63ce9813a3548ce5"><td class="memItemLeft" align="right" valign="top"><a id="acb5c47ff7d9e720e63ce9813a3548ce5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>PolyLargeType</b> = <a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyImpl</a>&lt; BigVecType &gt;</td></tr>
<tr class="separator:acb5c47ff7d9e720e63ce9813a3548ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5560043bd7a46c9fead585f179e9620"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">DCRTPolyInterface</a>&lt; DerivedType, BigVecType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#aa5560043bd7a46c9fead585f179e9620">DCRTPolyInterfaceType</a></td></tr>
<tr class="memdesc:aa5560043bd7a46c9fead585f179e9620"><td class="mdescLeft">&#160;</td><td class="mdescRight">Probably not going to use this, in lieu of.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#aa5560043bd7a46c9fead585f179e9620">More...</a><br /></td></tr>
<tr class="separator:aa5560043bd7a46c9fead585f179e9620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a838ed13093d8b6db3dec4f01c86b59b5"><td class="memItemLeft" align="right" valign="top"><a id="a838ed13093d8b6db3dec4f01c86b59b5"></a>
typedef <a class="el" href="classlbcrypto_1_1DiscreteGaussianGeneratorImpl.html">DiscreteGaussianGeneratorImpl</a>&lt; LilVecType &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>DggType</b></td></tr>
<tr class="separator:a838ed13093d8b6db3dec4f01c86b59b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b4241230f64810b01f918979298c9f"><td class="memItemLeft" align="right" valign="top"><a id="a96b4241230f64810b01f918979298c9f"></a>
typedef <a class="el" href="classlbcrypto_1_1DiscreteUniformGeneratorImpl.html">DiscreteUniformGeneratorImpl</a>&lt; LilVecType &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>DugType</b></td></tr>
<tr class="separator:a96b4241230f64810b01f918979298c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf6855d43cd97e1b381f61846981b0ed"><td class="memItemLeft" align="right" valign="top"><a id="aaf6855d43cd97e1b381f61846981b0ed"></a>
typedef <a class="el" href="classlbcrypto_1_1TernaryUniformGeneratorImpl.html">TernaryUniformGeneratorImpl</a>&lt; LilVecType &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>TugType</b></td></tr>
<tr class="separator:aaf6855d43cd97e1b381f61846981b0ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3cd3ddea172baab0ba6c82c903b7483"><td class="memItemLeft" align="right" valign="top"><a id="aa3cd3ddea172baab0ba6c82c903b7483"></a>
typedef <a class="el" href="classlbcrypto_1_1BinaryUniformGeneratorImpl.html">BinaryUniformGeneratorImpl</a>&lt; LilVecType &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>BugType</b></td></tr>
<tr class="separator:aa3cd3ddea172baab0ba6c82c903b7483"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6cdf654d89986d28366885e364d80080"><td class="memItemLeft" align="right" valign="top">DerivedType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a6cdf654d89986d28366885e364d80080">GetDerived</a> ()</td></tr>
<tr class="memdesc:a6cdf654d89986d28366885e364d80080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Derived object, this is apart of the CRTP software design pattern it allows the base class (this one) to implement methods that call the derived objects implementation.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a6cdf654d89986d28366885e364d80080">More...</a><br /></td></tr>
<tr class="separator:a6cdf654d89986d28366885e364d80080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d67b375b98e88fb78392f2d214d5458"><td class="memItemLeft" align="right" valign="top">const DerivedType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a4d67b375b98e88fb78392f2d214d5458">GetDerived</a> () const</td></tr>
<tr class="separator:a4d67b375b98e88fb78392f2d214d5458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93098716b9e5257d512764efa43b2977"><td class="memItemLeft" align="right" valign="top"><a id="a93098716b9e5257d512764efa43b2977"></a>
virtual const DerivedType &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const TowerType &amp;element)=0</td></tr>
<tr class="separator:a93098716b9e5257d512764efa43b2977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a122a57c82a7aa913148ef673fdfb74aa"><td class="memItemLeft" align="right" valign="top">virtual DerivedType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a122a57c82a7aa913148ef673fdfb74aa">CloneTowers</a> (uint32_t startTower, uint32_t endTower) const =0</td></tr>
<tr class="memdesc:a122a57c82a7aa913148ef673fdfb74aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a copy of the DCRTPoly, but it includes only a sequential subset of the towers that the original holds.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a122a57c82a7aa913148ef673fdfb74aa">More...</a><br /></td></tr>
<tr class="separator:a122a57c82a7aa913148ef673fdfb74aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8aaf7680a031550d84687c9d9c0ae1a"><td class="memItemLeft" align="right" valign="top">const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#ac8aaf7680a031550d84687c9d9c0ae1a">GetParams</a> () const</td></tr>
<tr class="memdesc:ac8aaf7680a031550d84687c9d9c0ae1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the parameters of the element.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#ac8aaf7680a031550d84687c9d9c0ae1a">More...</a><br /></td></tr>
<tr class="separator:ac8aaf7680a031550d84687c9d9c0ae1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c59a54a3117891aaf660f5d2f0bea2"><td class="memItemLeft" align="right" valign="top">virtual usint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a40c59a54a3117891aaf660f5d2f0bea2">GetCyclotomicOrder</a> () const</td></tr>
<tr class="memdesc:a40c59a54a3117891aaf660f5d2f0bea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the element's cyclotomic order  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a40c59a54a3117891aaf660f5d2f0bea2">More...</a><br /></td></tr>
<tr class="separator:a40c59a54a3117891aaf660f5d2f0bea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20fe813cfd6a8f469a5f585d9b1adc42"><td class="memItemLeft" align="right" valign="top">virtual usint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a20fe813cfd6a8f469a5f585d9b1adc42">GetRingDimension</a> () const</td></tr>
<tr class="memdesc:a20fe813cfd6a8f469a5f585d9b1adc42"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the element's ring dimension  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a20fe813cfd6a8f469a5f585d9b1adc42">More...</a><br /></td></tr>
<tr class="separator:a20fe813cfd6a8f469a5f585d9b1adc42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20af925ea09544588f834f8021d68f9a"><td class="memItemLeft" align="right" valign="top">const BigIntType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a20af925ea09544588f834f8021d68f9a">GetModulus</a> () const</td></tr>
<tr class="memdesc:a20af925ea09544588f834f8021d68f9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the element's modulus  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a20af925ea09544588f834f8021d68f9a">More...</a><br /></td></tr>
<tr class="separator:a20af925ea09544588f834f8021d68f9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a131ad02f83ced06622e6d8e00fb6c2"><td class="memItemLeft" align="right" valign="top">const BigIntType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a5a131ad02f83ced06622e6d8e00fb6c2">GetOriginalModulus</a> () const</td></tr>
<tr class="memdesc:a5a131ad02f83ced06622e6d8e00fb6c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the element's original modulus, derived from Poly  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a5a131ad02f83ced06622e6d8e00fb6c2">More...</a><br /></td></tr>
<tr class="separator:a5a131ad02f83ced06622e6d8e00fb6c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c943dd0618aeb63c915250be84c10cd"><td class="memItemLeft" align="right" valign="top">virtual const BigIntType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a0c943dd0618aeb63c915250be84c10cd">GetRootOfUnity</a> () const</td></tr>
<tr class="memdesc:a0c943dd0618aeb63c915250be84c10cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the element's root of unity.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a0c943dd0618aeb63c915250be84c10cd">More...</a><br /></td></tr>
<tr class="separator:a0c943dd0618aeb63c915250be84c10cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add0c94d87832fec8fa4c2c60aa1fd23e"><td class="memItemLeft" align="right" valign="top">virtual usint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#add0c94d87832fec8fa4c2c60aa1fd23e">GetLength</a> () const</td></tr>
<tr class="memdesc:add0c94d87832fec8fa4c2c60aa1fd23e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get method for length of each component element. NOTE assumes all components are the same size. (Ring Dimension)  <a href="classlbcrypto_1_1DCRTPolyInterface.html#add0c94d87832fec8fa4c2c60aa1fd23e">More...</a><br /></td></tr>
<tr class="separator:add0c94d87832fec8fa4c2c60aa1fd23e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c801b6fd516206b274d90163dd4bf1"><td class="memItemLeft" align="right" valign="top">virtual BigIntType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a51c801b6fd516206b274d90163dd4bf1">at</a> (usint i)=0</td></tr>
<tr class="memdesc:a51c801b6fd516206b274d90163dd4bf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get interpolated value of elements at all tower index i. Note this operation is computationally intense. Does bound checking.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a51c801b6fd516206b274d90163dd4bf1">More...</a><br /></td></tr>
<tr class="separator:a51c801b6fd516206b274d90163dd4bf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2657dee1a19e6107276015dd958386c9"><td class="memItemLeft" align="right" valign="top"><a id="a2657dee1a19e6107276015dd958386c9"></a>
virtual const BigIntType &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>at</b> (usint i) const =0</td></tr>
<tr class="separator:a2657dee1a19e6107276015dd958386c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02b0f63b9b363fe509e449ca9fe9e24f"><td class="memItemLeft" align="right" valign="top">virtual BigIntType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a02b0f63b9b363fe509e449ca9fe9e24f">operator[]</a> (usint i)=0</td></tr>
<tr class="memdesc:a02b0f63b9b363fe509e449ca9fe9e24f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get interpolated value of element at index i. Note this operation is computationally intense. No bound checking.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a02b0f63b9b363fe509e449ca9fe9e24f">More...</a><br /></td></tr>
<tr class="separator:a02b0f63b9b363fe509e449ca9fe9e24f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9218984d8019fb69eb9c3f48da70cab"><td class="memItemLeft" align="right" valign="top"><a id="ad9218984d8019fb69eb9c3f48da70cab"></a>
virtual const BigIntType &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (usint i) const =0</td></tr>
<tr class="separator:ad9218984d8019fb69eb9c3f48da70cab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f373c9110cff8599393a6fc47390bb"><td class="memItemLeft" align="right" valign="top">virtual usint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a66f373c9110cff8599393a6fc47390bb">GetNumOfElements</a> () const =0</td></tr>
<tr class="memdesc:a66f373c9110cff8599393a6fc47390bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get method of the number of component elements, also known as the number of towers.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a66f373c9110cff8599393a6fc47390bb">More...</a><br /></td></tr>
<tr class="separator:a66f373c9110cff8599393a6fc47390bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d5dbd1bbfb043b71fa773b9d3f7f08"><td class="memItemLeft" align="right" valign="top">virtual const std::vector&lt; TowerType &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a93d5dbd1bbfb043b71fa773b9d3f7f08">GetAllElements</a> () const =0</td></tr>
<tr class="memdesc:a93d5dbd1bbfb043b71fa773b9d3f7f08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get method that returns a vector of all component elements.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a93d5dbd1bbfb043b71fa773b9d3f7f08">More...</a><br /></td></tr>
<tr class="separator:a93d5dbd1bbfb043b71fa773b9d3f7f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b5764dee7d4a77f0a8832d94ba37f5"><td class="memItemLeft" align="right" valign="top">virtual Format&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a09b5764dee7d4a77f0a8832d94ba37f5">GetFormat</a> () const</td></tr>
<tr class="memdesc:a09b5764dee7d4a77f0a8832d94ba37f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get method of the format.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a09b5764dee7d4a77f0a8832d94ba37f5">More...</a><br /></td></tr>
<tr class="separator:a09b5764dee7d4a77f0a8832d94ba37f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af494504657264b13c00a15bc27810dba"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; DerivedType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#af494504657264b13c00a15bc27810dba">BaseDecompose</a> (usint baseBits, bool evalModeAnswer) const =0</td></tr>
<tr class="memdesc:af494504657264b13c00a15bc27810dba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the element as <img class="formulaInl" alt="$ \sum\limits{i=0}^{\lfloor {\log q/base} \rfloor} {(base^i u_i)} $" src="form_0.png"/> and return the vector of <img class="formulaInl" alt="$ \left\{u_0, u_1,...,u_{\lfloor {\log q/base} \rfloor} \right\} \in R_{{base}^{\lceil {\log q/base} \rceil}} $" src="form_1.png"/>; This is used as a subroutine in the relinearization procedure.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#af494504657264b13c00a15bc27810dba">More...</a><br /></td></tr>
<tr class="separator:af494504657264b13c00a15bc27810dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15120f3c80902a9a3e8fa080d23bd484"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; DerivedType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a15120f3c80902a9a3e8fa080d23bd484">PowersOfBase</a> (usint baseBits) const =0</td></tr>
<tr class="memdesc:a15120f3c80902a9a3e8fa080d23bd484"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a vector of <a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyImpl</a>'s as <img class="formulaInl" alt="$ \left\{x, {base}*x, {base}^2*x, ..., {base}^{\lfloor {\log q/{base}} \rfloor} \right\}*x $" src="form_3.png"/>, where <img class="formulaInl" alt="$ x $" src="form_4.png"/> is the current <a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyImpl</a> object; used as a subroutine in the relinearization procedure to get powers of a certain "base" for the secret key element.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a15120f3c80902a9a3e8fa080d23bd484">More...</a><br /></td></tr>
<tr class="separator:a15120f3c80902a9a3e8fa080d23bd484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa5771dde254b6445a252714933504bb"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; DerivedType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#afa5771dde254b6445a252714933504bb">CRTDecompose</a> (uint32_t baseBits=0) const =0</td></tr>
<tr class="separator:afa5771dde254b6445a252714933504bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c3acffd584a927600c188a32626b7c5"><td class="memItemLeft" align="right" valign="top">virtual const DerivedType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a6c3acffd584a927600c188a32626b7c5">operator=</a> (const DerivedType &amp;rhs)=0</td></tr>
<tr class="memdesc:a6c3acffd584a927600c188a32626b7c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment Operator.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a6c3acffd584a927600c188a32626b7c5">More...</a><br /></td></tr>
<tr class="separator:a6c3acffd584a927600c188a32626b7c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b97ec6ea90493c8c4ef7e77bf7f4800"><td class="memItemLeft" align="right" valign="top">virtual const DerivedType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a7b97ec6ea90493c8c4ef7e77bf7f4800">operator=</a> (DerivedType &amp;&amp;rhs)=0</td></tr>
<tr class="memdesc:a7b97ec6ea90493c8c4ef7e77bf7f4800"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move Assignment Operator.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a7b97ec6ea90493c8c4ef7e77bf7f4800">More...</a><br /></td></tr>
<tr class="separator:a7b97ec6ea90493c8c4ef7e77bf7f4800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c21084ea80bc73c22800792f78efa26"><td class="memItemLeft" align="right" valign="top">virtual DerivedType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a3c21084ea80bc73c22800792f78efa26">operator=</a> (std::initializer_list&lt; uint64_t &gt; rhs)=0</td></tr>
<tr class="memdesc:a3c21084ea80bc73c22800792f78efa26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initalizer list.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a3c21084ea80bc73c22800792f78efa26">More...</a><br /></td></tr>
<tr class="separator:a3c21084ea80bc73c22800792f78efa26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa510d16766774ae7e15c52f08db2b82"><td class="memItemLeft" align="right" valign="top">virtual DerivedType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#afa510d16766774ae7e15c52f08db2b82">operator=</a> (uint64_t val)=0</td></tr>
<tr class="memdesc:afa510d16766774ae7e15c52f08db2b82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment Operator. The usint val will be set at index zero and all other indices will be set to zero.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#afa510d16766774ae7e15c52f08db2b82">More...</a><br /></td></tr>
<tr class="separator:afa510d16766774ae7e15c52f08db2b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ecc645e7b55894a3f94280b41e9f982"><td class="memItemLeft" align="right" valign="top">virtual DerivedType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a2ecc645e7b55894a3f94280b41e9f982">operator=</a> (const std::vector&lt; int64_t &gt; &amp;rhs)=0</td></tr>
<tr class="memdesc:a2ecc645e7b55894a3f94280b41e9f982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a Poly from a vector of signed integers (used for trapdoor sampling)  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a2ecc645e7b55894a3f94280b41e9f982">More...</a><br /></td></tr>
<tr class="separator:a2ecc645e7b55894a3f94280b41e9f982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cfedcf2b29c343daf88b24a3c52613d"><td class="memItemLeft" align="right" valign="top">virtual DerivedType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a0cfedcf2b29c343daf88b24a3c52613d">operator=</a> (const std::vector&lt; int32_t &gt; &amp;rhs)=0</td></tr>
<tr class="memdesc:a0cfedcf2b29c343daf88b24a3c52613d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a Poly from a vector of signed integers (used for trapdoor sampling)  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a0cfedcf2b29c343daf88b24a3c52613d">More...</a><br /></td></tr>
<tr class="separator:a0cfedcf2b29c343daf88b24a3c52613d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af06c30c5d62fb3b177a9eecacc1e7e0e"><td class="memItemLeft" align="right" valign="top">virtual DerivedType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#af06c30c5d62fb3b177a9eecacc1e7e0e">operator=</a> (std::initializer_list&lt; std::string &gt; rhs)=0</td></tr>
<tr class="memdesc:af06c30c5d62fb3b177a9eecacc1e7e0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initalizer list.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#af06c30c5d62fb3b177a9eecacc1e7e0e">More...</a><br /></td></tr>
<tr class="separator:af06c30c5d62fb3b177a9eecacc1e7e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98d4c5817cba2c2b2b9188c05870e39f"><td class="memItemLeft" align="right" valign="top">virtual DerivedType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a98d4c5817cba2c2b2b9188c05870e39f">operator-</a> () const =0</td></tr>
<tr class="memdesc:a98d4c5817cba2c2b2b9188c05870e39f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary minus on a element.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a98d4c5817cba2c2b2b9188c05870e39f">More...</a><br /></td></tr>
<tr class="separator:a98d4c5817cba2c2b2b9188c05870e39f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a845271828e9e902a65840752b3fdcc16"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a845271828e9e902a65840752b3fdcc16">operator==</a> (const DerivedType &amp;rhs) const =0</td></tr>
<tr class="memdesc:a845271828e9e902a65840752b3fdcc16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a845271828e9e902a65840752b3fdcc16">More...</a><br /></td></tr>
<tr class="separator:a845271828e9e902a65840752b3fdcc16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a126c7febc3ab3bc45522ef94bf835e7c"><td class="memItemLeft" align="right" valign="top">virtual const DerivedType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a126c7febc3ab3bc45522ef94bf835e7c">operator+=</a> (const DerivedType &amp;rhs)=0</td></tr>
<tr class="memdesc:a126c7febc3ab3bc45522ef94bf835e7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an entry-wise addition over all elements of each tower with the towers of the element on the right hand side.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a126c7febc3ab3bc45522ef94bf835e7c">More...</a><br /></td></tr>
<tr class="separator:a126c7febc3ab3bc45522ef94bf835e7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06ac6a37ad6be0a9055cb9dbedd2a9bc"><td class="memItemLeft" align="right" valign="top">virtual const DerivedType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a06ac6a37ad6be0a9055cb9dbedd2a9bc">operator-=</a> (const DerivedType &amp;rhs)=0</td></tr>
<tr class="memdesc:a06ac6a37ad6be0a9055cb9dbedd2a9bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an entry-wise subtraction over all elements of each tower with the towers of the element on the right hand side.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a06ac6a37ad6be0a9055cb9dbedd2a9bc">More...</a><br /></td></tr>
<tr class="separator:a06ac6a37ad6be0a9055cb9dbedd2a9bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a703db5691aa73e9b2988b07376017219"><td class="memItemLeft" align="right" valign="top">virtual DerivedType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a703db5691aa73e9b2988b07376017219">AutomorphismTransform</a> (const usint &amp;i) const =0</td></tr>
<tr class="memdesc:a703db5691aa73e9b2988b07376017219"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permutes coefficients in a polynomial. Moves the ith index to the first one, it only supports odd indices.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a703db5691aa73e9b2988b07376017219">More...</a><br /></td></tr>
<tr class="separator:a703db5691aa73e9b2988b07376017219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5805c88f6af7bb50febbfe8d436298ab"><td class="memItemLeft" align="right" valign="top">virtual DerivedType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a5805c88f6af7bb50febbfe8d436298ab">AutomorphismTransform</a> (usint i, const std::vector&lt; usint &gt; &amp;map) const =0</td></tr>
<tr class="memdesc:a5805c88f6af7bb50febbfe8d436298ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an automorphism transform operation using precomputed bit reversal indices.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a5805c88f6af7bb50febbfe8d436298ab">More...</a><br /></td></tr>
<tr class="separator:a5805c88f6af7bb50febbfe8d436298ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77fa4c8b73acda9b59dc034519d592db"><td class="memItemLeft" align="right" valign="top">virtual DerivedType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a77fa4c8b73acda9b59dc034519d592db">Transpose</a> () const</td></tr>
<tr class="memdesc:a77fa4c8b73acda9b59dc034519d592db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose the ring element using the automorphism operation.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a77fa4c8b73acda9b59dc034519d592db">More...</a><br /></td></tr>
<tr class="separator:a77fa4c8b73acda9b59dc034519d592db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c1193a99a15b71b7eb3b544b53b827e"><td class="memItemLeft" align="right" valign="top">virtual DerivedType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a0c1193a99a15b71b7eb3b544b53b827e">Plus</a> (const DerivedType &amp;element) const =0</td></tr>
<tr class="memdesc:a0c1193a99a15b71b7eb3b544b53b827e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an addition operation and returns the result.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a0c1193a99a15b71b7eb3b544b53b827e">More...</a><br /></td></tr>
<tr class="separator:a0c1193a99a15b71b7eb3b544b53b827e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e87746e6b870e0e23c7196cd0d6e1d"><td class="memItemLeft" align="right" valign="top">virtual DerivedType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a12e87746e6b870e0e23c7196cd0d6e1d">Times</a> (const DerivedType &amp;element) const =0</td></tr>
<tr class="memdesc:a12e87746e6b870e0e23c7196cd0d6e1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a multiplication operation and returns the result.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a12e87746e6b870e0e23c7196cd0d6e1d">More...</a><br /></td></tr>
<tr class="separator:a12e87746e6b870e0e23c7196cd0d6e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ec584b5d32386e4f3682bb8a386aa6b"><td class="memItemLeft" align="right" valign="top">virtual DerivedType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a3ec584b5d32386e4f3682bb8a386aa6b">Minus</a> (const DerivedType &amp;element) const =0</td></tr>
<tr class="memdesc:a3ec584b5d32386e4f3682bb8a386aa6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a subtraction operation and returns the result.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a3ec584b5d32386e4f3682bb8a386aa6b">More...</a><br /></td></tr>
<tr class="separator:a3ec584b5d32386e4f3682bb8a386aa6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca7c97cd5997160bf1542c7310b66a01"><td class="memItemLeft" align="right" valign="top">virtual DerivedType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#aca7c97cd5997160bf1542c7310b66a01">Plus</a> (const BigIntType &amp;element) const =0</td></tr>
<tr class="memdesc:aca7c97cd5997160bf1542c7310b66a01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar addition - add an element to the first index of each tower.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#aca7c97cd5997160bf1542c7310b66a01">More...</a><br /></td></tr>
<tr class="separator:aca7c97cd5997160bf1542c7310b66a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8653434b7b187397033f19812921785"><td class="memItemLeft" align="right" valign="top">virtual DerivedType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#ad8653434b7b187397033f19812921785">Plus</a> (const vector&lt; BigIntType &gt; &amp;element) const =0</td></tr>
<tr class="memdesc:ad8653434b7b187397033f19812921785"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar addition for elements in CRT format. CRT elements are represented as vector of integer elements which correspond to the represented number modulo the primes in the tower chain (in same order).  <a href="classlbcrypto_1_1DCRTPolyInterface.html#ad8653434b7b187397033f19812921785">More...</a><br /></td></tr>
<tr class="separator:ad8653434b7b187397033f19812921785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dfadd41ee3fc03df8375b1548e619ec"><td class="memItemLeft" align="right" valign="top">virtual DerivedType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a1dfadd41ee3fc03df8375b1548e619ec">Minus</a> (const BigIntType &amp;element) const =0</td></tr>
<tr class="memdesc:a1dfadd41ee3fc03df8375b1548e619ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar subtraction - subtract an element to all entries.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a1dfadd41ee3fc03df8375b1548e619ec">More...</a><br /></td></tr>
<tr class="separator:a1dfadd41ee3fc03df8375b1548e619ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acebbf62af47212eb1ff94d727924ee98"><td class="memItemLeft" align="right" valign="top">virtual DerivedType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#acebbf62af47212eb1ff94d727924ee98">Minus</a> (const vector&lt; BigIntType &gt; &amp;element) const =0</td></tr>
<tr class="memdesc:acebbf62af47212eb1ff94d727924ee98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar subtraction for elements in CRT format. CRT elements are represented as vector of integer elements which correspond to the represented number modulo the primes in the tower chain (in same order).  <a href="classlbcrypto_1_1DCRTPolyInterface.html#acebbf62af47212eb1ff94d727924ee98">More...</a><br /></td></tr>
<tr class="separator:acebbf62af47212eb1ff94d727924ee98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe20fce440768599da3a2edeb27ced9f"><td class="memItemLeft" align="right" valign="top">virtual DerivedType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#abe20fce440768599da3a2edeb27ced9f">Times</a> (const BigIntType &amp;element) const =0</td></tr>
<tr class="memdesc:abe20fce440768599da3a2edeb27ced9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar multiplication - multiply all entries.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#abe20fce440768599da3a2edeb27ced9f">More...</a><br /></td></tr>
<tr class="separator:abe20fce440768599da3a2edeb27ced9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acee8bc36b405189c3be42b0ef2417625"><td class="memItemLeft" align="right" valign="top">virtual DerivedType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#acee8bc36b405189c3be42b0ef2417625">Times</a> (bigintnat::NativeInteger::SignedNativeInt element) const =0</td></tr>
<tr class="memdesc:acee8bc36b405189c3be42b0ef2417625"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar multiplication - multiply by a signed integer.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#acee8bc36b405189c3be42b0ef2417625">More...</a><br /></td></tr>
<tr class="separator:acee8bc36b405189c3be42b0ef2417625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0418bd87a1822e8f47b56ac4a8dbb560"><td class="memItemLeft" align="right" valign="top">virtual DerivedType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a0418bd87a1822e8f47b56ac4a8dbb560">Times</a> (int64_t element) const =0</td></tr>
<tr class="memdesc:a0418bd87a1822e8f47b56ac4a8dbb560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar multiplication - multiply by a signed integer.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a0418bd87a1822e8f47b56ac4a8dbb560">More...</a><br /></td></tr>
<tr class="separator:a0418bd87a1822e8f47b56ac4a8dbb560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ede9b43e16d3baae6c37e796db1d86a"><td class="memItemLeft" align="right" valign="top">virtual DerivedType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a8ede9b43e16d3baae6c37e796db1d86a">Times</a> (const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;element) const =0</td></tr>
<tr class="memdesc:a8ede9b43e16d3baae6c37e796db1d86a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar multiplication by an integer represented in CRT Basis.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a8ede9b43e16d3baae6c37e796db1d86a">More...</a><br /></td></tr>
<tr class="separator:a8ede9b43e16d3baae6c37e796db1d86a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6fd62f7cc5222c6ab8719f0d5a2c8c1"><td class="memItemLeft" align="right" valign="top">virtual DerivedType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#ad6fd62f7cc5222c6ab8719f0d5a2c8c1">Times</a> (const std::vector&lt; BigIntType &gt; &amp;element) const =0</td></tr>
<tr class="memdesc:ad6fd62f7cc5222c6ab8719f0d5a2c8c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar modular multiplication by an integer represented in CRT Basis.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#ad6fd62f7cc5222c6ab8719f0d5a2c8c1">More...</a><br /></td></tr>
<tr class="separator:ad6fd62f7cc5222c6ab8719f0d5a2c8c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c299cc747f5176cdf79912089e0238d"><td class="memItemLeft" align="right" valign="top">virtual DerivedType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a9c299cc747f5176cdf79912089e0238d">MultiplyAndRound</a> (const BigIntType &amp;p, const BigIntType &amp;q) const</td></tr>
<tr class="memdesc:a9c299cc747f5176cdf79912089e0238d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar multiplication followed by division and rounding operation - operation on all entries.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a9c299cc747f5176cdf79912089e0238d">More...</a><br /></td></tr>
<tr class="separator:a9c299cc747f5176cdf79912089e0238d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a509bf1d5399f63247aa1af0aa1ebd4df"><td class="memItemLeft" align="right" valign="top">virtual DerivedType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a509bf1d5399f63247aa1af0aa1ebd4df">DivideAndRound</a> (const BigIntType &amp;q) const</td></tr>
<tr class="memdesc:a509bf1d5399f63247aa1af0aa1ebd4df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar division followed by rounding operation - operation on all entries.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a509bf1d5399f63247aa1af0aa1ebd4df">More...</a><br /></td></tr>
<tr class="separator:a509bf1d5399f63247aa1af0aa1ebd4df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6975f0cd6039ceeb1a4ad954519954f2"><td class="memItemLeft" align="right" valign="top">virtual DerivedType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a6975f0cd6039ceeb1a4ad954519954f2">Negate</a> () const =0</td></tr>
<tr class="memdesc:a6975f0cd6039ceeb1a4ad954519954f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a negation operation and returns the result.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a6975f0cd6039ceeb1a4ad954519954f2">More...</a><br /></td></tr>
<tr class="separator:a6975f0cd6039ceeb1a4ad954519954f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb429befd3061e3283b65cc0a5cadf2"><td class="memItemLeft" align="right" valign="top"><a id="a3eb429befd3061e3283b65cc0a5cadf2"></a>
virtual const DerivedType &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator+=</b> (const BigIntType &amp;element)=0</td></tr>
<tr class="separator:a3eb429befd3061e3283b65cc0a5cadf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae624e9a0fb904bdee4c7b536e12d6808"><td class="memItemLeft" align="right" valign="top">virtual const DerivedType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#ae624e9a0fb904bdee4c7b536e12d6808">operator-=</a> (const BigIntType &amp;element)=0</td></tr>
<tr class="memdesc:ae624e9a0fb904bdee4c7b536e12d6808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a subtraction operation and returns the result.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#ae624e9a0fb904bdee4c7b536e12d6808">More...</a><br /></td></tr>
<tr class="separator:ae624e9a0fb904bdee4c7b536e12d6808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a649ce1d2b14105bd41e6a33caf7912a2"><td class="memItemLeft" align="right" valign="top">virtual const DerivedType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a649ce1d2b14105bd41e6a33caf7912a2">operator*=</a> (const BigIntType &amp;element)=0</td></tr>
<tr class="memdesc:a649ce1d2b14105bd41e6a33caf7912a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a multiplication operation and returns the result.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a649ce1d2b14105bd41e6a33caf7912a2">More...</a><br /></td></tr>
<tr class="separator:a649ce1d2b14105bd41e6a33caf7912a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc908662a421a5f61b9d555cf4feaa51"><td class="memItemLeft" align="right" valign="top">virtual const DerivedType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#afc908662a421a5f61b9d555cf4feaa51">operator*=</a> (const DerivedType &amp;element)=0</td></tr>
<tr class="memdesc:afc908662a421a5f61b9d555cf4feaa51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an multiplication operation and returns the result.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#afc908662a421a5f61b9d555cf4feaa51">More...</a><br /></td></tr>
<tr class="separator:afc908662a421a5f61b9d555cf4feaa51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a68eccc6f73da3f18aa3d493db9209d"><td class="memItemLeft" align="right" valign="top">virtual TowerType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a8a68eccc6f73da3f18aa3d493db9209d">ElementAtIndex</a> (usint i)=0</td></tr>
<tr class="memdesc:a8a68eccc6f73da3f18aa3d493db9209d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get value of element at index i.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a8a68eccc6f73da3f18aa3d493db9209d">More...</a><br /></td></tr>
<tr class="separator:a8a68eccc6f73da3f18aa3d493db9209d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1426c1b052a5ae4b9ccc1b0d738dec1"><td class="memItemLeft" align="right" valign="top">virtual DerivedType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#aa1426c1b052a5ae4b9ccc1b0d738dec1">MultiplicativeInverse</a> () const =0</td></tr>
<tr class="memdesc:aa1426c1b052a5ae4b9ccc1b0d738dec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a multiplicative inverse operation and returns the result.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#aa1426c1b052a5ae4b9ccc1b0d738dec1">More...</a><br /></td></tr>
<tr class="separator:aa1426c1b052a5ae4b9ccc1b0d738dec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad10296261f590b69a2efd23a6b57e698"><td class="memItemLeft" align="right" valign="top">virtual DerivedType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#ad10296261f590b69a2efd23a6b57e698">ModByTwo</a> () const</td></tr>
<tr class="memdesc:ad10296261f590b69a2efd23a6b57e698"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a modulus by 2 operation. Returns the least significant bit.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#ad10296261f590b69a2efd23a6b57e698">More...</a><br /></td></tr>
<tr class="separator:ad10296261f590b69a2efd23a6b57e698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae234c1d7db46ab3ed963d0ef1257d39b"><td class="memItemLeft" align="right" valign="top">virtual DerivedType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#ae234c1d7db46ab3ed963d0ef1257d39b">Mod</a> (const BigIntType &amp;modulus) const</td></tr>
<tr class="memdesc:ae234c1d7db46ab3ed963d0ef1257d39b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modulus - perform a modulus operation. Does proper mapping of [-modulus/2, modulus/2) to [0, modulus)  <a href="classlbcrypto_1_1DCRTPolyInterface.html#ae234c1d7db46ab3ed963d0ef1257d39b">More...</a><br /></td></tr>
<tr class="separator:ae234c1d7db46ab3ed963d0ef1257d39b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af35691c5c689c9804b87ad18e08269ba"><td class="memItemLeft" align="right" valign="top">virtual const BigVecType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#af35691c5c689c9804b87ad18e08269ba">GetValues</a> () const</td></tr>
<tr class="memdesc:af35691c5c689c9804b87ad18e08269ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get method that should not be used.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#af35691c5c689c9804b87ad18e08269ba">More...</a><br /></td></tr>
<tr class="separator:af35691c5c689c9804b87ad18e08269ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1288c458ea53efc64df24b1162b35ddc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a1288c458ea53efc64df24b1162b35ddc">SetValues</a> (const BigVecType &amp;values, Format format)</td></tr>
<tr class="memdesc:a1288c458ea53efc64df24b1162b35ddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set method that should not be used, will throw an error.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a1288c458ea53efc64df24b1162b35ddc">More...</a><br /></td></tr>
<tr class="separator:a1288c458ea53efc64df24b1162b35ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62144e300a0691110a99511b9f21617b"><td class="memItemLeft" align="right" valign="top">virtual const TowerType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a62144e300a0691110a99511b9f21617b">GetElementAtIndex</a> (usint i) const =0</td></tr>
<tr class="memdesc:a62144e300a0691110a99511b9f21617b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get method of individual tower of elements. Note this behavior is different than poly.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a62144e300a0691110a99511b9f21617b">More...</a><br /></td></tr>
<tr class="separator:a62144e300a0691110a99511b9f21617b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e661fe12826ed9369943c5d8aec138"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#af0e661fe12826ed9369943c5d8aec138">SetElementAtIndex</a> (usint index, const TowerType &amp;element)=0</td></tr>
<tr class="memdesc:af0e661fe12826ed9369943c5d8aec138"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets element at index.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#af0e661fe12826ed9369943c5d8aec138">More...</a><br /></td></tr>
<tr class="separator:af0e661fe12826ed9369943c5d8aec138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6d970d2568f0f712d39d20021eee2d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a5b6d970d2568f0f712d39d20021eee2d">SetElementAtIndex</a> (usint index, TowerType &amp;&amp;element)=0</td></tr>
<tr class="memdesc:a5b6d970d2568f0f712d39d20021eee2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets element at index.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a5b6d970d2568f0f712d39d20021eee2d">More...</a><br /></td></tr>
<tr class="separator:a5b6d970d2568f0f712d39d20021eee2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0d32ffc802d1a6a8302cc4d5672512d"><td class="memItemLeft" align="right" valign="top"><a id="af0d32ffc802d1a6a8302cc4d5672512d"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#af0d32ffc802d1a6a8302cc4d5672512d">SetValuesToZero</a> ()=0</td></tr>
<tr class="memdesc:af0d32ffc802d1a6a8302cc4d5672512d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all values of element to zero. <br /></td></tr>
<tr class="separator:af0d32ffc802d1a6a8302cc4d5672512d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41e9b4c79355ba9aee56e62f6e5422fd"><td class="memItemLeft" align="right" valign="top"><a id="a41e9b4c79355ba9aee56e62f6e5422fd"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a41e9b4c79355ba9aee56e62f6e5422fd">AddILElementOne</a> ()=0</td></tr>
<tr class="memdesc:a41e9b4c79355ba9aee56e62f6e5422fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds "1" to every entry in every tower. <br /></td></tr>
<tr class="separator:a41e9b4c79355ba9aee56e62f6e5422fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec031b96c902996ebb986097e7919442"><td class="memItemLeft" align="right" valign="top">virtual DerivedType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#aec031b96c902996ebb986097e7919442">AddRandomNoise</a> (const BigIntType &amp;modulus) const</td></tr>
<tr class="memdesc:aec031b96c902996ebb986097e7919442"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add uniformly random values to all components except for the first one.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#aec031b96c902996ebb986097e7919442">More...</a><br /></td></tr>
<tr class="separator:aec031b96c902996ebb986097e7919442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c06761fc369968fe907d8aaea9596fc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a4c06761fc369968fe907d8aaea9596fc">MakeSparse</a> (const uint32_t &amp;wFactor)</td></tr>
<tr class="memdesc:a4c06761fc369968fe907d8aaea9596fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make DCRTPoly Sparse. Sets every index of each tower not equal to zero mod the wFactor to zero.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a4c06761fc369968fe907d8aaea9596fc">More...</a><br /></td></tr>
<tr class="separator:a4c06761fc369968fe907d8aaea9596fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a278d9399c70da14dd2984df93749d881"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a278d9399c70da14dd2984df93749d881">IsEmpty</a> () const =0</td></tr>
<tr class="memdesc:a278d9399c70da14dd2984df93749d881"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if ALL the tower(s) are empty.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a278d9399c70da14dd2984df93749d881">More...</a><br /></td></tr>
<tr class="separator:a278d9399c70da14dd2984df93749d881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae389e5a67b2c9f79298fb7d69a18a050"><td class="memItemLeft" align="right" valign="top"><a id="ae389e5a67b2c9f79298fb7d69a18a050"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#ae389e5a67b2c9f79298fb7d69a18a050">DropLastElement</a> ()=0</td></tr>
<tr class="memdesc:ae389e5a67b2c9f79298fb7d69a18a050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drops the last element in the double-CRT representation. The resulting DCRTPoly element will have one less tower. <br /></td></tr>
<tr class="separator:ae389e5a67b2c9f79298fb7d69a18a050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2321bdd673f9e5f1af0917d8cacf0c7e"><td class="memItemLeft" align="right" valign="top"><a id="a2321bdd673f9e5f1af0917d8cacf0c7e"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a2321bdd673f9e5f1af0917d8cacf0c7e">DropLastElements</a> (size_t i)=0</td></tr>
<tr class="memdesc:a2321bdd673f9e5f1af0917d8cacf0c7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drops the last i elements in the double-CRT representation. <br /></td></tr>
<tr class="separator:a2321bdd673f9e5f1af0917d8cacf0c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a454428f6f25cca22c8194788c549a5f6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a454428f6f25cca22c8194788c549a5f6">DropLastElementAndScale</a> (const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;QlQlInvModqlDivqlModq, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;QlQlInvModqlDivqlModqPrecon, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;qlInvModq, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;qlInvModqPrecon)=0</td></tr>
<tr class="memdesc:a454428f6f25cca22c8194788c549a5f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drops the last element in the double-CRT representation and scales down by the last CRT modulus. The resulting DCRTPoly element will have one less tower.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a454428f6f25cca22c8194788c549a5f6">More...</a><br /></td></tr>
<tr class="separator:a454428f6f25cca22c8194788c549a5f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e133a2c25996be14600e54605b8bc4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a25e133a2c25996be14600e54605b8bc4">ModReduce</a> (const <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &amp;t, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;tModqPrecon, const <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &amp;negtInvModq, const <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &amp;negtInvModqPrecon, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;qlInvModq, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;qlInvModqPrecon)=0</td></tr>
<tr class="memdesc:a25e133a2c25996be14600e54605b8bc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">ModReduces reduces the DCRTPoly element's composite modulus by dropping the last modulus from the chain of moduli as well as dropping the last tower.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a25e133a2c25996be14600e54605b8bc4">More...</a><br /></td></tr>
<tr class="separator:a25e133a2c25996be14600e54605b8bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a498cdac8c2f3f8dbbe9fccc9b8d5de87"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyLargeType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a498cdac8c2f3f8dbbe9fccc9b8d5de87">CRTInterpolate</a> () const =0</td></tr>
<tr class="memdesc:a498cdac8c2f3f8dbbe9fccc9b8d5de87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolates the DCRTPoly to an Poly based on the Chinese Remainder Transform Interpolation. and then returns a Poly with that single element.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a498cdac8c2f3f8dbbe9fccc9b8d5de87">More...</a><br /></td></tr>
<tr class="separator:a498cdac8c2f3f8dbbe9fccc9b8d5de87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af671ffd01a5e2c08d0d0bb972be83bd7"><td class="memItemLeft" align="right" valign="top"><a id="af671ffd01a5e2c08d0d0bb972be83bd7"></a>
virtual TowerType&#160;</td><td class="memItemRight" valign="bottom"><b>DecryptionCRTInterpolate</b> (PlaintextModulus ptm) const =0</td></tr>
<tr class="separator:af671ffd01a5e2c08d0d0bb972be83bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d2b7e3f78ba01d71c1ea9425ea908f9"><td class="memItemLeft" align="right" valign="top">virtual TowerType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a0d2b7e3f78ba01d71c1ea9425ea908f9">ToNativePoly</a> () const =0</td></tr>
<tr class="memdesc:a0d2b7e3f78ba01d71c1ea9425ea908f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the values are small enough this is used for efficiency.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a0d2b7e3f78ba01d71c1ea9425ea908f9">More...</a><br /></td></tr>
<tr class="separator:a0d2b7e3f78ba01d71c1ea9425ea908f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a1dc378f31930ed354ef77ed7351d9b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyLargeType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a8a1dc378f31930ed354ef77ed7351d9b">CRTInterpolateIndex</a> (usint i) const =0</td></tr>
<tr class="memdesc:a8a1dc378f31930ed354ef77ed7351d9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolates the DCRTPoly to an Poly based on the Chinese Remainder Transform Interpolation, only at element index i, all other elements are zero. and then returns a Poly with that single element.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a8a1dc378f31930ed354ef77ed7351d9b">More...</a><br /></td></tr>
<tr class="separator:a8a1dc378f31930ed354ef77ed7351d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb38c09cf2d6bc44acce65cd6d3cc064"><td class="memItemLeft" align="right" valign="top">virtual BigIntType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#abb38c09cf2d6bc44acce65cd6d3cc064">GetWorkingModulus</a> () const =0</td></tr>
<tr class="memdesc:abb38c09cf2d6bc44acce65cd6d3cc064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and returns the product of primes in the current moduli chain. Compared to GetModulus, which always returns the product of all primes in the crypto parameters, this method will return a different modulus, based on the towers/moduli that are currently in the chain (some towers are dropped along the way).  <a href="classlbcrypto_1_1DCRTPolyInterface.html#abb38c09cf2d6bc44acce65cd6d3cc064">More...</a><br /></td></tr>
<tr class="separator:abb38c09cf2d6bc44acce65cd6d3cc064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5154189bc463d2babe5f6128b09b85d"><td class="memItemLeft" align="right" valign="top">virtual shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#ae5154189bc463d2babe5f6128b09b85d">GetExtendedCRTBasis</a> (std::shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt; paramsP) const =0</td></tr>
<tr class="memdesc:ae5154189bc463d2babe5f6128b09b85d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the element parameters for DCRTPoly elements in an extended CRT basis, which is the concatenation of the towers currently in "this" DCRTPoly, and the moduli in ParamsP.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#ae5154189bc463d2babe5f6128b09b85d">More...</a><br /></td></tr>
<tr class="separator:ae5154189bc463d2babe5f6128b09b85d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac03b0bd8ca326b7936dc04122b31c6df"><td class="memItemLeft" align="right" valign="top">virtual DerivedType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#ac03b0bd8ca326b7936dc04122b31c6df">ApproxSwitchCRTBasis</a> (const std::shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt; paramsQ, const std::shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt; paramsP, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;QHatInvModq, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;QHatInvModqPrecon, const std::vector&lt; std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;&gt; &amp;QHatModp, const std::vector&lt; DoubleNativeInt &gt; &amp;modpBarrettMu) const =0</td></tr>
<tr class="memdesc:ac03b0bd8ca326b7936dc04122b31c6df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs approximate CRT basis switching: {X}_{Q} -&gt; {X'}_{P} X' = X + alpha*Q for small alpha {Q} = {q_1,...,q_l} {P} = {p_1,...,p_k}.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#ac03b0bd8ca326b7936dc04122b31c6df">More...</a><br /></td></tr>
<tr class="separator:ac03b0bd8ca326b7936dc04122b31c6df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a562cc4ae452f8a957ce7cb6fab67904e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a562cc4ae452f8a957ce7cb6fab67904e">ApproxModUp</a> (const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt; paramsQ, const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt; paramsP, const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt; paramsQP, const vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;QHatInvModq, const vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;QHatInvModqPrecon, const vector&lt; vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;&gt; &amp;QHatModp, const vector&lt; DoubleNativeInt &gt; &amp;modpBarrettMu)=0</td></tr>
<tr class="memdesc:a562cc4ae452f8a957ce7cb6fab67904e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs approximate modulus raising: {X}_{Q} -&gt; {X'}_{Q,P}. X' = X + alpha*Q for small alpha {Q} = {q_1,...,q_l} {P} = {p_1,...,p_k}.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a562cc4ae452f8a957ce7cb6fab67904e">More...</a><br /></td></tr>
<tr class="separator:a562cc4ae452f8a957ce7cb6fab67904e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af143d9876962db6a0ec4cfba0362c16e"><td class="memItemLeft" align="right" valign="top">virtual DerivedType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#af143d9876962db6a0ec4cfba0362c16e">ApproxModDown</a> (const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt; paramsQ, const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt; paramsP, const vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;PInvModq, const vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;PInvModqPrecon, const vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;PHatInvModp, const vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;PHatInvModpPrecon, const vector&lt; vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;&gt; &amp;PHatModq, const vector&lt; DoubleNativeInt &gt; &amp;modqBarrettMu, const vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;tInvModp, const vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;tInvModpPrecon, const <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &amp;t, const vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;tModqPrecon) const =0</td></tr>
<tr class="memdesc:af143d9876962db6a0ec4cfba0362c16e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs approximate modulus reduction: {X}_{Q,P} -&gt; {\approx(X/P)}_{Q}. {Q} = {q_1,...,q_l} {P} = {p_1,...,p_k}.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#af143d9876962db6a0ec4cfba0362c16e">More...</a><br /></td></tr>
<tr class="separator:af143d9876962db6a0ec4cfba0362c16e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e3f3fcb29277339a655424ce674a60c"><td class="memItemLeft" align="right" valign="top">virtual DerivedType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a0e3f3fcb29277339a655424ce674a60c">SwitchCRTBasis</a> (const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt; paramsP, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;QHatInvModq, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;QHatInvModqPrecon, const std::vector&lt; std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;&gt; &amp;QHatModp, const std::vector&lt; std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;&gt; &amp;alphaQModp, const std::vector&lt; DoubleNativeInt &gt; &amp;modpBarrettMu, const std::vector&lt; double &gt; &amp;qInv) const =0</td></tr>
<tr class="memdesc:a0e3f3fcb29277339a655424ce674a60c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs CRT basis switching: {X}_{Q} -&gt; {X}_{P} {Q} = {q_1,...,q_l} {P} = {p_1,...,p_k}.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a0e3f3fcb29277339a655424ce674a60c">More...</a><br /></td></tr>
<tr class="separator:a0e3f3fcb29277339a655424ce674a60c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f9144151b30ee7218e8d855930d640"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a41f9144151b30ee7218e8d855930d640">ExpandCRTBasis</a> (const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt; paramsQP, const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt; paramsP, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;QHatInvModq, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;QHatInvModqPrecon, const std::vector&lt; std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;&gt; &amp;QHatModp, const std::vector&lt; std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;&gt; &amp;alphaQModp, const std::vector&lt; DoubleNativeInt &gt; &amp;modpBarrettMu, const std::vector&lt; double &gt; &amp;qInv, Format resultFormat)=0</td></tr>
<tr class="memdesc:a41f9144151b30ee7218e8d855930d640"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs modulus raising: {X}_{Q} -&gt; {X}_{Q,P} {Q} = {q_1,...,q_l} {P} = {p_1,...,p_k}.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a41f9144151b30ee7218e8d855930d640">More...</a><br /></td></tr>
<tr class="separator:a41f9144151b30ee7218e8d855930d640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab60fd67b9cdf8d1dc877432a9c198e98"><td class="memItemLeft" align="right" valign="top">virtual TowerType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#ab60fd67b9cdf8d1dc877432a9c198e98">ScaleAndRound</a> (const <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &amp;t, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;tQHatInvModqDivqModt, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;tQHatInvModqDivqModtPrecon, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;tQHatInvModqBDivqModt, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;tQHatInvModqBDivqModtPrecon, const std::vector&lt; double &gt; &amp;tQHatInvModqDivqFrac, const std::vector&lt; double &gt; &amp;tQHatInvModqBDivqFrac) const =0</td></tr>
<tr class="memdesc:ab60fd67b9cdf8d1dc877432a9c198e98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs scale and round: {X}_{Q} -&gt; {\round(t/Q*X)}_t {Q} = {q_1,...,q_l} {P} = {p_1,...,p_k}.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#ab60fd67b9cdf8d1dc877432a9c198e98">More...</a><br /></td></tr>
<tr class="separator:ab60fd67b9cdf8d1dc877432a9c198e98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca90f477f7a3ebdd52dcacbb49f7f74"><td class="memItemLeft" align="right" valign="top">virtual DerivedType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a7ca90f477f7a3ebdd52dcacbb49f7f74">ApproxScaleAndRound</a> (const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt; paramsP, const std::vector&lt; std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;&gt; &amp;tPSHatInvModsDivsModp, const std::vector&lt; DoubleNativeInt &gt; &amp;modpBarretMu) const =0</td></tr>
<tr class="memdesc:a7ca90f477f7a3ebdd52dcacbb49f7f74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes approximate scale and round: {X}_{Q,P} -&gt; {\approx{t/Q * X}}_{P} {Q} = {q_1,...,q_l} {P} = {p_1,...,p_k}.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a7ca90f477f7a3ebdd52dcacbb49f7f74">More...</a><br /></td></tr>
<tr class="separator:a7ca90f477f7a3ebdd52dcacbb49f7f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbe955b6be2cf993ee95a7ced916a2eb"><td class="memItemLeft" align="right" valign="top">virtual DerivedType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#afbe955b6be2cf993ee95a7ced916a2eb">ScaleAndRound</a> (const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt; paramsP, const std::vector&lt; std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;&gt; &amp;tPSHatInvModsDivsModp, const std::vector&lt; double &gt; &amp;tPSHatInvModsDivsFrac, const std::vector&lt; DoubleNativeInt &gt; &amp;modpBarretMu) const =0</td></tr>
<tr class="memdesc:afbe955b6be2cf993ee95a7ced916a2eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes scale and round: {X}_{Q,P} -&gt; {t/Q * X}_{P} {Q} = {q_1,...,q_l} {P} = {p_1,...,p_k}.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#afbe955b6be2cf993ee95a7ced916a2eb">More...</a><br /></td></tr>
<tr class="separator:afbe955b6be2cf993ee95a7ced916a2eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a474f08ad683cb2d196024fc0a0a34b1f"><td class="memItemLeft" align="right" valign="top">virtual TowerType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a474f08ad683cb2d196024fc0a0a34b1f">ScaleAndRound</a> (const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;moduliQ, const <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &amp;t, const <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &amp;tgamma, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;tgammaQHatModq, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;tgammaQHatModqPrecon, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;negInvqModtgamma, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;negInvqModtgammaPrecon) const =0</td></tr>
<tr class="memdesc:a474f08ad683cb2d196024fc0a0a34b1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes scale and round for fast rounding: {X}_{Q} -&gt; {\round(t/Q * X)}_t {Q} = {q_1,...,q_l}.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a474f08ad683cb2d196024fc0a0a34b1f">More...</a><br /></td></tr>
<tr class="separator:a474f08ad683cb2d196024fc0a0a34b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eca50ec338533d004b18584cd6ab157"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a8eca50ec338533d004b18584cd6ab157">FastBaseConvqToBskMontgomery</a> (const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt; paramsBsk, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;moduliQ, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;moduliBsk, const std::vector&lt; DoubleNativeInt &gt; &amp;modbskBarrettMu, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;mtildeQHatInvModq, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;mtildeQHatInvModqPrecon, const std::vector&lt; std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;&gt; &amp;QHatModbsk, const std::vector&lt; uint16_t &gt; &amp;QHatModmtilde, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;QModbsk, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;QModbskPrecon, const uint16_t &amp;negQInvModmtilde, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;mtildeInvModbsk, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;mtildeInvModbskPrecon)=0</td></tr>
<tr class="memdesc:a8eca50ec338533d004b18584cd6ab157"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expands basis: {X}_{Q} -&gt; {X}_{Q,Bsk,mtilde} mtilde is a redundant modulus used to remove q overflows generated from fast conversion. Outputs the resulting polynomial in CRT/RNS {Q} = {q_1,...,q_l} {Bsk} = {bsk_1,...,bsk_k}.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a8eca50ec338533d004b18584cd6ab157">More...</a><br /></td></tr>
<tr class="separator:a8eca50ec338533d004b18584cd6ab157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79ab7c03584ce526f115af9f8690519c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a79ab7c03584ce526f115af9f8690519c">FastRNSFloorq</a> (const <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &amp;t, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;moduliQ, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;moduliBsk, const std::vector&lt; DoubleNativeInt &gt; &amp;modbskBarrettMu, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;tQHatInvModq, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;tQHatInvModqPrecon, const std::vector&lt; std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;&gt; &amp;QHatModbsk, const std::vector&lt; std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;&gt; &amp;qInvModbsk, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;tQInvModbsk, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;tQInvModbskPrecon)=0</td></tr>
<tr class="memdesc:a79ab7c03584ce526f115af9f8690519c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes scale and floor: {X}_{Q,Bsk} -&gt; {\floor{t/Q * X}}_{Bsk} {Q} = {q_1,...,q_l} {Bsk} = {bsk_1,...,bsk_k} Outputs the resulting polynomial in CRT/RNS.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a79ab7c03584ce526f115af9f8690519c">More...</a><br /></td></tr>
<tr class="separator:a79ab7c03584ce526f115af9f8690519c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb8755ad950dc46a5400facfa3f39c32"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#adb8755ad950dc46a5400facfa3f39c32">FastBaseConvSK</a> (const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;moduliQ, const std::vector&lt; DoubleNativeInt &gt; &amp;modqBarrettMu, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;moduliBsk, const std::vector&lt; DoubleNativeInt &gt; &amp;modbskBarrettMu, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;BHatInvModb, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;BHatInvModbPrecon, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;BHatModmsk, const <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &amp;BInvModmsk, const <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &amp;BInvModmskPrecon, const std::vector&lt; std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;&gt; &amp;BHatModq, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;BModq, const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;BModqPrecon)=0</td></tr>
<tr class="memdesc:adb8755ad950dc46a5400facfa3f39c32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts basis: {X}_{Q,Bsk} -&gt; {X}_{Bsk} {Q} = {q_1,...,q_l} {Bsk} = {bsk_1,...,bsk_k} using Shenoy Kumaresan method. Outputs the resulting polynomial in CRT/RNS.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#adb8755ad950dc46a5400facfa3f39c32">More...</a><br /></td></tr>
<tr class="separator:adb8755ad950dc46a5400facfa3f39c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a984331e9b51c18bde937d77742361ef1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a984331e9b51c18bde937d77742361ef1">SwitchFormat</a> ()=0</td></tr>
<tr class="memdesc:a984331e9b51c18bde937d77742361ef1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert from Coefficient to CRT or vice versa; calls FFT and inverse FFT.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a984331e9b51c18bde937d77742361ef1">More...</a><br /></td></tr>
<tr class="separator:a984331e9b51c18bde937d77742361ef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c38037e64d065fd8240883700f25764"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a0c38037e64d065fd8240883700f25764">SwitchModulus</a> (const BigIntType &amp;modulus, const BigIntType &amp;rootOfUnity, const BigIntType &amp;modulusArb, const BigIntType &amp;rootOfUnityArb)</td></tr>
<tr class="memdesc:a0c38037e64d065fd8240883700f25764"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switch modulus and adjust the values.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a0c38037e64d065fd8240883700f25764">More...</a><br /></td></tr>
<tr class="separator:a0c38037e64d065fd8240883700f25764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5756e146673e846bc8ebaf4e3139472"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#ae5756e146673e846bc8ebaf4e3139472">SwitchModulusAtIndex</a> (usint index, const BigIntType &amp;modulus, const BigIntType &amp;rootOfUnity)=0</td></tr>
<tr class="memdesc:ae5756e146673e846bc8ebaf4e3139472"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switch modulus at tower i and adjust the values.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#ae5756e146673e846bc8ebaf4e3139472">More...</a><br /></td></tr>
<tr class="separator:ae5756e146673e846bc8ebaf4e3139472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d84bf03f20db3d0b46a40efb7d9f746"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a6d84bf03f20db3d0b46a40efb7d9f746">InverseExists</a> () const =0</td></tr>
<tr class="memdesc:a6d84bf03f20db3d0b46a40efb7d9f746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if inverse exists.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a6d84bf03f20db3d0b46a40efb7d9f746">More...</a><br /></td></tr>
<tr class="separator:a6d84bf03f20db3d0b46a40efb7d9f746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dce2c859629115a2453bb8726e8e137"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a4dce2c859629115a2453bb8726e8e137">Norm</a> () const =0</td></tr>
<tr class="memdesc:a4dce2c859629115a2453bb8726e8e137"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the infinity norm, basically the largest value in the ring element.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a4dce2c859629115a2453bb8726e8e137">More...</a><br /></td></tr>
<tr class="separator:a4dce2c859629115a2453bb8726e8e137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classlbcrypto_1_1ILElement"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classlbcrypto_1_1ILElement')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classlbcrypto_1_1ILElement.html">lbcrypto::ILElement&lt; DerivedType, BigVector &gt;</a></td></tr>
<tr class="memitem:a70b85d0a6aea66ace2c983618ac8a489 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memItemLeft" align="right" valign="top">virtual DerivedType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#a70b85d0a6aea66ace2c983618ac8a489">Clone</a> () const=0</td></tr>
<tr class="memdesc:a70b85d0a6aea66ace2c983618ac8a489 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone the object by making a copy of it and returning the copy.  <a href="classlbcrypto_1_1ILElement.html#a70b85d0a6aea66ace2c983618ac8a489">More...</a><br /></td></tr>
<tr class="separator:a70b85d0a6aea66ace2c983618ac8a489 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a6b897331d1265eb815e6d50d295037 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memItemLeft" align="right" valign="top">virtual DerivedType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#a0a6b897331d1265eb815e6d50d295037">CloneEmpty</a> () const=0</td></tr>
<tr class="memdesc:a0a6b897331d1265eb815e6d50d295037 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone the object, but have it contain nothing.  <a href="classlbcrypto_1_1ILElement.html#a0a6b897331d1265eb815e6d50d295037">More...</a><br /></td></tr>
<tr class="separator:a0a6b897331d1265eb815e6d50d295037 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a7aeb078733436bf1071b5127f79a7 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memItemLeft" align="right" valign="top">virtual DerivedType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#a77a7aeb078733436bf1071b5127f79a7">CloneParametersOnly</a> () const=0</td></tr>
<tr class="memdesc:a77a7aeb078733436bf1071b5127f79a7 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clones the element's parameters, leaves vector initialized to 0.  <a href="classlbcrypto_1_1ILElement.html#a77a7aeb078733436bf1071b5127f79a7">More...</a><br /></td></tr>
<tr class="separator:a77a7aeb078733436bf1071b5127f79a7 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e2e2a2bacd65456e0ce82aaf33e23e inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memItemLeft" align="right" valign="top">virtual DerivedType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#a45e2e2a2bacd65456e0ce82aaf33e23e">CloneWithNoise</a> (const <a class="el" href="classlbcrypto_1_1DiscreteGaussianGeneratorImpl.html">DiscreteGaussianGeneratorImpl</a>&lt; <a class="el" href="classbigintfxd_1_1BigVectorImpl.html">BigVector</a> &gt; &amp;dgg, Format format=Format::EVALUATION) const=0</td></tr>
<tr class="memdesc:a45e2e2a2bacd65456e0ce82aaf33e23e inherit pub_methods_classlbcrypto_1_1ILElement"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clones the element with parameters and with noise for the vector.  <a href="classlbcrypto_1_1ILElement.html#a45e2e2a2bacd65456e0ce82aaf33e23e">More...</a><br /></td></tr>
<tr class="separator:a45e2e2a2bacd65456e0ce82aaf33e23e inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1538c0112d2d4dfba9eec22118b22cc inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memItemLeft" align="right" valign="top"><a id="aa1538c0112d2d4dfba9eec22118b22cc"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#aa1538c0112d2d4dfba9eec22118b22cc">~ILElement</a> ()</td></tr>
<tr class="memdesc:aa1538c0112d2d4dfba9eec22118b22cc inherit pub_methods_classlbcrypto_1_1ILElement"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard destructor. <br /></td></tr>
<tr class="separator:aa1538c0112d2d4dfba9eec22118b22cc inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7d2c897610e5923b5418f7227393272 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memItemLeft" align="right" valign="top">virtual Format&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#ac7d2c897610e5923b5418f7227393272">GetFormat</a> () const=0</td></tr>
<tr class="memdesc:ac7d2c897610e5923b5418f7227393272 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get format of the element.  <a href="classlbcrypto_1_1ILElement.html#ac7d2c897610e5923b5418f7227393272">More...</a><br /></td></tr>
<tr class="separator:ac7d2c897610e5923b5418f7227393272 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9eeef930f29aa94f77cca1a86fabf6e inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memItemLeft" align="right" valign="top">virtual usint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#af9eeef930f29aa94f77cca1a86fabf6e">GetLength</a> () const=0</td></tr>
<tr class="memdesc:af9eeef930f29aa94f77cca1a86fabf6e inherit pub_methods_classlbcrypto_1_1ILElement"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the length of the element.  <a href="classlbcrypto_1_1ILElement.html#af9eeef930f29aa94f77cca1a86fabf6e">More...</a><br /></td></tr>
<tr class="separator:af9eeef930f29aa94f77cca1a86fabf6e inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacc0cf9d638c8e613fb0c646456be0a0 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memItemLeft" align="right" valign="top">virtual const IntType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#aacc0cf9d638c8e613fb0c646456be0a0">GetModulus</a> () const=0</td></tr>
<tr class="memdesc:aacc0cf9d638c8e613fb0c646456be0a0 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get modulus of the element.  <a href="classlbcrypto_1_1ILElement.html#aacc0cf9d638c8e613fb0c646456be0a0">More...</a><br /></td></tr>
<tr class="separator:aacc0cf9d638c8e613fb0c646456be0a0 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a474bbec1e55b18ecf1fc52b806d7f186 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classbigintfxd_1_1BigVectorImpl.html">BigVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#a474bbec1e55b18ecf1fc52b806d7f186">GetValues</a> () const=0</td></tr>
<tr class="memdesc:a474bbec1e55b18ecf1fc52b806d7f186 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the values for the element.  <a href="classlbcrypto_1_1ILElement.html#a474bbec1e55b18ecf1fc52b806d7f186">More...</a><br /></td></tr>
<tr class="separator:a474bbec1e55b18ecf1fc52b806d7f186 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7de6762a19c79d5a0be9896a2b69498c inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memItemLeft" align="right" valign="top">virtual usint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#a7de6762a19c79d5a0be9896a2b69498c">GetCyclotomicOrder</a> () const=0</td></tr>
<tr class="memdesc:a7de6762a19c79d5a0be9896a2b69498c inherit pub_methods_classlbcrypto_1_1ILElement"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the cyclotomic order.  <a href="classlbcrypto_1_1ILElement.html#a7de6762a19c79d5a0be9896a2b69498c">More...</a><br /></td></tr>
<tr class="separator:a7de6762a19c79d5a0be9896a2b69498c inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a746f4dd63222b09c45ad989b8045bae7 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memItemLeft" align="right" valign="top">virtual DerivedType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#a746f4dd63222b09c45ad989b8045bae7">operator-</a> () const=0</td></tr>
<tr class="memdesc:a746f4dd63222b09c45ad989b8045bae7 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary negation on a lattice.  <a href="classlbcrypto_1_1ILElement.html#a746f4dd63222b09c45ad989b8045bae7">More...</a><br /></td></tr>
<tr class="separator:a746f4dd63222b09c45ad989b8045bae7 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07683b181b31fb853a4988a7f35bc776 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memItemLeft" align="right" valign="top">virtual DerivedType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#a07683b181b31fb853a4988a7f35bc776">Plus</a> (const IntType &amp;element) const=0</td></tr>
<tr class="memdesc:a07683b181b31fb853a4988a7f35bc776 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar addition - add an element to the first index only. This operation is only allowed in COEFFICIENT format.  <a href="classlbcrypto_1_1ILElement.html#a07683b181b31fb853a4988a7f35bc776">More...</a><br /></td></tr>
<tr class="separator:a07683b181b31fb853a4988a7f35bc776 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceb6e03c9b3106a45c13f3488bdaf403 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memItemLeft" align="right" valign="top">virtual DerivedType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#aceb6e03c9b3106a45c13f3488bdaf403">Minus</a> (const IntType &amp;element) const=0</td></tr>
<tr class="memdesc:aceb6e03c9b3106a45c13f3488bdaf403 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar subtraction - subtract an element frp, all entries.  <a href="classlbcrypto_1_1ILElement.html#aceb6e03c9b3106a45c13f3488bdaf403">More...</a><br /></td></tr>
<tr class="separator:aceb6e03c9b3106a45c13f3488bdaf403 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace67acbcf4ed67ce68a02e1565159af4 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memItemLeft" align="right" valign="top">virtual DerivedType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#ace67acbcf4ed67ce68a02e1565159af4">Times</a> (const IntType &amp;element) const=0</td></tr>
<tr class="memdesc:ace67acbcf4ed67ce68a02e1565159af4 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar multiplication - multiply all entries.  <a href="classlbcrypto_1_1ILElement.html#ace67acbcf4ed67ce68a02e1565159af4">More...</a><br /></td></tr>
<tr class="separator:ace67acbcf4ed67ce68a02e1565159af4 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5763872f5ef073a213c3d7564bb1359 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memItemLeft" align="right" valign="top">virtual const DerivedType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#ad5763872f5ef073a213c3d7564bb1359">operator+=</a> (const IntType &amp;element)=0</td></tr>
<tr class="memdesc:ad5763872f5ef073a213c3d7564bb1359 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs += operation with a BigInteger and returns the result.  <a href="classlbcrypto_1_1ILElement.html#ad5763872f5ef073a213c3d7564bb1359">More...</a><br /></td></tr>
<tr class="separator:ad5763872f5ef073a213c3d7564bb1359 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b6b8e3c0fe6e82a736e0697a381856 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memItemLeft" align="right" valign="top">virtual const DerivedType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#ae7b6b8e3c0fe6e82a736e0697a381856">operator-=</a> (const IntType &amp;element)=0</td></tr>
<tr class="memdesc:ae7b6b8e3c0fe6e82a736e0697a381856 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs -= operation with a BigInteger and returns the result.  <a href="classlbcrypto_1_1ILElement.html#ae7b6b8e3c0fe6e82a736e0697a381856">More...</a><br /></td></tr>
<tr class="separator:ae7b6b8e3c0fe6e82a736e0697a381856 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb0670789e94757db373df45ff9067cd inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memItemLeft" align="right" valign="top">virtual const DerivedType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#abb0670789e94757db373df45ff9067cd">operator*=</a> (const IntType &amp;element)=0</td></tr>
<tr class="memdesc:abb0670789e94757db373df45ff9067cd inherit pub_methods_classlbcrypto_1_1ILElement"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs *= operation with a BigInteger and returns the result.  <a href="classlbcrypto_1_1ILElement.html#abb0670789e94757db373df45ff9067cd">More...</a><br /></td></tr>
<tr class="separator:abb0670789e94757db373df45ff9067cd inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac59b8d3af7b29f7225ee37dc83214e79 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#ac59b8d3af7b29f7225ee37dc83214e79">operator!=</a> (const DerivedType &amp;element) const</td></tr>
<tr class="memdesc:ac59b8d3af7b29f7225ee37dc83214e79 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator. Compares values of element to be compared to.  <a href="classlbcrypto_1_1ILElement.html#ac59b8d3af7b29f7225ee37dc83214e79">More...</a><br /></td></tr>
<tr class="separator:ac59b8d3af7b29f7225ee37dc83214e79 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d781be3bbb1386494f2f60ef4c93927 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memItemLeft" align="right" valign="top">virtual DerivedType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#a9d781be3bbb1386494f2f60ef4c93927">Transpose</a> () const=0</td></tr>
<tr class="memdesc:a9d781be3bbb1386494f2f60ef4c93927 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose the ring element using the automorphism operation.  <a href="classlbcrypto_1_1ILElement.html#a9d781be3bbb1386494f2f60ef4c93927">More...</a><br /></td></tr>
<tr class="separator:a9d781be3bbb1386494f2f60ef4c93927 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad335f96c10a85a9c1c969bd8366123 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memItemLeft" align="right" valign="top">virtual DerivedType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#a7ad335f96c10a85a9c1c969bd8366123">DivideAndRound</a> (const IntType &amp;q) const=0</td></tr>
<tr class="memdesc:a7ad335f96c10a85a9c1c969bd8366123 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar division followed by rounding operation - operation on all entries.  <a href="classlbcrypto_1_1ILElement.html#a7ad335f96c10a85a9c1c969bd8366123">More...</a><br /></td></tr>
<tr class="separator:a7ad335f96c10a85a9c1c969bd8366123 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a5636cb0f6cfa9ce7ccdb6239f8bba inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#a87a5636cb0f6cfa9ce7ccdb6239f8bba">InverseExists</a> () const=0</td></tr>
<tr class="memdesc:a87a5636cb0f6cfa9ce7ccdb6239f8bba inherit pub_methods_classlbcrypto_1_1ILElement"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if inverse exists.  <a href="classlbcrypto_1_1ILElement.html#a87a5636cb0f6cfa9ce7ccdb6239f8bba">More...</a><br /></td></tr>
<tr class="separator:a87a5636cb0f6cfa9ce7ccdb6239f8bba inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af05d67e38444a81ae0847f50665a17b0 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#af05d67e38444a81ae0847f50665a17b0">Norm</a> () const=0</td></tr>
<tr class="memdesc:af05d67e38444a81ae0847f50665a17b0 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the infinity norm, basically the largest value in the ring element.  <a href="classlbcrypto_1_1ILElement.html#af05d67e38444a81ae0847f50665a17b0">More...</a><br /></td></tr>
<tr class="separator:af05d67e38444a81ae0847f50665a17b0 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5da86b5e1c04a91d126f6220824e066c inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#a5da86b5e1c04a91d126f6220824e066c">IsEmpty</a> () const=0</td></tr>
<tr class="memdesc:a5da86b5e1c04a91d126f6220824e066c inherit pub_methods_classlbcrypto_1_1ILElement"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the vector is empty/ m_values==nullptr.  <a href="classlbcrypto_1_1ILElement.html#a5da86b5e1c04a91d126f6220824e066c">More...</a><br /></td></tr>
<tr class="separator:a5da86b5e1c04a91d126f6220824e066c inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e5fcbb9decceac48d33a94a81cfde6 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memItemLeft" align="right" valign="top">virtual DerivedType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#a63e5fcbb9decceac48d33a94a81cfde6">ModByTwo</a> () const=0</td></tr>
<tr class="memdesc:a63e5fcbb9decceac48d33a94a81cfde6 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate Element mod 2.  <a href="classlbcrypto_1_1ILElement.html#a63e5fcbb9decceac48d33a94a81cfde6">More...</a><br /></td></tr>
<tr class="separator:a63e5fcbb9decceac48d33a94a81cfde6 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0feb835a89963a5a761c06d27c59bd6 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memItemLeft" align="right" valign="top">virtual DerivedType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#ae0feb835a89963a5a761c06d27c59bd6">MultiplicativeInverse</a> () const=0</td></tr>
<tr class="memdesc:ae0feb835a89963a5a761c06d27c59bd6 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate and return the Multiplicative Inverse of the element.  <a href="classlbcrypto_1_1ILElement.html#ae0feb835a89963a5a761c06d27c59bd6">More...</a><br /></td></tr>
<tr class="separator:ae0feb835a89963a5a761c06d27c59bd6 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ae88a999b925e069bfb4d92c68bfd6 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memItemLeft" align="right" valign="top">virtual DerivedType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#a40ae88a999b925e069bfb4d92c68bfd6">MultiplyAndRound</a> (const IntType &amp;p, const IntType &amp;q) const=0</td></tr>
<tr class="memdesc:a40ae88a999b925e069bfb4d92c68bfd6 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar multiplication followed by division and rounding operation - operation on all entries.  <a href="classlbcrypto_1_1ILElement.html#a40ae88a999b925e069bfb4d92c68bfd6">More...</a><br /></td></tr>
<tr class="separator:a40ae88a999b925e069bfb4d92c68bfd6 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a344cbaf3a5cb2119a728d5588446cf5c inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memItemLeft" align="right" valign="top">virtual DerivedType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#a344cbaf3a5cb2119a728d5588446cf5c">Mod</a> (const IntType &amp;modulus) const=0</td></tr>
<tr class="memdesc:a344cbaf3a5cb2119a728d5588446cf5c inherit pub_methods_classlbcrypto_1_1ILElement"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mod - perform a modulus operation. Does proper mapping of [-modulus/2, modulus/2) to [0, modulus).  <a href="classlbcrypto_1_1ILElement.html#a344cbaf3a5cb2119a728d5588446cf5c">More...</a><br /></td></tr>
<tr class="separator:a344cbaf3a5cb2119a728d5588446cf5c inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58eafec82f5f68c4e9efcf37324c0d03 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#a58eafec82f5f68c4e9efcf37324c0d03">SwitchModulus</a> (const IntType &amp;modulus, const IntType &amp;rootOfUnity, const IntType &amp;modulusArb=IntType::ZERO, const IntType &amp;rootOfUnityArb=IntType::ZERO)=0</td></tr>
<tr class="memdesc:a58eafec82f5f68c4e9efcf37324c0d03 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switch modulus and adjust the values.  <a href="classlbcrypto_1_1ILElement.html#a58eafec82f5f68c4e9efcf37324c0d03">More...</a><br /></td></tr>
<tr class="separator:a58eafec82f5f68c4e9efcf37324c0d03 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e39b2a1a1ef24df9de8974acad76c43 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#a4e39b2a1a1ef24df9de8974acad76c43">SetFormat</a> (const Format format)</td></tr>
<tr class="memdesc:a4e39b2a1a1ef24df9de8974acad76c43 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the format/representation of the element.  <a href="classlbcrypto_1_1ILElement.html#a4e39b2a1a1ef24df9de8974acad76c43">More...</a><br /></td></tr>
<tr class="separator:a4e39b2a1a1ef24df9de8974acad76c43 inherit pub_methods_classlbcrypto_1_1ILElement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classlbcrypto_1_1Serializable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classlbcrypto_1_1Serializable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classlbcrypto_1_1Serializable.html">lbcrypto::Serializable</a></td></tr>
<tr class="memitem:a1325a7f98c262df15af7aafee05a0368 inherit pub_methods_classlbcrypto_1_1Serializable"><td class="memItemLeft" align="right" valign="top"><a id="a1325a7f98c262df15af7aafee05a0368"></a>
virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><b>SerializedObjectName</b> () const =0</td></tr>
<tr class="separator:a1325a7f98c262df15af7aafee05a0368 inherit pub_methods_classlbcrypto_1_1Serializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a707b00f0957b9401a58e4f143bf7cb34"><td class="memItemLeft" align="right" valign="top">static function&lt; DerivedType()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a707b00f0957b9401a58e4f143bf7cb34">Allocator</a> (const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt; params, Format format)</td></tr>
<tr class="memdesc:a707b00f0957b9401a58e4f143bf7cb34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create lambda that allocates a zeroed element for the case when it is called from a templated class.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a707b00f0957b9401a58e4f143bf7cb34">More...</a><br /></td></tr>
<tr class="separator:a707b00f0957b9401a58e4f143bf7cb34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae22cd32bfb9e99d19fa87cba5c4c9c2b"><td class="memItemLeft" align="right" valign="top">static function&lt; DerivedType()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#ae22cd32bfb9e99d19fa87cba5c4c9c2b">MakeDiscreteGaussianCoefficientAllocator</a> (shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt; params, Format resultFormat, double stddev)</td></tr>
<tr class="memdesc:ae22cd32bfb9e99d19fa87cba5c4c9c2b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classAllocator.html">Allocator</a> for discrete uniform distribution.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#ae22cd32bfb9e99d19fa87cba5c4c9c2b">More...</a><br /></td></tr>
<tr class="separator:ae22cd32bfb9e99d19fa87cba5c4c9c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b2b29ed26d54b371f8bbe545292cd90"><td class="memItemLeft" align="right" valign="top">static function&lt; DerivedType()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a4b2b29ed26d54b371f8bbe545292cd90">MakeDiscreteUniformAllocator</a> (shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt; params, Format format)</td></tr>
<tr class="memdesc:a4b2b29ed26d54b371f8bbe545292cd90"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classAllocator.html">Allocator</a> for discrete uniform distribution.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a4b2b29ed26d54b371f8bbe545292cd90">More...</a><br /></td></tr>
<tr class="separator:a4b2b29ed26d54b371f8bbe545292cd90"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a320385e8cacd3ad54e5efce7da035326"><td class="memItemLeft" align="right" valign="top"><a id="a320385e8cacd3ad54e5efce7da035326"></a>
shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_params</b></td></tr>
<tr class="separator:a320385e8cacd3ad54e5efce7da035326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e83ca2233fb4f86c81f81bd0ef7bf3"><td class="memItemLeft" align="right" valign="top"><a id="a63e83ca2233fb4f86c81f81bd0ef7bf3"></a>
Format&#160;</td><td class="memItemRight" valign="bottom"><b>m_format</b></td></tr>
<tr class="separator:a63e83ca2233fb4f86c81f81bd0ef7bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a65f5228b2d411c4da6daca47f031c99b"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a65f5228b2d411c4da6daca47f031c99b">operator&lt;&lt;</a> (std::ostream &amp;os, const DerivedType &amp;vec)</td></tr>
<tr class="memdesc:a65f5228b2d411c4da6daca47f031c99b"><td class="mdescLeft">&#160;</td><td class="mdescRight">ostream operator  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a65f5228b2d411c4da6daca47f031c99b">More...</a><br /></td></tr>
<tr class="separator:a65f5228b2d411c4da6daca47f031c99b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad18caaec27bec23156635e966b5a6b32"><td class="memItemLeft" align="right" valign="top">DerivedType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#ad18caaec27bec23156635e966b5a6b32">operator+</a> (const DerivedType &amp;a, const DerivedType &amp;b)</td></tr>
<tr class="memdesc:ad18caaec27bec23156635e966b5a6b32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-element addition operator.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#ad18caaec27bec23156635e966b5a6b32">More...</a><br /></td></tr>
<tr class="separator:ad18caaec27bec23156635e966b5a6b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6642ccfeddef9f1decea469bab6b27b1"><td class="memItemLeft" align="right" valign="top">DerivedType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a6642ccfeddef9f1decea469bab6b27b1">operator+</a> (const DerivedType &amp;a, const BigIntType &amp;b)</td></tr>
<tr class="memdesc:a6642ccfeddef9f1decea469bab6b27b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-integer addition operator.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a6642ccfeddef9f1decea469bab6b27b1">More...</a><br /></td></tr>
<tr class="separator:a6642ccfeddef9f1decea469bab6b27b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43590c2fa51c6859654160e4657fb521"><td class="memItemLeft" align="right" valign="top">DerivedType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a43590c2fa51c6859654160e4657fb521">operator+</a> (const BigIntType &amp;a, const DerivedType &amp;b)</td></tr>
<tr class="memdesc:a43590c2fa51c6859654160e4657fb521"><td class="mdescLeft">&#160;</td><td class="mdescRight">BigIntType-element addition operator.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a43590c2fa51c6859654160e4657fb521">More...</a><br /></td></tr>
<tr class="separator:a43590c2fa51c6859654160e4657fb521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b6df4e75de80bbf9276e30ad06d20a"><td class="memItemLeft" align="right" valign="top">DerivedType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#aa3b6df4e75de80bbf9276e30ad06d20a">operator+</a> (const DerivedType &amp;a, const vector&lt; BigIntType &gt; &amp;b)</td></tr>
<tr class="memdesc:aa3b6df4e75de80bbf9276e30ad06d20a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-integer addition operator with CRT integer.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#aa3b6df4e75de80bbf9276e30ad06d20a">More...</a><br /></td></tr>
<tr class="separator:aa3b6df4e75de80bbf9276e30ad06d20a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a55c7c3d2f79ca78bdead15ad9033b9"><td class="memItemLeft" align="right" valign="top">DerivedType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a7a55c7c3d2f79ca78bdead15ad9033b9">operator+</a> (const vector&lt; BigIntType &gt; &amp;a, const DerivedType &amp;b)</td></tr>
<tr class="memdesc:a7a55c7c3d2f79ca78bdead15ad9033b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">BigIntType-element addition operator with CRT integer.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a7a55c7c3d2f79ca78bdead15ad9033b9">More...</a><br /></td></tr>
<tr class="separator:a7a55c7c3d2f79ca78bdead15ad9033b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a0b432c4d5fcfe7927e2273ed6ad062"><td class="memItemLeft" align="right" valign="top">DerivedType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a6a0b432c4d5fcfe7927e2273ed6ad062">operator-</a> (const DerivedType &amp;a, const DerivedType &amp;b)</td></tr>
<tr class="memdesc:a6a0b432c4d5fcfe7927e2273ed6ad062"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-element subtraction operator.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a6a0b432c4d5fcfe7927e2273ed6ad062">More...</a><br /></td></tr>
<tr class="separator:a6a0b432c4d5fcfe7927e2273ed6ad062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7536108ae00642c44c249b83cc1534ed"><td class="memItemLeft" align="right" valign="top">DerivedType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a7536108ae00642c44c249b83cc1534ed">operator-</a> (const DerivedType &amp;a, const vector&lt; BigIntType &gt; &amp;b)</td></tr>
<tr class="memdesc:a7536108ae00642c44c249b83cc1534ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-integer subtraction operator with CRT integer.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a7536108ae00642c44c249b83cc1534ed">More...</a><br /></td></tr>
<tr class="separator:a7536108ae00642c44c249b83cc1534ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7083d5e4343ee4d6bd3d0d01842fafa8"><td class="memItemLeft" align="right" valign="top">DerivedType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a7083d5e4343ee4d6bd3d0d01842fafa8">operator-</a> (const vector&lt; BigIntType &gt; &amp;a, const DerivedType &amp;b)</td></tr>
<tr class="memdesc:a7083d5e4343ee4d6bd3d0d01842fafa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">BigIntType-element subtraction operator with CRT integer.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a7083d5e4343ee4d6bd3d0d01842fafa8">More...</a><br /></td></tr>
<tr class="separator:a7083d5e4343ee4d6bd3d0d01842fafa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c703da1ce30308cc6f4266093bb0325"><td class="memItemLeft" align="right" valign="top">DerivedType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a0c703da1ce30308cc6f4266093bb0325">operator-</a> (const DerivedType &amp;a, const BigIntType &amp;b)</td></tr>
<tr class="memdesc:a0c703da1ce30308cc6f4266093bb0325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-integer subtraction operator.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a0c703da1ce30308cc6f4266093bb0325">More...</a><br /></td></tr>
<tr class="separator:a0c703da1ce30308cc6f4266093bb0325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b869cfdc3e36bb62e779856c46f1570"><td class="memItemLeft" align="right" valign="top">DerivedType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a0b869cfdc3e36bb62e779856c46f1570">operator*</a> (const DerivedType &amp;a, const DerivedType &amp;b)</td></tr>
<tr class="memdesc:a0b869cfdc3e36bb62e779856c46f1570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-element multiplication operator.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a0b869cfdc3e36bb62e779856c46f1570">More...</a><br /></td></tr>
<tr class="separator:a0b869cfdc3e36bb62e779856c46f1570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a679021dabcc74542e18af66ca0f11219"><td class="memItemLeft" align="right" valign="top">DerivedType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a679021dabcc74542e18af66ca0f11219">operator*</a> (const DerivedType &amp;a, const BigIntType &amp;b)</td></tr>
<tr class="memdesc:a679021dabcc74542e18af66ca0f11219"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-integer multiplication operator.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a679021dabcc74542e18af66ca0f11219">More...</a><br /></td></tr>
<tr class="separator:a679021dabcc74542e18af66ca0f11219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed5be6e095880c30bee13d4a7a8b7024"><td class="memItemLeft" align="right" valign="top">DerivedType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#aed5be6e095880c30bee13d4a7a8b7024">operator*</a> (const DerivedType &amp;a, const vector&lt; BigIntType &gt; &amp;b)</td></tr>
<tr class="memdesc:aed5be6e095880c30bee13d4a7a8b7024"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-CRT number multiplication operator.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#aed5be6e095880c30bee13d4a7a8b7024">More...</a><br /></td></tr>
<tr class="separator:aed5be6e095880c30bee13d4a7a8b7024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f94b2fcef68088ec97dd97baeaf5678"><td class="memItemLeft" align="right" valign="top">DerivedType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a3f94b2fcef68088ec97dd97baeaf5678">operator*</a> (const BigIntType &amp;a, const DerivedType &amp;b)</td></tr>
<tr class="memdesc:a3f94b2fcef68088ec97dd97baeaf5678"><td class="mdescLeft">&#160;</td><td class="mdescRight">BigIntType-element multiplication operator.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a3f94b2fcef68088ec97dd97baeaf5678">More...</a><br /></td></tr>
<tr class="separator:a3f94b2fcef68088ec97dd97baeaf5678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a720afafe6ecdc7e2be081909dde7b5fe"><td class="memItemLeft" align="right" valign="top">DerivedType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a720afafe6ecdc7e2be081909dde7b5fe">operator*</a> (const DerivedType &amp;a, int64_t b)</td></tr>
<tr class="memdesc:a720afafe6ecdc7e2be081909dde7b5fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-signed-integer multiplication operator.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#a720afafe6ecdc7e2be081909dde7b5fe">More...</a><br /></td></tr>
<tr class="separator:a720afafe6ecdc7e2be081909dde7b5fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7e0ded9452926fe21e067c118eb6d45"><td class="memItemLeft" align="right" valign="top">DerivedType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#ad7e0ded9452926fe21e067c118eb6d45">operator*</a> (int64_t a, const DerivedType &amp;b)</td></tr>
<tr class="memdesc:ad7e0ded9452926fe21e067c118eb6d45"><td class="mdescLeft">&#160;</td><td class="mdescRight">signed-BigIntType-element multiplication operator.  <a href="classlbcrypto_1_1DCRTPolyInterface.html#ad7e0ded9452926fe21e067c118eb6d45">More...</a><br /></td></tr>
<tr class="separator:ad7e0ded9452926fe21e067c118eb6d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aa5560043bd7a46c9fead585f179e9620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5560043bd7a46c9fead585f179e9620">&#9670;&nbsp;</a></span>DCRTPolyInterfaceType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">DCRTPolyInterface</a>&lt;DerivedType, BigVecType&gt; <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::<a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#aa5560043bd7a46c9fead585f179e9620">DCRTPolyInterfaceType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Probably not going to use this, in lieu of. </p>
<dl class="section see"><dt>See also</dt><dd>DerivedType </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aec031b96c902996ebb986097e7919442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec031b96c902996ebb986097e7919442">&#9670;&nbsp;</a></span>AddRandomNoise()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual DerivedType <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::AddRandomNoise </td>
          <td>(</td>
          <td class="paramtype">const BigIntType &amp;&#160;</td>
          <td class="paramname"><em>modulus</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add uniformly random values to all components except for the first one. </p>
<dl class="section warning"><dt>Warning</dt><dd>Doesn't make sense for DCRT </dd></dl>

<p>Reimplemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#aa27a69b9e199e7ad7edb7d88adc44528">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="a707b00f0957b9401a58e4f143bf7cb34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a707b00f0957b9401a58e4f143bf7cb34">&#9670;&nbsp;</a></span>Allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static function&lt;DerivedType()&gt; <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::<a class="el" href="classAllocator.html">Allocator</a> </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Format&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create lambda that allocates a zeroed element for the case when it is called from a templated class. </p>
<dl class="section note"><dt>Note</dt><dd>323-comment, Not sure if we need this in the base abstract classs</dd></dl>
<ul>
<li>yes this can stay here, but might need to do a static_cast to get derived constructor. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>the params to use. </td></tr>
    <tr><td class="paramname">format</td><td>- EVALUATION or COEFFICIENT </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a id="af143d9876962db6a0ec4cfba0362c16e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af143d9876962db6a0ec4cfba0362c16e">&#9670;&nbsp;</a></span>ApproxModDown()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual DerivedType <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::ApproxModDown </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt;&#160;</td>
          <td class="paramname"><em>paramsQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt;&#160;</td>
          <td class="paramname"><em>paramsP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>PInvModq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>PInvModqPrecon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>PHatInvModp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>PHatInvModpPrecon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>PHatModq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; DoubleNativeInt &gt; &amp;&#160;</td>
          <td class="paramname"><em>modqBarrettMu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tInvModp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tInvModpPrecon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tModqPrecon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs approximate modulus reduction: {X}_{Q,P} -&gt; {\approx(X/P)}_{Q}. {Q} = {q_1,...,q_l} {P} = {p_1,...,p_k}. </p>
<p>Brief algorithm: 1) use <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a14326698ef430e239dba7f45ccf3d6f6" title="Performs approximate CRT basis switching: {X}_{Q} -&gt; {X&#39;}_{P} X&#39; = X + alpha*Q for small alpha {Q} = ...">DCRTPoly::ApproxSwitchCRTBasis</a> : {X}_{P} -&gt; {X'}_{Q} 2) compute : {(X-X') * P^{-1}}_{Q}</p>
<p>Source: "A full RNS variant of approximate homomorphic encryption" by Cheon, et. al.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;paramsQ</td><td>parameters for the CRT basis {q_1,...,q_l} </td></tr>
    <tr><td class="paramname">&amp;paramsP</td><td>parameters for the CRT basis {p_1,...,p_k} </td></tr>
    <tr><td class="paramname">&amp;PInvModq</td><td>precomputed values for (P^{-1} mod q_j) </td></tr>
    <tr><td class="paramname">&amp;PInvModqPrecon</td><td>NTL-specific precomputations </td></tr>
    <tr><td class="paramname">&amp;PHatInvModp</td><td>precomputed values for [(P/p_j)^{-1}]_{p_j} </td></tr>
    <tr><td class="paramname">&amp;PHatInvModpPrecon</td><td>NTL-specific precomputations </td></tr>
    <tr><td class="paramname">&amp;PHatModq</td><td>precomputed values for [P/p_j]_{q_i} </td></tr>
    <tr><td class="paramname">&amp;modqBarrettMu</td><td>128-bit Barrett reduction precomputed values for q_i </td></tr>
    <tr><td class="paramname">&amp;tInvModp</td><td>precomputed values for [t^{-1}]_{p_j} used in BGVrns </td></tr>
    <tr><td class="paramname">t</td><td>often corresponds to the plaintext modulus used in BGVrns </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the representation of {\approx(X/P)}_{Q} </dd></dl>

</div>
</div>
<a id="a562cc4ae452f8a957ce7cb6fab67904e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a562cc4ae452f8a957ce7cb6fab67904e">&#9670;&nbsp;</a></span>ApproxModUp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::ApproxModUp </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt;&#160;</td>
          <td class="paramname"><em>paramsQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt;&#160;</td>
          <td class="paramname"><em>paramsP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt;&#160;</td>
          <td class="paramname"><em>paramsQP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>QHatInvModq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>QHatInvModqPrecon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>QHatModp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; DoubleNativeInt &gt; &amp;&#160;</td>
          <td class="paramname"><em>modpBarrettMu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs approximate modulus raising: {X}_{Q} -&gt; {X'}_{Q,P}. X' = X + alpha*Q for small alpha {Q} = {q_1,...,q_l} {P} = {p_1,...,p_k}. </p>
<p>Brief algorithm: {X}_{Q} -&gt; {X'}_Q : trivial {X}_{Q} -&gt; {X'}_P : use <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a14326698ef430e239dba7f45ccf3d6f6" title="Performs approximate CRT basis switching: {X}_{Q} -&gt; {X&#39;}_{P} X&#39; = X + alpha*Q for small alpha {Q} = ...">DCRTPoly::ApproxSwitchCRTBasis</a></p>
<p>Source: "A full RNS variant of approximate homomorphic encryption" by Cheon, et. al.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;paramsQ</td><td>parameters for the CRT basis {q_1,...,q_l} </td></tr>
    <tr><td class="paramname">&amp;paramsP</td><td>parameters for the CRT basis {p_1,...,p_k} </td></tr>
    <tr><td class="paramname">&amp;QHatInvModq</td><td>precomputed values for [(Q/q_i)^{-1}]_{q_i} </td></tr>
    <tr><td class="paramname">&amp;QHatInvModqPrecon</td><td>NTL-specific precomputations </td></tr>
    <tr><td class="paramname">&amp;QHatModp</td><td>precomputed values for [Q/q_i]_{p_j} </td></tr>
    <tr><td class="paramname">&amp;modpBarrettMu</td><td>128-bit Barrett reduction precomputed values for p_j </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the representation of {X + alpha*Q} in basis {Q,P}. </dd></dl>

</div>
</div>
<a id="a7ca90f477f7a3ebdd52dcacbb49f7f74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ca90f477f7a3ebdd52dcacbb49f7f74">&#9670;&nbsp;</a></span>ApproxScaleAndRound()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual DerivedType <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::ApproxScaleAndRound </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt;&#160;</td>
          <td class="paramname"><em>paramsP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>tPSHatInvModsDivsModp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; DoubleNativeInt &gt; &amp;&#160;</td>
          <td class="paramname"><em>modpBarretMu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes approximate scale and round: {X}_{Q,P} -&gt; {\approx{t/Q * X}}_{P} {Q} = {q_1,...,q_l} {P} = {p_1,...,p_k}. </p>
<p>Brief algorithm: Let S = {Q,P} 1) [\sum_k x_k * alpha_k]_{p_j} 2) alpha_k = [Floor[t*P*[[SHatInv_k]_{s_k}/s_k]]_{p_j}</p>
<p>Source: Halevi S., Polyakov Y., and Shoup V. An Improved RNS Variant of the BFV Homomorphic Encryption Scheme. Cryptology ePrint Archive, Report 2018/117. (<a href="https://eprint.iacr.org/2018/117">https://eprint.iacr.org/2018/117</a>)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;paramsP</td><td>parameters for the CRT basis {p_1,...,p_k} </td></tr>
    <tr><td class="paramname">&amp;tPSHatInvModsDivsModp</td><td>precomputed values for [\floor[t*P*[[SHatInv_k]_{s_k}/s_k]]_{p_j} </td></tr>
    <tr><td class="paramname">&amp;modpBarretMu</td><td>128-bit Barrett reduction precomputed values for p_j </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result {\approx{t/Q * X}}_{P} </dd></dl>

</div>
</div>
<a id="ac03b0bd8ca326b7936dc04122b31c6df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac03b0bd8ca326b7936dc04122b31c6df">&#9670;&nbsp;</a></span>ApproxSwitchCRTBasis()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual DerivedType <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::ApproxSwitchCRTBasis </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt;&#160;</td>
          <td class="paramname"><em>paramsQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt;&#160;</td>
          <td class="paramname"><em>paramsP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>QHatInvModq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>QHatInvModqPrecon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>QHatModp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; DoubleNativeInt &gt; &amp;&#160;</td>
          <td class="paramname"><em>modpBarrettMu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs approximate CRT basis switching: {X}_{Q} -&gt; {X'}_{P} X' = X + alpha*Q for small alpha {Q} = {q_1,...,q_l} {P} = {p_1,...,p_k}. </p>
<p>Brief algorithm: [X']_{p_j} = [\sum_i([x_i*(Q/q_i)^{-1}]_{q_i}*(Q/q_i)]_{p_j}</p>
<p>Source: "A full RNS variant of approximate homomorphic encryption" by Cheon, et. al.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;paramsQ</td><td>parameters for the CRT basis {q_1,...,q_l} </td></tr>
    <tr><td class="paramname">&amp;paramsP</td><td>parameters for the CRT basis {p_1,...,p_k} </td></tr>
    <tr><td class="paramname">&amp;QHatinvModq</td><td>precomputed values for [(Q/q_i)^{-1}]_{q_i} </td></tr>
    <tr><td class="paramname">&amp;QHatinvModqPrecon</td><td>NTL-specific precomputations </td></tr>
    <tr><td class="paramname">&amp;QHatModp</td><td>precomputed values for [Q/q_i]_{p_j} </td></tr>
    <tr><td class="paramname">&amp;modpBarrettMu</td><td>128-bit Barrett reduction precomputed values </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the representation of {X + alpha*Q} in basis {P}. </dd></dl>

</div>
</div>
<a id="a51c801b6fd516206b274d90163dd4bf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51c801b6fd516206b274d90163dd4bf1">&#9670;&nbsp;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual BigIntType&amp; <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::at </td>
          <td>(</td>
          <td class="paramtype">usint&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get interpolated value of elements at all tower index i. Note this operation is computationally intense. Does bound checking. </p>
<dl class="section return"><dt>Returns</dt><dd>interpolated value at index i. </dd></dl>

<p>Reimplemented from <a class="el" href="classlbcrypto_1_1ILElement.html#a359fe4a33cd095b663313d970518c1b7">lbcrypto::ILElement&lt; DerivedType, BigVector &gt;</a>.</p>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a3de4e1a07f58874a6f03f9de8cca63c2">lbcrypto::DCRTPolyImpl&lt; VecType &gt;</a>, and <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a3de4e1a07f58874a6f03f9de8cca63c2">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="a703db5691aa73e9b2988b07376017219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a703db5691aa73e9b2988b07376017219">&#9670;&nbsp;</a></span>AutomorphismTransform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual DerivedType <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::AutomorphismTransform </td>
          <td>(</td>
          <td class="paramtype">const usint &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Permutes coefficients in a polynomial. Moves the ith index to the first one, it only supports odd indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;i</td><td>is the element to perform the automorphism transform with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the automorphism transform. </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1ILElement.html#ac5dcc9fbc3a60640bb1722f236b2bdb8">lbcrypto::ILElement&lt; DerivedType, BigVector &gt;</a>.</p>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#ae7336e935f2a0cd14d6bcfc8a8a2f373">lbcrypto::DCRTPolyImpl&lt; VecType &gt;</a>, and <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#ae7336e935f2a0cd14d6bcfc8a8a2f373">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="a5805c88f6af7bb50febbfe8d436298ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5805c88f6af7bb50febbfe8d436298ab">&#9670;&nbsp;</a></span>AutomorphismTransform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual DerivedType <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::AutomorphismTransform </td>
          <td>(</td>
          <td class="paramtype">usint&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; usint &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs an automorphism transform operation using precomputed bit reversal indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;i</td><td>is the element to perform the automorphism transform with. </td></tr>
    <tr><td class="paramname">&amp;map</td><td>a vector with precomputed indices </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the automorphism transform. </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1ILElement.html#afc8d59503d85d7ad398b1a287fd86e1c">lbcrypto::ILElement&lt; DerivedType, BigVector &gt;</a>.</p>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a77f3f1e018b1687961203d6af9b7b1c6">lbcrypto::DCRTPolyImpl&lt; VecType &gt;</a>, and <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a77f3f1e018b1687961203d6af9b7b1c6">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="af494504657264b13c00a15bc27810dba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af494504657264b13c00a15bc27810dba">&#9670;&nbsp;</a></span>BaseDecompose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;DerivedType&gt; <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::BaseDecompose </td>
          <td>(</td>
          <td class="paramtype">usint&#160;</td>
          <td class="paramname"><em>baseBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>evalModeAnswer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the element as <img class="formulaInl" alt="$ \sum\limits{i=0}^{\lfloor {\log q/base} \rfloor} {(base^i u_i)} $" src="form_0.png"/> and return the vector of <img class="formulaInl" alt="$ \left\{u_0, u_1,...,u_{\lfloor {\log q/base} \rfloor} \right\} \in R_{{base}^{\lceil {\log q/base} \rceil}} $" src="form_1.png"/>; This is used as a subroutine in the relinearization procedure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseBits</td><td>is the number of bits in the base, i.e., <img class="formulaInl" alt="$ base = 2^{baseBits} $" src="form_2.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the pointer where the base decomposition vector is stored</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>not efficient and not fast, uses multiprecision arithmetic and will be removed in future. Use </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#afa5771dde254b6445a252714933504bb">DCRTPolyInterface::CRTDecompose</a> instead. </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1ILElement.html#a04e988bc884a7592cf9bf6f35f5ffca5">lbcrypto::ILElement&lt; DerivedType, BigVector &gt;</a>.</p>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#afceb52d627d4e7c5c03efaf5a1144bb3">lbcrypto::DCRTPolyImpl&lt; VecType &gt;</a>, and <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#afceb52d627d4e7c5c03efaf5a1144bb3">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="a122a57c82a7aa913148ef673fdfb74aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a122a57c82a7aa913148ef673fdfb74aa">&#9670;&nbsp;</a></span>CloneTowers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual DerivedType <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::CloneTowers </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>startTower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>endTower</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a copy of the DCRTPoly, but it includes only a sequential subset of the towers that the original holds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startTower</td><td>The index number of the first tower to clone </td></tr>
    <tr><td class="paramname">endTower</td><td>The index number of the last tower to clone </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new Element </dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a81ddfb19d04d8ad8ca182728a2729006">lbcrypto::DCRTPolyImpl&lt; VecType &gt;</a>, and <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a81ddfb19d04d8ad8ca182728a2729006">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="afa5771dde254b6445a252714933504bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa5771dde254b6445a252714933504bb">&#9670;&nbsp;</a></span>CRTDecompose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;DerivedType&gt; <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::CRTDecompose </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseBits</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>CRT basis decomposition of c as [c qi/q]_qi</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;baseBits</td><td>bits in the base for additional digit decomposition if base &gt; 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the pointer where the resulting vector is stored </dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#adde6e16e5192893c3aa1fd24e23826ce">lbcrypto::DCRTPolyImpl&lt; VecType &gt;</a>, and <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#adde6e16e5192893c3aa1fd24e23826ce">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="a498cdac8c2f3f8dbbe9fccc9b8d5de87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a498cdac8c2f3f8dbbe9fccc9b8d5de87">&#9670;&nbsp;</a></span>CRTInterpolate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyLargeType</a> <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::CRTInterpolate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interpolates the DCRTPoly to an Poly based on the Chinese Remainder Transform Interpolation. and then returns a Poly with that single element. </p>
<dl class="section return"><dt>Returns</dt><dd>the interpolated ring element as a Poly object. </dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a10aa386efd097ac88b00c6670f147023">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="a8a1dc378f31930ed354ef77ed7351d9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a1dc378f31930ed354ef77ed7351d9b">&#9670;&nbsp;</a></span>CRTInterpolateIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyLargeType</a> <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::CRTInterpolateIndex </td>
          <td>(</td>
          <td class="paramtype">usint&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interpolates the DCRTPoly to an Poly based on the Chinese Remainder Transform Interpolation, only at element index i, all other elements are zero. and then returns a Poly with that single element. </p>
<dl class="section return"><dt>Returns</dt><dd>the interpolated ring element as a Poly object. </dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#ac03600bc778887c747ac27e74704ccf5">lbcrypto::DCRTPolyImpl&lt; VecType &gt;</a>, and <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#ac03600bc778887c747ac27e74704ccf5">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="a509bf1d5399f63247aa1af0aa1ebd4df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a509bf1d5399f63247aa1af0aa1ebd4df">&#9670;&nbsp;</a></span>DivideAndRound()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual DerivedType <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::DivideAndRound </td>
          <td>(</td>
          <td class="paramtype">const BigIntType &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scalar division followed by rounding operation - operation on all entries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;q</td><td>is the element to divide entry-wise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the return value of the divide, followed by rounding operation.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Will remove, this is only inplace because of BFV </dd></dl>

</div>
</div>
<a id="a454428f6f25cca22c8194788c549a5f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a454428f6f25cca22c8194788c549a5f6">&#9670;&nbsp;</a></span>DropLastElementAndScale()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::DropLastElementAndScale </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>QlQlInvModqlDivqlModq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>QlQlInvModqlDivqlModqPrecon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>qlInvModq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>qlInvModqPrecon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drops the last element in the double-CRT representation and scales down by the last CRT modulus. The resulting DCRTPoly element will have one less tower. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;QlQlInvModqlDivqlModq</td><td>precomputed values for [Q^(l)*[Q^(l)^{-1}]_{q_l}/q_l]_{q_i} </td></tr>
    <tr><td class="paramname">&amp;QlQlInvModqlDivqlModqPrecon</td><td>NTL-specific precomputations </td></tr>
    <tr><td class="paramname">&amp;qlInvModq</td><td>precomputed values for [q_l^{-1}]_{q_i} </td></tr>
    <tr><td class="paramname">&amp;qlInvModqPrecon</td><td>NTL-specific precomputations </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a250b81c51dea6af83acf0fd2fc14f365">lbcrypto::DCRTPolyImpl&lt; VecType &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a250b81c51dea6af83acf0fd2fc14f365">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>, <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html#af66a8858b3583ee1410099cd9c745db3">lbcrypto::HexlDCRTPoly&lt; VecType &gt;</a>, and <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html#af66a8858b3583ee1410099cd9c745db3">lbcrypto::HexlDCRTPoly&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="a8a68eccc6f73da3f18aa3d493db9209d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a68eccc6f73da3f18aa3d493db9209d">&#9670;&nbsp;</a></span>ElementAtIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual TowerType&amp; <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::ElementAtIndex </td>
          <td>(</td>
          <td class="paramtype">usint&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get value of element at index i. </p>
<dl class="section return"><dt>Returns</dt><dd>value at index i.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Should be removed to disable access to the towers, all modifications in the lattice layer should be done in the lattice layer. This means new functions will be need in the lattice layer. </dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a4f16ebd27ef359ce367fc8d6669c1a67">lbcrypto::DCRTPolyImpl&lt; VecType &gt;</a>, and <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a4f16ebd27ef359ce367fc8d6669c1a67">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="a41f9144151b30ee7218e8d855930d640"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41f9144151b30ee7218e8d855930d640">&#9670;&nbsp;</a></span>ExpandCRTBasis()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::ExpandCRTBasis </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt;&#160;</td>
          <td class="paramname"><em>paramsQP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt;&#160;</td>
          <td class="paramname"><em>paramsP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>QHatInvModq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>QHatInvModqPrecon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>QHatModp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>alphaQModp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; DoubleNativeInt &gt; &amp;&#160;</td>
          <td class="paramname"><em>modpBarrettMu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>qInv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Format&#160;</td>
          <td class="paramname"><em>resultFormat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs modulus raising: {X}_{Q} -&gt; {X}_{Q,P} {Q} = {q_1,...,q_l} {P} = {p_1,...,p_k}. </p>
<p>Brief algorithm: {X}_{Q} -&gt; {X}_P : use <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a84c8c9ac3d8593ad61784f4b9d9624cc" title="Performs CRT basis switching: {X}_{Q} -&gt; {X}_{P} {Q} = {q_1,...,q_l} {P} = {p_1,.....">DCRTPoly::SwitchCRTBasis</a> combine {X}_{Q} and {X}_{P} Outputs the resulting polynomial in CRT/RNS</p>
<p>Source: Halevi S., Polyakov Y., and Shoup V. An Improved RNS Variant of the BFV Homomorphic Encryption Scheme. Cryptology ePrint Archive, Report 2018/117. (<a href="https://eprint.iacr.org/2018/117">https://eprint.iacr.org/2018/117</a>)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;paramsQP</td><td>parameters for the CRT basis {q_1,...,q_l,p_1,...,p_k} </td></tr>
    <tr><td class="paramname">&amp;paramsP</td><td>parameters for the CRT basis {p_1,...,p_k} </td></tr>
    <tr><td class="paramname">&amp;QHatInvModq</td><td>precomputed values for [QInv_i]_{q_i} </td></tr>
    <tr><td class="paramname">&amp;QHatInvModqPrecon</td><td>NTL-specific precomputations </td></tr>
    <tr><td class="paramname">&amp;QHatModp</td><td>precomputed values for [QHat_i]_{p_j} </td></tr>
    <tr><td class="paramname">&amp;alphaQModp</td><td>precomputed values for [alpha*Q]_{p_j} </td></tr>
    <tr><td class="paramname">&amp;modpBarrettMu</td><td>128-bit Barrett reduction precomputed values for p_j @params &amp;qInv precomputed values for 1/q_i </td></tr>
    <tr><td class="paramname">resultFormat</td><td>Specifies the format we want the result to be in </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8eca50ec338533d004b18584cd6ab157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eca50ec338533d004b18584cd6ab157">&#9670;&nbsp;</a></span>FastBaseConvqToBskMontgomery()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::FastBaseConvqToBskMontgomery </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt;&#160;</td>
          <td class="paramname"><em>paramsBsk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>moduliQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>moduliBsk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; DoubleNativeInt &gt; &amp;&#160;</td>
          <td class="paramname"><em>modbskBarrettMu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mtildeQHatInvModq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mtildeQHatInvModqPrecon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>QHatModbsk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint16_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>QHatModmtilde</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>QModbsk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>QModbskPrecon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t &amp;&#160;</td>
          <td class="paramname"><em>negQInvModmtilde</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mtildeInvModbsk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mtildeInvModbskPrecon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expands basis: {X}_{Q} -&gt; {X}_{Q,Bsk,mtilde} mtilde is a redundant modulus used to remove q overflows generated from fast conversion. Outputs the resulting polynomial in CRT/RNS {Q} = {q_1,...,q_l} {Bsk} = {bsk_1,...,bsk_k}. </p>
<p>Source: Jean-Claude Bajard and Julien Eynard and Anwar Hasan and Vincent Zucca. A Full RNS Variant of FV like Somewhat Homomorphic Encryption Schemes. Cryptology ePrint Archive: Report 2016/510. (<a href="https://eprint.iacr.org/2016/510">https://eprint.iacr.org/2016/510</a>)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">paramsBsk</td><td>container of Bsk moduli and roots on unity </td></tr>
    <tr><td class="paramname">&amp;moduliQ</td><td>basis {Q} = {q_1,q_2,...,q_l} </td></tr>
    <tr><td class="paramname">&amp;moduliBsk</td><td>basis {Bsk U mtilde} ... </td></tr>
    <tr><td class="paramname">&amp;modbskBarrettMu</td><td>128-bit Barrett reduction precomputed values for bsk_j </td></tr>
    <tr><td class="paramname">&amp;mtildeQHatInvModq</td><td>[mtilde*(Q/q_i)^{-1}]_{q_i} </td></tr>
    <tr><td class="paramname">&amp;mtildeQHatInvModqPrecon</td><td>NTL-specific precomputations </td></tr>
    <tr><td class="paramname">&amp;QHatModbsk</td><td>[Q/q_i]_{bsk_j} </td></tr>
    <tr><td class="paramname">&amp;QHatModmtilde</td><td>[Q/q_i]_{mtilde} </td></tr>
    <tr><td class="paramname">&amp;QModbsk</td><td>[Q]_{bsk_j} </td></tr>
    <tr><td class="paramname">&amp;QModbskPrecon</td><td>NTL-specific precomputations </td></tr>
    <tr><td class="paramname">&amp;negQInvModmtilde</td><td>[-Q^{-1}]_{mtilde} </td></tr>
    <tr><td class="paramname">&amp;mtildeInvModbsk</td><td>[mtilde^{-1}]_{bsk_j} </td></tr>
    <tr><td class="paramname">&amp;mtildeInvModbskPrecon</td><td>NTL-specific precomputations </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb8755ad950dc46a5400facfa3f39c32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb8755ad950dc46a5400facfa3f39c32">&#9670;&nbsp;</a></span>FastBaseConvSK()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::FastBaseConvSK </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>moduliQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; DoubleNativeInt &gt; &amp;&#160;</td>
          <td class="paramname"><em>modqBarrettMu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>moduliBsk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; DoubleNativeInt &gt; &amp;&#160;</td>
          <td class="paramname"><em>modbskBarrettMu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>BHatInvModb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>BHatInvModbPrecon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>BHatModmsk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &amp;&#160;</td>
          <td class="paramname"><em>BInvModmsk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &amp;&#160;</td>
          <td class="paramname"><em>BInvModmskPrecon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>BHatModq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>BModq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>BModqPrecon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts basis: {X}_{Q,Bsk} -&gt; {X}_{Bsk} {Q} = {q_1,...,q_l} {Bsk} = {bsk_1,...,bsk_k} using Shenoy Kumaresan method. Outputs the resulting polynomial in CRT/RNS. </p>
<p>Source: Jean-Claude Bajard and Julien Eynard and Anwar Hasan and Vincent Zucca. A Full RNS Variant of FV like Somewhat Homomorphic Encryption Schemes. Cryptology ePrint Archive: Report 2016/510. (<a href="https://eprint.iacr.org/2016/510">https://eprint.iacr.org/2016/510</a>)</p>
<p>Note in the source paper, B is referred to by M.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;moduliQ</td><td>basis Q = {q_1,...,q_l} </td></tr>
    <tr><td class="paramname">&amp;modqBarrettMu</td><td>precomputed Barrett Mu for q_i </td></tr>
    <tr><td class="paramname">&amp;moduliBsk</td><td>basis {Bsk} = {bsk_1,...,bsk_k} </td></tr>
    <tr><td class="paramname">&amp;modbskBarrettMu</td><td>precomputed Barrett Mu for bsk_j </td></tr>
    <tr><td class="paramname">&amp;BHatInvModb</td><td>[(B/b_j)^{-1}]_{b_j} </td></tr>
    <tr><td class="paramname">&amp;BHatInvModbPrecon</td><td><a class="el" href="namespaceNTL.html">NTL</a> precomptations for [(B/b_j)^{-1}]_{b_j} </td></tr>
    <tr><td class="paramname">&amp;BHatModmsk</td><td>[B/b_j]_{msk} </td></tr>
    <tr><td class="paramname">&amp;BInvModmsk</td><td>[B^{-1}]_{msk} </td></tr>
    <tr><td class="paramname">&amp;BInvModmskPrecon</td><td><a class="el" href="namespaceNTL.html">NTL</a> precomptation for [B^{-1}]_{msk} </td></tr>
    <tr><td class="paramname">&amp;BHatModq</td><td>[B/b_j]_{q_i} </td></tr>
    <tr><td class="paramname">&amp;BModq</td><td>[B]_{q_i} </td></tr>
    <tr><td class="paramname">&amp;BModqPrecon</td><td><a class="el" href="namespaceNTL.html">NTL</a> precomptations for [B]_{q_i} </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a175720c325d466f6eb7505f65035b849">lbcrypto::DCRTPolyImpl&lt; VecType &gt;</a>, and <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a175720c325d466f6eb7505f65035b849">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="a79ab7c03584ce526f115af9f8690519c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79ab7c03584ce526f115af9f8690519c">&#9670;&nbsp;</a></span>FastRNSFloorq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::FastRNSFloorq </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>moduliQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>moduliBsk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; DoubleNativeInt &gt; &amp;&#160;</td>
          <td class="paramname"><em>modbskBarrettMu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tQHatInvModq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tQHatInvModqPrecon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>QHatModbsk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>qInvModbsk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tQInvModbsk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tQInvModbskPrecon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes scale and floor: {X}_{Q,Bsk} -&gt; {\floor{t/Q * X}}_{Bsk} {Q} = {q_1,...,q_l} {Bsk} = {bsk_1,...,bsk_k} Outputs the resulting polynomial in CRT/RNS. </p>
<p>Source: Jean-Claude Bajard and Julien Eynard and Anwar Hasan and Vincent Zucca. A Full RNS Variant of FV like Somewhat Homomorphic Encryption Schemes. Cryptology ePrint Archive: Report 2016/510. (<a href="https://eprint.iacr.org/2016/510">https://eprint.iacr.org/2016/510</a>)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;t</td><td>plaintext modulus </td></tr>
    <tr><td class="paramname">&amp;moduliQ</td><td>{Q} = {q_1,...,q_l} </td></tr>
    <tr><td class="paramname">&amp;moduliBsk</td><td>{Bsk} = {bsk_1,...,bsk_k} </td></tr>
    <tr><td class="paramname">&amp;modbskBarrettMu</td><td>128-bit Barrett reduction precomputed values for bsk_j </td></tr>
    <tr><td class="paramname">&amp;tQHatInvModq</td><td>[(Q/q_i)^{-1}]_{q_i} </td></tr>
    <tr><td class="paramname">&amp;tQHatInvModqPrecon</td><td>NTL-specific precomputations </td></tr>
    <tr><td class="paramname">&amp;QHatModbsk</td><td>[Q/q_i]_{bsk_i} </td></tr>
    <tr><td class="paramname">&amp;qInvModbsk</td><td>[(q_i)^{-1}]_{bsk_j} </td></tr>
    <tr><td class="paramname">&amp;tQInvModbsk</td><td>[t*Q^{-1}]_{bsk_j} </td></tr>
    <tr><td class="paramname">&amp;tQInvModbskPrecon</td><td>NTL-specific precomputations </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a7ebeafa37c47d074c2ed333c6ffbc960">lbcrypto::DCRTPolyImpl&lt; VecType &gt;</a>, and <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a7ebeafa37c47d074c2ed333c6ffbc960">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="a93d5dbd1bbfb043b71fa773b9d3f7f08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93d5dbd1bbfb043b71fa773b9d3f7f08">&#9670;&nbsp;</a></span>GetAllElements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::vector&lt;TowerType&gt;&amp; <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::GetAllElements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get method that returns a vector of all component elements. </p>
<dl class="section return"><dt>Returns</dt><dd>a vector of the component elements. </dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a60dc86e2084a250d002f47c7581a9990">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="a40c59a54a3117891aaf660f5d2f0bea2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40c59a54a3117891aaf660f5d2f0bea2">&#9670;&nbsp;</a></span>GetCyclotomicOrder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual usint <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::GetCyclotomicOrder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the element's cyclotomic order </p>
<dl class="section return"><dt>Returns</dt><dd>returns the cyclotomic order of the element. </dd></dl>

</div>
</div>
<a id="a6cdf654d89986d28366885e364d80080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cdf654d89986d28366885e364d80080">&#9670;&nbsp;</a></span>GetDerived() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DerivedType&amp; <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::GetDerived </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the Derived object, this is apart of the CRTP software design pattern it allows the base class (this one) to implement methods that call the derived objects implementation. </p>
<p>Chapter 21.2 "C++ Templates The Complete Guide" by David Vandevoorde and Nicolai M. Josuttis <a href="http://www.informit.com/articles/article.asp?p=31473">http://www.informit.com/articles/article.asp?p=31473</a></p>
<dl class="section return"><dt>Returns</dt><dd>DerivedType&amp; </dd></dl>

</div>
</div>
<a id="a4d67b375b98e88fb78392f2d214d5458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d67b375b98e88fb78392f2d214d5458">&#9670;&nbsp;</a></span>GetDerived() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const DerivedType&amp; <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::GetDerived </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a6cdf654d89986d28366885e364d80080" title="Get the Derived object, this is apart of the CRTP software design pattern it allows the base class (t...">GetDerived</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>DerivedType const&amp; </dd></dl>

</div>
</div>
<a id="a62144e300a0691110a99511b9f21617b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62144e300a0691110a99511b9f21617b">&#9670;&nbsp;</a></span>GetElementAtIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const TowerType&amp; <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::GetElementAtIndex </td>
          <td>(</td>
          <td class="paramtype">usint&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get method of individual tower of elements. Note this behavior is different than poly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>index of tower to be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the returned tower </dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a943ae946b1541b8968e008e8f5c9d839">lbcrypto::DCRTPolyImpl&lt; VecType &gt;</a>, and <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a943ae946b1541b8968e008e8f5c9d839">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="ae5154189bc463d2babe5f6128b09b85d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5154189bc463d2babe5f6128b09b85d">&#9670;&nbsp;</a></span>GetExtendedCRTBasis()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual shared_ptr&lt;<a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a>&gt; <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::GetExtendedCRTBasis </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt;&#160;</td>
          <td class="paramname"><em>paramsP</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the element parameters for DCRTPoly elements in an extended CRT basis, which is the concatenation of the towers currently in "this" DCRTPoly, and the moduli in ParamsP. </p>
<dl class="section return"><dt>Returns</dt><dd>element parameters of the extended basis. </dd></dl>

</div>
</div>
<a id="a09b5764dee7d4a77f0a8832d94ba37f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09b5764dee7d4a77f0a8832d94ba37f5">&#9670;&nbsp;</a></span>GetFormat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Format <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::GetFormat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get method of the format. </p>
<dl class="section return"><dt>Returns</dt><dd>the format, either COEFFICIENT or EVALUATION </dd></dl>

</div>
</div>
<a id="add0c94d87832fec8fa4c2c60aa1fd23e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add0c94d87832fec8fa4c2c60aa1fd23e">&#9670;&nbsp;</a></span>GetLength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual usint <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::GetLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get method for length of each component element. NOTE assumes all components are the same size. (Ring Dimension) </p>
<dl class="section return"><dt>Returns</dt><dd>length of the component element </dd></dl>

</div>
</div>
<a id="a20af925ea09544588f834f8021d68f9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20af925ea09544588f834f8021d68f9a">&#9670;&nbsp;</a></span>GetModulus()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const BigIntType&amp; <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::GetModulus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the element's modulus </p>
<dl class="section return"><dt>Returns</dt><dd>returns the modulus of the element. </dd></dl>

</div>
</div>
<a id="a66f373c9110cff8599393a6fc47390bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66f373c9110cff8599393a6fc47390bb">&#9670;&nbsp;</a></span>GetNumOfElements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual usint <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::GetNumOfElements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get method of the number of component elements, also known as the number of towers. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of component elements. </dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#ac5123c286785633ed7726dda3a2de9e9">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="a5a131ad02f83ced06622e6d8e00fb6c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a131ad02f83ced06622e6d8e00fb6c2">&#9670;&nbsp;</a></span>GetOriginalModulus()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const BigIntType&amp; <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::GetOriginalModulus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the element's original modulus, derived from Poly </p>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>returns the modulus of the element. </dd></dl>

</div>
</div>
<a id="ac8aaf7680a031550d84687c9d9c0ae1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8aaf7680a031550d84687c9d9c0ae1a">&#9670;&nbsp;</a></span>GetParams()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const shared_ptr&lt;<a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a>&gt; <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::GetParams </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the parameters of the element. </p>
<dl class="section return"><dt>Returns</dt><dd>the element parameter set. </dd></dl>

</div>
</div>
<a id="a20fe813cfd6a8f469a5f585d9b1adc42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20fe813cfd6a8f469a5f585d9b1adc42">&#9670;&nbsp;</a></span>GetRingDimension()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual usint <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::GetRingDimension </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the element's ring dimension </p>
<dl class="section return"><dt>Returns</dt><dd>returns the ring dimension of the element. </dd></dl>

</div>
</div>
<a id="a0c943dd0618aeb63c915250be84c10cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c943dd0618aeb63c915250be84c10cd">&#9670;&nbsp;</a></span>GetRootOfUnity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const BigIntType&amp; <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::GetRootOfUnity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the element's root of unity. </p>
<dl class="section return"><dt>Returns</dt><dd>the element's root of unity. </dd></dl>

</div>
</div>
<a id="af35691c5c689c9804b87ad18e08269ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af35691c5c689c9804b87ad18e08269ba">&#9670;&nbsp;</a></span>GetValues()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const BigVecType&amp; <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::GetValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get method that should not be used. </p>
<dl class="section return"><dt>Returns</dt><dd>will throw an error.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Doesn't make sense for DCRT </dd></dl>

</div>
</div>
<a id="abb38c09cf2d6bc44acce65cd6d3cc064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb38c09cf2d6bc44acce65cd6d3cc064">&#9670;&nbsp;</a></span>GetWorkingModulus()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual BigIntType <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::GetWorkingModulus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes and returns the product of primes in the current moduli chain. Compared to GetModulus, which always returns the product of all primes in the crypto parameters, this method will return a different modulus, based on the towers/moduli that are currently in the chain (some towers are dropped along the way). </p>
<dl class="section return"><dt>Returns</dt><dd>the product of moduli in the current towers. </dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a63d3e755fea7654aa9b3e7bd14e42a8d">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="a6d84bf03f20db3d0b46a40efb7d9f746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d84bf03f20db3d0b46a40efb7d9f746">&#9670;&nbsp;</a></span>InverseExists()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::InverseExists </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if inverse exists. </p>
<dl class="section return"><dt>Returns</dt><dd>is the Boolean representation of the existence of multiplicative inverse. </dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a344d2b7f16a8aa10a4006dfd972a78e1">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="a278d9399c70da14dd2984df93749d881"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a278d9399c70da14dd2984df93749d881">&#9670;&nbsp;</a></span>IsEmpty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::IsEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if ALL the tower(s) are empty. </p>
<dl class="section return"><dt>Returns</dt><dd>true if all towers are empty </dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#abc4b6a822c5551bf0f23b61e1426d26e">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="ae22cd32bfb9e99d19fa87cba5c4c9c2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae22cd32bfb9e99d19fa87cba5c4c9c2b">&#9670;&nbsp;</a></span>MakeDiscreteGaussianCoefficientAllocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static function&lt;DerivedType()&gt; <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::MakeDiscreteGaussianCoefficientAllocator </td>
          <td>(</td>
          <td class="paramtype">shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Format&#160;</td>
          <td class="paramname"><em>resultFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>stddev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classAllocator.html">Allocator</a> for discrete uniform distribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td><a class="el" href="classlbcrypto_1_1Params.html">Params</a> instance that is is passed. </td></tr>
    <tr><td class="paramname">resultFormat</td><td>resultFormat for the polynomials generated. </td></tr>
    <tr><td class="paramname">stddev</td><td>standard deviation for the discrete gaussian generator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting vector. </dd></dl>

</div>
</div>
<a id="a4b2b29ed26d54b371f8bbe545292cd90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b2b29ed26d54b371f8bbe545292cd90">&#9670;&nbsp;</a></span>MakeDiscreteUniformAllocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static function&lt;DerivedType()&gt; <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::MakeDiscreteUniformAllocator </td>
          <td>(</td>
          <td class="paramtype">shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Format&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classAllocator.html">Allocator</a> for discrete uniform distribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td><a class="el" href="classlbcrypto_1_1Params.html">Params</a> instance that is is passed. </td></tr>
    <tr><td class="paramname">format</td><td>format for the polynomials generated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting vector. </dd></dl>

</div>
</div>
<a id="a4c06761fc369968fe907d8aaea9596fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c06761fc369968fe907d8aaea9596fc">&#9670;&nbsp;</a></span>MakeSparse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::MakeSparse </td>
          <td>(</td>
          <td class="paramtype">const uint32_t &amp;&#160;</td>
          <td class="paramname"><em>wFactor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make DCRTPoly Sparse. Sets every index of each tower not equal to zero mod the wFactor to zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;wFactor</td><td>ratio between the sparse and none-sparse values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Only used by RingSwitching, which is no longer supported. Will be removed in future. </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1ILElement.html#a470e37bbdb57df7b3e5a6ebd3d2f0f51">lbcrypto::ILElement&lt; DerivedType, BigVector &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a13383a02ee6a007a1c4cf5ea07c3c707">lbcrypto::DCRTPolyImpl&lt; VecType &gt;</a>, and <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a13383a02ee6a007a1c4cf5ea07c3c707">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="a1dfadd41ee3fc03df8375b1548e619ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dfadd41ee3fc03df8375b1548e619ec">&#9670;&nbsp;</a></span>Minus() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual DerivedType <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::Minus </td>
          <td>(</td>
          <td class="paramtype">const BigIntType &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scalar subtraction - subtract an element to all entries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;element</td><td>is the element to subtract entry-wise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the return value of the minus operation. </dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#ade9a9e38b6c5b4e0a445f1526bb731d6">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="a3ec584b5d32386e4f3682bb8a386aa6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ec584b5d32386e4f3682bb8a386aa6b">&#9670;&nbsp;</a></span>Minus() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual DerivedType <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::Minus </td>
          <td>(</td>
          <td class="paramtype">const DerivedType &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a subtraction operation and returns the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;element</td><td>is the element to subtract from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the subtraction. </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1ILElement.html#a9b308cd85c096a6c150a35a4e8e52970">lbcrypto::ILElement&lt; DerivedType, BigVector &gt;</a>.</p>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a9094f635ef1078a91ffae5c4520e6615">lbcrypto::DCRTPolyImpl&lt; VecType &gt;</a>.</p>

</div>
</div>
<a id="acebbf62af47212eb1ff94d727924ee98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acebbf62af47212eb1ff94d727924ee98">&#9670;&nbsp;</a></span>Minus() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual DerivedType <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::Minus </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; BigIntType &gt; &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scalar subtraction for elements in CRT format. CRT elements are represented as vector of integer elements which correspond to the represented number modulo the primes in the tower chain (in same order). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;element</td><td>is the element to subtract entry-wise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the subtraction operation. </dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a23a9e333f86b9f21ef1cca2e1f1e2280">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="ae234c1d7db46ab3ed963d0ef1257d39b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae234c1d7db46ab3ed963d0ef1257d39b">&#9670;&nbsp;</a></span>Mod()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual DerivedType <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::Mod </td>
          <td>(</td>
          <td class="paramtype">const BigIntType &amp;&#160;</td>
          <td class="paramname"><em>modulus</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modulus - perform a modulus operation. Does proper mapping of [-modulus/2, modulus/2) to [0, modulus) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">modulus</td><td>is the modulus to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the return value of the modulus.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Doesn't make sense for DCRT </dd></dl>

</div>
</div>
<a id="ad10296261f590b69a2efd23a6b57e698"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad10296261f590b69a2efd23a6b57e698">&#9670;&nbsp;</a></span>ModByTwo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual DerivedType <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::ModByTwo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a modulus by 2 operation. Returns the least significant bit. </p>
<dl class="section return"><dt>Returns</dt><dd>is the resulting value.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Doesn't make sense for DCRT </dd></dl>

</div>
</div>
<a id="a25e133a2c25996be14600e54605b8bc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25e133a2c25996be14600e54605b8bc4">&#9670;&nbsp;</a></span>ModReduce()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::ModReduce </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tModqPrecon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &amp;&#160;</td>
          <td class="paramname"><em>negtInvModq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &amp;&#160;</td>
          <td class="paramname"><em>negtInvModqPrecon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>qlInvModq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>qlInvModqPrecon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ModReduces reduces the DCRTPoly element's composite modulus by dropping the last modulus from the chain of moduli as well as dropping the last tower. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;t</td><td>is the plaintextModulus used for the DCRTPoly </td></tr>
    <tr><td class="paramname">&amp;tModqPrecon</td><td>NTL-specific precomputations for [t]_{q_i} </td></tr>
    <tr><td class="paramname">&amp;negtInvModq</td><td>precomputed values for [-t^{-1}]_{q_i} </td></tr>
    <tr><td class="paramname">&amp;negtInvModqPrecon</td><td>NTL-specific precomputations for [-t^{-1}]_{q_i} </td></tr>
    <tr><td class="paramname">&amp;qlInvModq</td><td>precomputed values for [q_{l}^{-1}]_{q_i} </td></tr>
    <tr><td class="paramname">&amp;qlInvModqPrecon</td><td>NTL-specific precomputations for [q_{l}^{-1}]_{q_i} </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a785eaff12419d594ce3255d16894c58f">lbcrypto::DCRTPolyImpl&lt; VecType &gt;</a>, and <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a785eaff12419d594ce3255d16894c58f">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="aa1426c1b052a5ae4b9ccc1b0d738dec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1426c1b052a5ae4b9ccc1b0d738dec1">&#9670;&nbsp;</a></span>MultiplicativeInverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual DerivedType <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::MultiplicativeInverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a multiplicative inverse operation and returns the result. </p>
<dl class="section return"><dt>Returns</dt><dd>is the result of the multiplicative inverse. </dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#acd897dd2c899f77b863fefce1eb8c7eb">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="a9c299cc747f5176cdf79912089e0238d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c299cc747f5176cdf79912089e0238d">&#9670;&nbsp;</a></span>MultiplyAndRound()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual DerivedType <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::MultiplyAndRound </td>
          <td>(</td>
          <td class="paramtype">const BigIntType &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BigIntType &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scalar multiplication followed by division and rounding operation - operation on all entries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;p</td><td>is the element to multiply entry-wise. </td></tr>
    <tr><td class="paramname">&amp;q</td><td>is the element to divide entry-wise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the return value of the multiply, divide and followed by rounding operation.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Will remove, this is only inplace because of BFV </dd></dl>

</div>
</div>
<a id="a6975f0cd6039ceeb1a4ad954519954f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6975f0cd6039ceeb1a4ad954519954f2">&#9670;&nbsp;</a></span>Negate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual DerivedType <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::Negate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a negation operation and returns the result. </p>
<dl class="section return"><dt>Returns</dt><dd>is the result of the negation. </dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a5b406c67506cb08ee38ef69c004daff3">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="a4dce2c859629115a2453bb8726e8e137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dce2c859629115a2453bb8726e8e137">&#9670;&nbsp;</a></span>Norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::Norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the infinity norm, basically the largest value in the ring element. </p>
<dl class="section return"><dt>Returns</dt><dd>is the largest value in the ring element. </dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a214892eae601551e99859e161ddc56eb">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="a649ce1d2b14105bd41e6a33caf7912a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a649ce1d2b14105bd41e6a33caf7912a2">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const DerivedType&amp; <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const BigIntType &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a multiplication operation and returns the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;element</td><td>is the element to multiply by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the multiplication. </dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a63a5c2efe731d3835f1cbfcbfde7c0ca">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="afc908662a421a5f61b9d555cf4feaa51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc908662a421a5f61b9d555cf4feaa51">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const DerivedType&amp; <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const DerivedType &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs an multiplication operation and returns the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;element</td><td>is the element to multiply with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the multiplication. </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1ILElement.html#adecf4245b01406e2a2568fad52434494">lbcrypto::ILElement&lt; DerivedType, BigVector &gt;</a>.</p>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#abc02a96815782bfe2dc8562ed5985030">lbcrypto::DCRTPolyImpl&lt; VecType &gt;</a>.</p>

</div>
</div>
<a id="a126c7febc3ab3bc45522ef94bf835e7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a126c7febc3ab3bc45522ef94bf835e7c">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const DerivedType&amp; <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const DerivedType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs an entry-wise addition over all elements of each tower with the towers of the element on the right hand side. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;rhs</td><td>is the element to add with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the addition. </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1ILElement.html#ad2fa2e51c8be146bdc2b739b40f4bf1f">lbcrypto::ILElement&lt; DerivedType, BigVector &gt;</a>.</p>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#afccab6ba0d328ddb7edcafe133e5d1dc">lbcrypto::DCRTPolyImpl&lt; VecType &gt;</a>.</p>

</div>
</div>
<a id="a98d4c5817cba2c2b2b9188c05870e39f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98d4c5817cba2c2b2b9188c05870e39f">&#9670;&nbsp;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual DerivedType <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::operator- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unary minus on a element. </p>
<dl class="section return"><dt>Returns</dt><dd>additive inverse of the an element. </dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a52f5c45054cfb7fa5587e5f2ba961cde">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="ae624e9a0fb904bdee4c7b536e12d6808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae624e9a0fb904bdee4c7b536e12d6808">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const DerivedType&amp; <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const BigIntType &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a subtraction operation and returns the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;element</td><td>is the element to subtract from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the subtraction. </dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#aa0946e79b8bfd1bb65600b0a203b8899">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="a06ac6a37ad6be0a9055cb9dbedd2a9bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06ac6a37ad6be0a9055cb9dbedd2a9bc">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const DerivedType&amp; <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const DerivedType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs an entry-wise subtraction over all elements of each tower with the towers of the element on the right hand side. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;rhs</td><td>is the element to subtract from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the addition. </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1ILElement.html#a16234919ba5cedf710fe8d6dbd071e44">lbcrypto::ILElement&lt; DerivedType, BigVector &gt;</a>.</p>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#aa965df981061d0f6390293612613b8a1">lbcrypto::DCRTPolyImpl&lt; VecType &gt;</a>.</p>

</div>
</div>
<a id="a6c3acffd584a927600c188a32626b7c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c3acffd584a927600c188a32626b7c5">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const DerivedType&amp; <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const DerivedType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment Operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;rhs</td><td>the copied element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting element. </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1ILElement.html#aa4c6ccfa8477a16e4f11df540100e847">lbcrypto::ILElement&lt; DerivedType, BigVector &gt;</a>.</p>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a194ec63fd9ff31e9bde2974268525ba9">lbcrypto::DCRTPolyImpl&lt; VecType &gt;</a>.</p>

</div>
</div>
<a id="a0cfedcf2b29c343daf88b24a3c52613d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cfedcf2b29c343daf88b24a3c52613d">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual DerivedType&amp; <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a Poly from a vector of signed integers (used for trapdoor sampling) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;rhs</td><td>the vector to set the <a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyImpl</a> to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting <a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyImpl</a>. </dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a1b32d39e39dba41cc4d8b70c3c93acf0">lbcrypto::DCRTPolyImpl&lt; VecType &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a1b32d39e39dba41cc4d8b70c3c93acf0">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>, <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html#a32f69739e67857b9f647e49c8036b616">lbcrypto::HexlDCRTPoly&lt; VecType &gt;</a>, and <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html#a32f69739e67857b9f647e49c8036b616">lbcrypto::HexlDCRTPoly&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="a2ecc645e7b55894a3f94280b41e9f982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ecc645e7b55894a3f94280b41e9f982">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual DerivedType&amp; <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a Poly from a vector of signed integers (used for trapdoor sampling) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;rhs</td><td>the vector to set the <a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyImpl</a> to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting <a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyImpl</a>. </dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a1a5a9c1ab6486c7dcd7dd57d6a225872">lbcrypto::DCRTPolyImpl&lt; VecType &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a1a5a9c1ab6486c7dcd7dd57d6a225872">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>, <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html#ac9b1f3ddb28c85c6eed67756727026bd">lbcrypto::HexlDCRTPoly&lt; VecType &gt;</a>, and <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html#ac9b1f3ddb28c85c6eed67756727026bd">lbcrypto::HexlDCRTPoly&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="a7b97ec6ea90493c8c4ef7e77bf7f4800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b97ec6ea90493c8c4ef7e77bf7f4800">&#9670;&nbsp;</a></span>operator=() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const DerivedType&amp; <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">DerivedType &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move Assignment Operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;rhs</td><td>the copied element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting element. </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1ILElement.html#a1cc3339607ccbccb15fcfe8deb84b3be">lbcrypto::ILElement&lt; DerivedType, BigVector &gt;</a>.</p>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#abd56802ffaaabf5f8b8e1ebaec49a529">lbcrypto::DCRTPolyImpl&lt; VecType &gt;</a>.</p>

</div>
</div>
<a id="af06c30c5d62fb3b177a9eecacc1e7e0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af06c30c5d62fb3b177a9eecacc1e7e0e">&#9670;&nbsp;</a></span>operator=() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual DerivedType&amp; <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initalizer list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;rhs</td><td>the list to set the <a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyImpl</a> to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting <a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyImpl</a>. </dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a50eb6a2455f926c4a1963b4a59459d7c">lbcrypto::DCRTPolyImpl&lt; VecType &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a50eb6a2455f926c4a1963b4a59459d7c">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>, <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html#a5977421f361f0fbfb3c4514036453a6c">lbcrypto::HexlDCRTPoly&lt; VecType &gt;</a>, and <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html#a5977421f361f0fbfb3c4514036453a6c">lbcrypto::HexlDCRTPoly&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="a3c21084ea80bc73c22800792f78efa26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c21084ea80bc73c22800792f78efa26">&#9670;&nbsp;</a></span>operator=() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual DerivedType&amp; <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; uint64_t &gt;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initalizer list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;rhs</td><td>the list to initalized the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting element. </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1ILElement.html#a7d6c463d45b96bd973af2c5564b62ced">lbcrypto::ILElement&lt; DerivedType, BigVector &gt;</a>.</p>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a2758f06a1075c396b73344ed3a13a734">lbcrypto::DCRTPolyImpl&lt; VecType &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a2758f06a1075c396b73344ed3a13a734">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>, <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html#af5f92cd8de1c2158c048379eb3a7d936">lbcrypto::HexlDCRTPoly&lt; VecType &gt;</a>, and <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html#af5f92cd8de1c2158c048379eb3a7d936">lbcrypto::HexlDCRTPoly&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="afa510d16766774ae7e15c52f08db2b82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa510d16766774ae7e15c52f08db2b82">&#9670;&nbsp;</a></span>operator=() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual DerivedType&amp; <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment Operator. The usint val will be set at index zero and all other indices will be set to zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>is the usint to assign to index zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting vector. </dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a4423d9b9a6034d499e45c4f15ba969d5">lbcrypto::DCRTPolyImpl&lt; VecType &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a4423d9b9a6034d499e45c4f15ba969d5">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>, <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html#aaeb069d4a0538c0bc7e54a8d43ab9cc9">lbcrypto::HexlDCRTPoly&lt; VecType &gt;</a>, and <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html#aaeb069d4a0538c0bc7e54a8d43ab9cc9">lbcrypto::HexlDCRTPoly&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="a845271828e9e902a65840752b3fdcc16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a845271828e9e902a65840752b3fdcc16">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const DerivedType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;rhs</td><td>is the specified element to be compared with this element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this element represents the same values as the specified element, false otherwise </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1ILElement.html#a87f7a9ab6c062085297399a40a3dec4b">lbcrypto::ILElement&lt; DerivedType, BigVector &gt;</a>.</p>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a38d217014f2f8e5075ab2b7d211ffae9">lbcrypto::DCRTPolyImpl&lt; VecType &gt;</a>.</p>

</div>
</div>
<a id="a02b0f63b9b363fe509e449ca9fe9e24f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02b0f63b9b363fe509e449ca9fe9e24f">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual BigIntType&amp; <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">usint&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get interpolated value of element at index i. Note this operation is computationally intense. No bound checking. </p>
<dl class="section return"><dt>Returns</dt><dd>interpolated value at index i. </dd></dl>

<p>Reimplemented from <a class="el" href="classlbcrypto_1_1ILElement.html">lbcrypto::ILElement&lt; DerivedType, BigVector &gt;</a>.</p>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a240aacc87126a12e6b6dd6e6503b0fa1">lbcrypto::DCRTPolyImpl&lt; VecType &gt;</a>, and <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a240aacc87126a12e6b6dd6e6503b0fa1">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="aca7c97cd5997160bf1542c7310b66a01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca7c97cd5997160bf1542c7310b66a01">&#9670;&nbsp;</a></span>Plus() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual DerivedType <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::Plus </td>
          <td>(</td>
          <td class="paramtype">const BigIntType &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scalar addition - add an element to the first index of each tower. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;element</td><td>is the element to add entry-wise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the addition operation. </dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#af531265d23d28fc85776bff0789e5205">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="a0c1193a99a15b71b7eb3b544b53b827e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c1193a99a15b71b7eb3b544b53b827e">&#9670;&nbsp;</a></span>Plus() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual DerivedType <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::Plus </td>
          <td>(</td>
          <td class="paramtype">const DerivedType &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs an addition operation and returns the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;element</td><td>is the element to add with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the addition. </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1ILElement.html#a38a6503240f38927f387a628c764b47e">lbcrypto::ILElement&lt; DerivedType, BigVector &gt;</a>.</p>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a9a3cea10ad195e8b3408da102f0ec9b7">lbcrypto::DCRTPolyImpl&lt; VecType &gt;</a>.</p>

</div>
</div>
<a id="ad8653434b7b187397033f19812921785"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8653434b7b187397033f19812921785">&#9670;&nbsp;</a></span>Plus() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual DerivedType <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::Plus </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; BigIntType &gt; &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scalar addition for elements in CRT format. CRT elements are represented as vector of integer elements which correspond to the represented number modulo the primes in the tower chain (in same order). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;element</td><td>is the element to add entry-wise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the addition operation. </dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a3c0a6d0fe477043cceba2adaa95afa9a">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="a15120f3c80902a9a3e8fa080d23bd484"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15120f3c80902a9a3e8fa080d23bd484">&#9670;&nbsp;</a></span>PowersOfBase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;DerivedType&gt; <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::PowersOfBase </td>
          <td>(</td>
          <td class="paramtype">usint&#160;</td>
          <td class="paramname"><em>baseBits</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a vector of <a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyImpl</a>'s as <img class="formulaInl" alt="$ \left\{x, {base}*x, {base}^2*x, ..., {base}^{\lfloor {\log q/{base}} \rfloor} \right\}*x $" src="form_3.png"/>, where <img class="formulaInl" alt="$ x $" src="form_4.png"/> is the current <a class="el" href="classlbcrypto_1_1PolyImpl.html">PolyImpl</a> object; used as a subroutine in the relinearization procedure to get powers of a certain "base" for the secret key element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseBits</td><td>is the number of bits in the base, i.e., <img class="formulaInl" alt="$ base = 2^{baseBits} $" src="form_2.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the pointer where the base decomposition vector is stored</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>not efficient and not fast, uses multiprecision arithmetic and will be removed in future. Use </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#afa5771dde254b6445a252714933504bb">DCRTPolyInterface::CRTDecompose</a> instead. </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1ILElement.html#aae3735eaf74bc0955519537441c098ba">lbcrypto::ILElement&lt; DerivedType, BigVector &gt;</a>.</p>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#af44c8da870103210cc33abb50446f44a">lbcrypto::DCRTPolyImpl&lt; VecType &gt;</a>, and <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#af44c8da870103210cc33abb50446f44a">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="ab60fd67b9cdf8d1dc877432a9c198e98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab60fd67b9cdf8d1dc877432a9c198e98">&#9670;&nbsp;</a></span>ScaleAndRound() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual TowerType <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::ScaleAndRound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tQHatInvModqDivqModt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tQHatInvModqDivqModtPrecon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tQHatInvModqBDivqModt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tQHatInvModqBDivqModtPrecon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>tQHatInvModqDivqFrac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>tQHatInvModqBDivqFrac</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs scale and round: {X}_{Q} -&gt; {\round(t/Q*X)}_t {Q} = {q_1,...,q_l} {P} = {p_1,...,p_k}. </p>
<p>Brief algorithm: [\sum_i x_i*[t*QHatInv_i/q_i]_t + Round(\sum_i x_i*{t*QHatInv_i/q_i})]_t</p>
<p>Source: Halevi S., Polyakov Y., and Shoup V. An Improved RNS Variant of the BFV Homomorphic Encryption Scheme. Cryptology ePrint Archive, Report 2018/117. (<a href="https://eprint.iacr.org/2018/117">https://eprint.iacr.org/2018/117</a>)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;t</td><td>often corresponds to the plaintext modulus </td></tr>
    <tr><td class="paramname">&amp;tQHatInvModqDivqModt</td><td>precomputed values for [Floor{t*QHatInv_i/q_i}]_t </td></tr>
    <tr><td class="paramname">&amp;tQHatInvModqDivqModtPrecon</td><td>NTL-specific precomputations </td></tr>
    <tr><td class="paramname">&amp;tQHatInvModqBDivqModt</td><td>precomputed values for [Floor{t*QHatInv_i*B/q_i}]_t used when CRT moduli are 45..60 bits long </td></tr>
    <tr><td class="paramname">&amp;tQHatInvBDivqModtPrecon</td><td>NTL-specific precomputations used when CRT moduli are 45..60 bits long </td></tr>
    <tr><td class="paramname">&amp;tQHatInvModqDivqFrac</td><td>precomputed values for Frac{t*QHatInv_i/q_i} </td></tr>
    <tr><td class="paramname">&amp;tQHatInvBDivqFrac</td><td>precomputed values for Frac{t*QHatInv_i*B/q_i} used when CRT moduli are 45..60 bits long </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of computation as a polynomial with native 64-bit coefficients </dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#ac519a50276b7a54a86ba4b1dd0bb8e30">lbcrypto::DCRTPolyImpl&lt; VecType &gt;</a>, and <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#ac519a50276b7a54a86ba4b1dd0bb8e30">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="afbe955b6be2cf993ee95a7ced916a2eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbe955b6be2cf993ee95a7ced916a2eb">&#9670;&nbsp;</a></span>ScaleAndRound() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual DerivedType <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::ScaleAndRound </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt;&#160;</td>
          <td class="paramname"><em>paramsP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>tPSHatInvModsDivsModp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>tPSHatInvModsDivsFrac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; DoubleNativeInt &gt; &amp;&#160;</td>
          <td class="paramname"><em>modpBarretMu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes scale and round: {X}_{Q,P} -&gt; {t/Q * X}_{P} {Q} = {q_1,...,q_l} {P} = {p_1,...,p_k}. </p>
<p>Brief algorithm: Let S = {Q,P} 1) [\sum_k x_k * alpha_k + Round(\sum_k beta_k * x_k)]_{p_j} 2) alpha_k = [Floor[t*P*[[SHatInv_k]_{s_k}/s_k]]_{p_j} 3) beta_k = {t*P*[[SHatInv_k]_{s_k}/s_k}</p>
<p>Source: Halevi S., Polyakov Y., and Shoup V. An Improved RNS Variant of the BFV Homomorphic Encryption Scheme. Cryptology ePrint Archive, Report 2018/117. (<a href="https://eprint.iacr.org/2018/117">https://eprint.iacr.org/2018/117</a>)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;paramsP</td><td>parameters for the CRT basis {p_1,...,p_k} </td></tr>
    <tr><td class="paramname">&amp;tPSHatInvModsDivsModp</td><td>precomputed values for [\floor[t*P*[[SHatInv_k]_{s_k}/s_k]]_{p_j} </td></tr>
    <tr><td class="paramname">&amp;tPSHatInvModsDivsFrac</td><td>precomputed values for {t*P*[[SHatInv_k]_{s_k}/s_k} </td></tr>
    <tr><td class="paramname">&amp;modpBarretMu</td><td>128-bit Barrett reduction precomputed values for p_j </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result {t/Q * X}_{P} </dd></dl>

</div>
</div>
<a id="a474f08ad683cb2d196024fc0a0a34b1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a474f08ad683cb2d196024fc0a0a34b1f">&#9670;&nbsp;</a></span>ScaleAndRound() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual TowerType <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::ScaleAndRound </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>moduliQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &amp;&#160;</td>
          <td class="paramname"><em>tgamma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tgammaQHatModq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tgammaQHatModqPrecon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>negInvqModtgamma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>negInvqModtgammaPrecon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes scale and round for fast rounding: {X}_{Q} -&gt; {\round(t/Q * X)}_t {Q} = {q_1,...,q_l}. </p>
<p>Brief algorithm:</p>
<p>Source: Jean-Claude Bajard and Julien Eynard and Anwar Hasan and Vincent Zucca. A Full RNS Variant of FV like Somewhat Homomorphic Encryption Schemes. Cryptology ePrint Archive: Report 2016/510. (<a href="https://eprint.iacr.org/2016/510">https://eprint.iacr.org/2016/510</a>)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;moduliQ</td><td>moduli {q_1,...,q_l} </td></tr>
    <tr><td class="paramname">&amp;t</td><td>often corresponds to the plaintext modulus </td></tr>
    <tr><td class="paramname">&amp;tgamma</td><td>t * gamma : t * 2^26 reduction </td></tr>
    <tr><td class="paramname">&amp;tgammaQHatModq</td><td>[t*gamma*(Q/q_i)]_{q_i} </td></tr>
    <tr><td class="paramname">&amp;tgammaQHatModqPrecon</td><td>NTL-specific precomputations </td></tr>
    <tr><td class="paramname">&amp;negInvqModtgamma</td><td>[-q^{-1}]_{t*gamma} </td></tr>
    <tr><td class="paramname">&amp;negInvqModtgammaPrecon</td><td>NTL-specific precomputations </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#afe11386ec43bee605053b5440867a51d">lbcrypto::DCRTPolyImpl&lt; VecType &gt;</a>, and <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#afe11386ec43bee605053b5440867a51d">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="af0e661fe12826ed9369943c5d8aec138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0e661fe12826ed9369943c5d8aec138">&#9670;&nbsp;</a></span>SetElementAtIndex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::SetElementAtIndex </td>
          <td>(</td>
          <td class="paramtype">usint&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TowerType &amp;&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets element at index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>where the element should be set </td></tr>
    <tr><td class="paramname">element</td><td>The element to store </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a60547fcb7ba2bda5861b637483c4b8a7">lbcrypto::DCRTPolyImpl&lt; VecType &gt;</a>, and <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a60547fcb7ba2bda5861b637483c4b8a7">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="a5b6d970d2568f0f712d39d20021eee2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b6d970d2568f0f712d39d20021eee2d">&#9670;&nbsp;</a></span>SetElementAtIndex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::SetElementAtIndex </td>
          <td>(</td>
          <td class="paramtype">usint&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TowerType &amp;&amp;&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets element at index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>where the element should be set </td></tr>
    <tr><td class="paramname">element</td><td>The element to store </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a9fd0741c2089400d7fa3a0c388cc78a2">lbcrypto::DCRTPolyImpl&lt; VecType &gt;</a>, and <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a9fd0741c2089400d7fa3a0c388cc78a2">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="a1288c458ea53efc64df24b1162b35ddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1288c458ea53efc64df24b1162b35ddc">&#9670;&nbsp;</a></span>SetValues()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::SetValues </td>
          <td>(</td>
          <td class="paramtype">const BigVecType &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Format&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set method that should not be used, will throw an error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;values</td><td></td></tr>
    <tr><td class="paramname">format</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Doesn't make sense for DCRT </dd></dl>

</div>
</div>
<a id="a0e3f3fcb29277339a655424ce674a60c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e3f3fcb29277339a655424ce674a60c">&#9670;&nbsp;</a></span>SwitchCRTBasis()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual DerivedType <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::SwitchCRTBasis </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; <a class="el" href="classlbcrypto_1_1ILDCRTParams.html">Params</a> &gt;&#160;</td>
          <td class="paramname"><em>paramsP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>QHatInvModq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>QHatInvModqPrecon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>QHatModp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>alphaQModp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; DoubleNativeInt &gt; &amp;&#160;</td>
          <td class="paramname"><em>modpBarrettMu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>qInv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs CRT basis switching: {X}_{Q} -&gt; {X}_{P} {Q} = {q_1,...,q_l} {P} = {p_1,...,p_k}. </p>
<p>Brief algorithm: 1) X=\sum_i[x_i*(Q/q_i)^{-1}]_{q_i}*(Q/q_i)-alpha*Q 2) compute round[[x_i*(Q/q_i)^{-1}]_{q_i} / q_i] to find alpha 3) [X]_{p_j}=[\sum_i[x_i*(Q/q_i)^{-1}]_{q_i}*(Q/q_i)]_{p_j}-[alpha*Q]_{p_j}</p>
<p>Source: Halevi S., Polyakov Y., and Shoup V. An Improved RNS Variant of the BFV Homomorphic Encryption Scheme. Cryptology ePrint Archive, Report 2018/117. (<a href="https://eprint.iacr.org/2018/117">https://eprint.iacr.org/2018/117</a>)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;paramsP</td><td>parameters for the CRT basis {p_1,...,p_k} </td></tr>
    <tr><td class="paramname">&amp;QHatInvModq</td><td>precomputed values for [(Q/q_i)^{-1}]_{q_i} </td></tr>
    <tr><td class="paramname">&amp;QHatInvModqPrecon</td><td>NTL-specific precomputations </td></tr>
    <tr><td class="paramname">&amp;QHatModp</td><td>precomputed values for [Q/q_i]_{p_j} </td></tr>
    <tr><td class="paramname">&amp;alphaQModp</td><td>precomputed values for [alpha*Q]_{p_j} </td></tr>
    <tr><td class="paramname">&amp;modpBarrettMu</td><td>128-bit Barrett reduction precomputed values for p_j @params &amp;qInv precomputed values for 1/q_i </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the representation of {X}_{P} </dd></dl>

</div>
</div>
<a id="a984331e9b51c18bde937d77742361ef1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a984331e9b51c18bde937d77742361ef1">&#9670;&nbsp;</a></span>SwitchFormat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::SwitchFormat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert from Coefficient to CRT or vice versa; calls FFT and inverse FFT. </p>
<dl class="section warning"><dt>Warning</dt><dd>use </dd></dl>
<dl class="section see"><dt>See also</dt><dd>SetFormat(format) instead </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1ILElement.html#a7a95c1f067428962beeef9ac20f4fefc">lbcrypto::ILElement&lt; DerivedType, BigVector &gt;</a>.</p>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a28d3c67522ed393eb3855cd4133c552d">lbcrypto::DCRTPolyImpl&lt; VecType &gt;</a>, and <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a28d3c67522ed393eb3855cd4133c552d">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="a0c38037e64d065fd8240883700f25764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c38037e64d065fd8240883700f25764">&#9670;&nbsp;</a></span>SwitchModulus()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::SwitchModulus </td>
          <td>(</td>
          <td class="paramtype">const BigIntType &amp;&#160;</td>
          <td class="paramname"><em>modulus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BigIntType &amp;&#160;</td>
          <td class="paramname"><em>rootOfUnity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BigIntType &amp;&#160;</td>
          <td class="paramname"><em>modulusArb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BigIntType &amp;&#160;</td>
          <td class="paramname"><em>rootOfUnityArb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Switch modulus and adjust the values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;modulus</td><td>is the modulus to be set </td></tr>
    <tr><td class="paramname">&amp;rootOfUnity</td><td>is the corresponding root of unity for the modulus </td></tr>
    <tr><td class="paramname">&amp;modulusArb</td><td>is the modulus used for arbitrary cyclotomics CRT </td></tr>
    <tr><td class="paramname">&amp;rootOfUnityArb</td><td>is the corresponding root of unity for the modulus ASSUMPTION: This method assumes that the caller provides the correct rootOfUnity for the modulus </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a5760813c7513606ea0cf28015639297e">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="ae5756e146673e846bc8ebaf4e3139472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5756e146673e846bc8ebaf4e3139472">&#9670;&nbsp;</a></span>SwitchModulusAtIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::SwitchModulusAtIndex </td>
          <td>(</td>
          <td class="paramtype">usint&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BigIntType &amp;&#160;</td>
          <td class="paramname"><em>modulus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BigIntType &amp;&#160;</td>
          <td class="paramname"><em>rootOfUnity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Switch modulus at tower i and adjust the values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>is the index for the tower </td></tr>
    <tr><td class="paramname">&amp;modulus</td><td>is the modulus to be set </td></tr>
    <tr><td class="paramname">&amp;rootOfUnity</td><td>is the corresponding root of unity for the modulus ASSUMPTION: This method assumes that the caller provides the correct rootOfUnity for the modulus </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a38e9a3306642a95e2a6debae131f234b">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="acee8bc36b405189c3be42b0ef2417625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acee8bc36b405189c3be42b0ef2417625">&#9670;&nbsp;</a></span>Times() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual DerivedType <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::Times </td>
          <td>(</td>
          <td class="paramtype">bigintnat::NativeInteger::SignedNativeInt&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scalar multiplication - multiply by a signed integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;element</td><td>is the element to multiply entry-wise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the return value of the times operation. </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1ILElement.html#a34e8992842f28638c8d4eff26d0fc584">lbcrypto::ILElement&lt; DerivedType, BigVector &gt;</a>.</p>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a187ab86229c1ecc9f372fd76886426eb">lbcrypto::DCRTPolyImpl&lt; VecType &gt;</a>, and <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a187ab86229c1ecc9f372fd76886426eb">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="abe20fce440768599da3a2edeb27ced9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe20fce440768599da3a2edeb27ced9f">&#9670;&nbsp;</a></span>Times() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual DerivedType <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::Times </td>
          <td>(</td>
          <td class="paramtype">const BigIntType &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scalar multiplication - multiply all entries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;element</td><td>is the element to multiply entry-wise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the return value of the times operation. </dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a90ef011a1f427c25add508227dcdda34">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="a12e87746e6b870e0e23c7196cd0d6e1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12e87746e6b870e0e23c7196cd0d6e1d">&#9670;&nbsp;</a></span>Times() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual DerivedType <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::Times </td>
          <td>(</td>
          <td class="paramtype">const DerivedType &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a multiplication operation and returns the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;element</td><td>is the element to multiply with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the multiplication. </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1ILElement.html#a87aae40f4589b2e10285495cfda2b492">lbcrypto::ILElement&lt; DerivedType, BigVector &gt;</a>.</p>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a90ee91a0f67930426467c8287b86f476">lbcrypto::DCRTPolyImpl&lt; VecType &gt;</a>.</p>

</div>
</div>
<a id="ad6fd62f7cc5222c6ab8719f0d5a2c8c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6fd62f7cc5222c6ab8719f0d5a2c8c1">&#9670;&nbsp;</a></span>Times() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual DerivedType <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::Times </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; BigIntType &gt; &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scalar modular multiplication by an integer represented in CRT Basis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;element</td><td>is the element to multiply entry-wise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the return value of the times operation.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Should remove this, data is truncated to native-word size. </dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#aab46382f79a885c1c1df2d5036795f77">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="a8ede9b43e16d3baae6c37e796db1d86a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ede9b43e16d3baae6c37e796db1d86a">&#9670;&nbsp;</a></span>Times() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual DerivedType <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::Times </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbigintnat_1_1NativeIntegerT.html">NativeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scalar multiplication by an integer represented in CRT Basis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;element</td><td>is the element to multiply entry-wise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the return value of the times operation. </dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a9d4f4516563a969449fa4ea833961264">lbcrypto::DCRTPolyImpl&lt; VecType &gt;</a>, and <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a9d4f4516563a969449fa4ea833961264">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="a0418bd87a1822e8f47b56ac4a8dbb560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0418bd87a1822e8f47b56ac4a8dbb560">&#9670;&nbsp;</a></span>Times() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual DerivedType <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::Times </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scalar multiplication - multiply by a signed integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;element</td><td>is the element to multiply entry-wise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the return value of the times operation.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>this is need for 128-bit so that the 64-bit inputs can be used. </dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#aee610929568e5beb855316a0642365b3">lbcrypto::DCRTPolyImpl&lt; VecType &gt;</a>, and <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#aee610929568e5beb855316a0642365b3">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="a0d2b7e3f78ba01d71c1ea9425ea908f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d2b7e3f78ba01d71c1ea9425ea908f9">&#9670;&nbsp;</a></span>ToNativePoly()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual TowerType <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::ToNativePoly </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the values are small enough this is used for efficiency. </p>
<dl class="section return"><dt>Returns</dt><dd>NativePoly</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This will be replaced with a non-member utility function. </dd></dl>

</div>
</div>
<a id="a77fa4c8b73acda9b59dc034519d592db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77fa4c8b73acda9b59dc034519d592db">&#9670;&nbsp;</a></span>Transpose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual DerivedType <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html">lbcrypto::DCRTPolyInterface</a>&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;::Transpose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transpose the ring element using the automorphism operation. </p>
<dl class="section return"><dt>Returns</dt><dd>is the result of the transposition. </dd></dl>

<p>Reimplemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a35d2fdfaa1eafe1f0f42e380e5356afd">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a3f94b2fcef68088ec97dd97baeaf5678"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f94b2fcef68088ec97dd97baeaf5678">&#9670;&nbsp;</a></span>operator* <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DerivedType operator* </td>
          <td>(</td>
          <td class="paramtype">const BigIntType &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedType &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>BigIntType-element multiplication operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>integer to multiply. </td></tr>
    <tr><td class="paramname">b</td><td>element to multiply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the multiplication operation. </dd></dl>

</div>
</div>
<a id="a679021dabcc74542e18af66ca0f11219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a679021dabcc74542e18af66ca0f11219">&#9670;&nbsp;</a></span>operator* <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DerivedType operator* </td>
          <td>(</td>
          <td class="paramtype">const DerivedType &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BigIntType &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-integer multiplication operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>element to multiply. </td></tr>
    <tr><td class="paramname">b</td><td>integer to multiply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the multiplication operation. </dd></dl>

</div>
</div>
<a id="a0b869cfdc3e36bb62e779856c46f1570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b869cfdc3e36bb62e779856c46f1570">&#9670;&nbsp;</a></span>operator* <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DerivedType operator* </td>
          <td>(</td>
          <td class="paramtype">const DerivedType &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedType &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-element multiplication operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>element to multiply. </td></tr>
    <tr><td class="paramname">b</td><td>element to multiply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the multiplication operation. </dd></dl>

</div>
</div>
<a id="aed5be6e095880c30bee13d4a7a8b7024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed5be6e095880c30bee13d4a7a8b7024">&#9670;&nbsp;</a></span>operator* <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DerivedType operator* </td>
          <td>(</td>
          <td class="paramtype">const DerivedType &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; BigIntType &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-CRT number multiplication operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>element to multiply. </td></tr>
    <tr><td class="paramname">b</td><td>integer to multiply, in CRT format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the multiplication operation. </dd></dl>

</div>
</div>
<a id="a720afafe6ecdc7e2be081909dde7b5fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a720afafe6ecdc7e2be081909dde7b5fe">&#9670;&nbsp;</a></span>operator* <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DerivedType operator* </td>
          <td>(</td>
          <td class="paramtype">const DerivedType &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-signed-integer multiplication operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>element to multiply. </td></tr>
    <tr><td class="paramname">b</td><td>integer to multiply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the multiplication operation. </dd></dl>

</div>
</div>
<a id="ad7e0ded9452926fe21e067c118eb6d45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7e0ded9452926fe21e067c118eb6d45">&#9670;&nbsp;</a></span>operator* <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DerivedType operator* </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedType &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>signed-BigIntType-element multiplication operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>integer to multiply. </td></tr>
    <tr><td class="paramname">b</td><td>element to multiply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the multiplication operation. </dd></dl>

</div>
</div>
<a id="a43590c2fa51c6859654160e4657fb521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43590c2fa51c6859654160e4657fb521">&#9670;&nbsp;</a></span>operator+ <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DerivedType operator+ </td>
          <td>(</td>
          <td class="paramtype">const BigIntType &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedType &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>BigIntType-element addition operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>integer to add. </td></tr>
    <tr><td class="paramname">b</td><td>element to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the addition operation. </dd></dl>

</div>
</div>
<a id="a6642ccfeddef9f1decea469bab6b27b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6642ccfeddef9f1decea469bab6b27b1">&#9670;&nbsp;</a></span>operator+ <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DerivedType operator+ </td>
          <td>(</td>
          <td class="paramtype">const DerivedType &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BigIntType &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-integer addition operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>first element to add. </td></tr>
    <tr><td class="paramname">b</td><td>integer to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the addition operation. </dd></dl>

</div>
</div>
<a id="ad18caaec27bec23156635e966b5a6b32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad18caaec27bec23156635e966b5a6b32">&#9670;&nbsp;</a></span>operator+ <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DerivedType operator+ </td>
          <td>(</td>
          <td class="paramtype">const DerivedType &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedType &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-element addition operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>first element to add. </td></tr>
    <tr><td class="paramname">b</td><td>second element to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the addition operation. </dd></dl>

</div>
</div>
<a id="aa3b6df4e75de80bbf9276e30ad06d20a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3b6df4e75de80bbf9276e30ad06d20a">&#9670;&nbsp;</a></span>operator+ <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DerivedType operator+ </td>
          <td>(</td>
          <td class="paramtype">const DerivedType &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; BigIntType &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-integer addition operator with CRT integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>first element to add. </td></tr>
    <tr><td class="paramname">b</td><td>integer to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the addition operation. </dd></dl>

</div>
</div>
<a id="a7a55c7c3d2f79ca78bdead15ad9033b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a55c7c3d2f79ca78bdead15ad9033b9">&#9670;&nbsp;</a></span>operator+ <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DerivedType operator+ </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; BigIntType &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedType &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>BigIntType-element addition operator with CRT integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>integer to add. </td></tr>
    <tr><td class="paramname">b</td><td>element to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the addition operation. </dd></dl>

</div>
</div>
<a id="a0c703da1ce30308cc6f4266093bb0325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c703da1ce30308cc6f4266093bb0325">&#9670;&nbsp;</a></span>operator- <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DerivedType operator- </td>
          <td>(</td>
          <td class="paramtype">const DerivedType &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BigIntType &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-integer subtraction operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>element to subtract from. </td></tr>
    <tr><td class="paramname">b</td><td>integer to subtract. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the subtraction operation. </dd></dl>

</div>
</div>
<a id="a6a0b432c4d5fcfe7927e2273ed6ad062"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a0b432c4d5fcfe7927e2273ed6ad062">&#9670;&nbsp;</a></span>operator- <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DerivedType operator- </td>
          <td>(</td>
          <td class="paramtype">const DerivedType &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedType &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-element subtraction operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>element to subtract from. </td></tr>
    <tr><td class="paramname">b</td><td>element to subtract. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the subtraction operation. </dd></dl>

</div>
</div>
<a id="a7536108ae00642c44c249b83cc1534ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7536108ae00642c44c249b83cc1534ed">&#9670;&nbsp;</a></span>operator- <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DerivedType operator- </td>
          <td>(</td>
          <td class="paramtype">const DerivedType &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; BigIntType &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-integer subtraction operator with CRT integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>first element to subtract. </td></tr>
    <tr><td class="paramname">b</td><td>integer to subtract. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the subtraction operation. </dd></dl>

</div>
</div>
<a id="a7083d5e4343ee4d6bd3d0d01842fafa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7083d5e4343ee4d6bd3d0d01842fafa8">&#9670;&nbsp;</a></span>operator- <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DerivedType operator- </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; BigIntType &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedType &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>BigIntType-element subtraction operator with CRT integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>integer to subtract. </td></tr>
    <tr><td class="paramname">b</td><td>element to subtract. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the subtraction operation. </dd></dl>

</div>
</div>
<a id="a65f5228b2d411c4da6daca47f031c99b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65f5228b2d411c4da6daca47f031c99b">&#9670;&nbsp;</a></span>operator&lt;&lt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename BigVecType  = BigVector, typename LilVecType  = NativeVector, template&lt; typename LVT &gt; typename RNSContainerType = PolyImpl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedType &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ostream operator </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>the input preceding output stream </td></tr>
    <tr><td class="paramname">vec</td><td>the element to add to the output stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a resulting concatenated output stream </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/core/include/lattice/<a class="el" href="dcrtpolyinterface_8h_source.html">dcrtpolyinterface.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jan 19 2022 00:47:58 for PALISADE Lattice Crypto Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
