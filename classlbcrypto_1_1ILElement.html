<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PALISADE Lattice Crypto Library: lbcrypto::ILElement&lt; Element, VecType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PALISADE Lattice Crypto Library
   &#160;<span id="projectnumber">1.11.5</span>
   </div>
   <div id="projectbrief">A lattice crypto library for software engineers by software engineers.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelbcrypto.html">lbcrypto</a></li><li class="navelem"><a class="el" href="classlbcrypto_1_1ILElement.html">ILElement</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classlbcrypto_1_1ILElement-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">lbcrypto::ILElement&lt; Element, VecType &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Interface for ideal lattices.  
 <a href="classlbcrypto_1_1ILElement.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ilelement_8h_source.html">ilelement.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for lbcrypto::ILElement&lt; Element, VecType &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classlbcrypto_1_1ILElement__inherit__graph.png" border="0" usemap="#lbcrypto_1_1ILElement_3_01Element_00_01VecType_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="lbcrypto_1_1ILElement_3_01Element_00_01VecType_01_4_inherit__map" id="lbcrypto_1_1ILElement_3_01Element_00_01VecType_01_4_inherit__map">
<area shape="rect" title="Interface for ideal lattices." alt="" coords="5,80,172,121"/>
<area shape="rect" href="classlbcrypto_1_1Serializable.html" title="Base class for PALISADE serialization." alt="" coords="9,5,168,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for lbcrypto::ILElement&lt; Element, VecType &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classlbcrypto_1_1ILElement__coll__graph.png" border="0" usemap="#lbcrypto_1_1ILElement_3_01Element_00_01VecType_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="lbcrypto_1_1ILElement_3_01Element_00_01VecType_01_4_coll__map" id="lbcrypto_1_1ILElement_3_01Element_00_01VecType_01_4_coll__map">
<area shape="rect" title="Interface for ideal lattices." alt="" coords="5,80,172,121"/>
<area shape="rect" href="classlbcrypto_1_1Serializable.html" title="Base class for PALISADE serialization." alt="" coords="9,5,168,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a70b85d0a6aea66ace2c983618ac8a489"><td class="memItemLeft" align="right" valign="top">virtual Element&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#a70b85d0a6aea66ace2c983618ac8a489">Clone</a> () const =0</td></tr>
<tr class="memdesc:a70b85d0a6aea66ace2c983618ac8a489"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone the object by making a copy of it and returning the copy.  <a href="classlbcrypto_1_1ILElement.html#a70b85d0a6aea66ace2c983618ac8a489">More...</a><br /></td></tr>
<tr class="separator:a70b85d0a6aea66ace2c983618ac8a489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a6b897331d1265eb815e6d50d295037"><td class="memItemLeft" align="right" valign="top">virtual Element&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#a0a6b897331d1265eb815e6d50d295037">CloneEmpty</a> () const =0</td></tr>
<tr class="memdesc:a0a6b897331d1265eb815e6d50d295037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone the object, but have it contain nothing.  <a href="classlbcrypto_1_1ILElement.html#a0a6b897331d1265eb815e6d50d295037">More...</a><br /></td></tr>
<tr class="separator:a0a6b897331d1265eb815e6d50d295037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a7aeb078733436bf1071b5127f79a7"><td class="memItemLeft" align="right" valign="top">virtual Element&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#a77a7aeb078733436bf1071b5127f79a7">CloneParametersOnly</a> () const =0</td></tr>
<tr class="memdesc:a77a7aeb078733436bf1071b5127f79a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clones the element's parameters, leaves vector initialized to 0.  <a href="classlbcrypto_1_1ILElement.html#a77a7aeb078733436bf1071b5127f79a7">More...</a><br /></td></tr>
<tr class="separator:a77a7aeb078733436bf1071b5127f79a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e2e2a2bacd65456e0ce82aaf33e23e"><td class="memItemLeft" align="right" valign="top">virtual Element&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#a45e2e2a2bacd65456e0ce82aaf33e23e">CloneWithNoise</a> (const <a class="el" href="classlbcrypto_1_1DiscreteGaussianGeneratorImpl.html">DiscreteGaussianGeneratorImpl</a>&lt; VecType &gt; &amp;dgg, Format format=Format::EVALUATION) const =0</td></tr>
<tr class="memdesc:a45e2e2a2bacd65456e0ce82aaf33e23e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clones the element with parameters and with noise for the vector.  <a href="classlbcrypto_1_1ILElement.html#a45e2e2a2bacd65456e0ce82aaf33e23e">More...</a><br /></td></tr>
<tr class="separator:a45e2e2a2bacd65456e0ce82aaf33e23e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1538c0112d2d4dfba9eec22118b22cc"><td class="memItemLeft" align="right" valign="top"><a id="aa1538c0112d2d4dfba9eec22118b22cc"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#aa1538c0112d2d4dfba9eec22118b22cc">~ILElement</a> ()</td></tr>
<tr class="memdesc:aa1538c0112d2d4dfba9eec22118b22cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard destructor. <br /></td></tr>
<tr class="separator:aa1538c0112d2d4dfba9eec22118b22cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4c6ccfa8477a16e4f11df540100e847"><td class="memItemLeft" align="right" valign="top">virtual const Element &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#aa4c6ccfa8477a16e4f11df540100e847">operator=</a> (const Element &amp;rhs)=0</td></tr>
<tr class="memdesc:aa4c6ccfa8477a16e4f11df540100e847"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator that copies elements.  <a href="classlbcrypto_1_1ILElement.html#aa4c6ccfa8477a16e4f11df540100e847">More...</a><br /></td></tr>
<tr class="separator:aa4c6ccfa8477a16e4f11df540100e847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cc3339607ccbccb15fcfe8deb84b3be"><td class="memItemLeft" align="right" valign="top">virtual const Element &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#a1cc3339607ccbccb15fcfe8deb84b3be">operator=</a> (Element &amp;&amp;rhs)=0</td></tr>
<tr class="memdesc:a1cc3339607ccbccb15fcfe8deb84b3be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator that copies elements.  <a href="classlbcrypto_1_1ILElement.html#a1cc3339607ccbccb15fcfe8deb84b3be">More...</a><br /></td></tr>
<tr class="separator:a1cc3339607ccbccb15fcfe8deb84b3be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d6c463d45b96bd973af2c5564b62ced"><td class="memItemLeft" align="right" valign="top">virtual const Element &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#a7d6c463d45b96bd973af2c5564b62ced">operator=</a> (std::initializer_list&lt; uint64_t &gt; rhs)=0</td></tr>
<tr class="memdesc:a7d6c463d45b96bd973af2c5564b62ced"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator that copies elements.  <a href="classlbcrypto_1_1ILElement.html#a7d6c463d45b96bd973af2c5564b62ced">More...</a><br /></td></tr>
<tr class="separator:a7d6c463d45b96bd973af2c5564b62ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7d2c897610e5923b5418f7227393272"><td class="memItemLeft" align="right" valign="top">virtual Format&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#ac7d2c897610e5923b5418f7227393272">GetFormat</a> () const =0</td></tr>
<tr class="memdesc:ac7d2c897610e5923b5418f7227393272"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get format of the element.  <a href="classlbcrypto_1_1ILElement.html#ac7d2c897610e5923b5418f7227393272">More...</a><br /></td></tr>
<tr class="separator:ac7d2c897610e5923b5418f7227393272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9eeef930f29aa94f77cca1a86fabf6e"><td class="memItemLeft" align="right" valign="top">virtual usint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#af9eeef930f29aa94f77cca1a86fabf6e">GetLength</a> () const =0</td></tr>
<tr class="memdesc:af9eeef930f29aa94f77cca1a86fabf6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the length of the element.  <a href="classlbcrypto_1_1ILElement.html#af9eeef930f29aa94f77cca1a86fabf6e">More...</a><br /></td></tr>
<tr class="separator:af9eeef930f29aa94f77cca1a86fabf6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacc0cf9d638c8e613fb0c646456be0a0"><td class="memItemLeft" align="right" valign="top">virtual const IntType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#aacc0cf9d638c8e613fb0c646456be0a0">GetModulus</a> () const =0</td></tr>
<tr class="memdesc:aacc0cf9d638c8e613fb0c646456be0a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get modulus of the element.  <a href="classlbcrypto_1_1ILElement.html#aacc0cf9d638c8e613fb0c646456be0a0">More...</a><br /></td></tr>
<tr class="separator:aacc0cf9d638c8e613fb0c646456be0a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a474bbec1e55b18ecf1fc52b806d7f186"><td class="memItemLeft" align="right" valign="top">virtual const VecType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#a474bbec1e55b18ecf1fc52b806d7f186">GetValues</a> () const =0</td></tr>
<tr class="memdesc:a474bbec1e55b18ecf1fc52b806d7f186"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the values for the element.  <a href="classlbcrypto_1_1ILElement.html#a474bbec1e55b18ecf1fc52b806d7f186">More...</a><br /></td></tr>
<tr class="separator:a474bbec1e55b18ecf1fc52b806d7f186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7de6762a19c79d5a0be9896a2b69498c"><td class="memItemLeft" align="right" valign="top">virtual usint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#a7de6762a19c79d5a0be9896a2b69498c">GetCyclotomicOrder</a> () const =0</td></tr>
<tr class="memdesc:a7de6762a19c79d5a0be9896a2b69498c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the cyclotomic order.  <a href="classlbcrypto_1_1ILElement.html#a7de6762a19c79d5a0be9896a2b69498c">More...</a><br /></td></tr>
<tr class="separator:a7de6762a19c79d5a0be9896a2b69498c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359fe4a33cd095b663313d970518c1b7"><td class="memItemLeft" align="right" valign="top">virtual IntType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#a359fe4a33cd095b663313d970518c1b7">at</a> (usint i)</td></tr>
<tr class="memdesc:a359fe4a33cd095b663313d970518c1b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the Value in the Element that is At Index and returns it. This is only implemented for some derived classes, so the default implementation throws an exception.  <a href="classlbcrypto_1_1ILElement.html#a359fe4a33cd095b663313d970518c1b7">More...</a><br /></td></tr>
<tr class="separator:a359fe4a33cd095b663313d970518c1b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe845fc38cbe1884a7268cc7425eabc5"><td class="memItemLeft" align="right" valign="top"><a id="afe845fc38cbe1884a7268cc7425eabc5"></a>
virtual const IntType &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>at</b> (usint i) const</td></tr>
<tr class="separator:afe845fc38cbe1884a7268cc7425eabc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ed329dea771efa4e670cc7ff4433b67"><td class="memItemLeft" align="right" valign="top"><a id="a1ed329dea771efa4e670cc7ff4433b67"></a>
virtual IntType &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (usint i)</td></tr>
<tr class="separator:a1ed329dea771efa4e670cc7ff4433b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a109dacf8b6c40e08254c6bd41850293c"><td class="memItemLeft" align="right" valign="top"><a id="a109dacf8b6c40e08254c6bd41850293c"></a>
virtual const IntType &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (usint i) const</td></tr>
<tr class="separator:a109dacf8b6c40e08254c6bd41850293c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a746f4dd63222b09c45ad989b8045bae7"><td class="memItemLeft" align="right" valign="top">virtual Element&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#a746f4dd63222b09c45ad989b8045bae7">operator-</a> () const =0</td></tr>
<tr class="memdesc:a746f4dd63222b09c45ad989b8045bae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary negation on a lattice.  <a href="classlbcrypto_1_1ILElement.html#a746f4dd63222b09c45ad989b8045bae7">More...</a><br /></td></tr>
<tr class="separator:a746f4dd63222b09c45ad989b8045bae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07683b181b31fb853a4988a7f35bc776"><td class="memItemLeft" align="right" valign="top">virtual Element&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#a07683b181b31fb853a4988a7f35bc776">Plus</a> (const IntType &amp;element) const =0</td></tr>
<tr class="memdesc:a07683b181b31fb853a4988a7f35bc776"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar addition - add an element to the first index only. This operation is only allowed in COEFFICIENT format.  <a href="classlbcrypto_1_1ILElement.html#a07683b181b31fb853a4988a7f35bc776">More...</a><br /></td></tr>
<tr class="separator:a07683b181b31fb853a4988a7f35bc776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceb6e03c9b3106a45c13f3488bdaf403"><td class="memItemLeft" align="right" valign="top">virtual Element&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#aceb6e03c9b3106a45c13f3488bdaf403">Minus</a> (const IntType &amp;element) const =0</td></tr>
<tr class="memdesc:aceb6e03c9b3106a45c13f3488bdaf403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar subtraction - subtract an element frp, all entries.  <a href="classlbcrypto_1_1ILElement.html#aceb6e03c9b3106a45c13f3488bdaf403">More...</a><br /></td></tr>
<tr class="separator:aceb6e03c9b3106a45c13f3488bdaf403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace67acbcf4ed67ce68a02e1565159af4"><td class="memItemLeft" align="right" valign="top">virtual Element&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#ace67acbcf4ed67ce68a02e1565159af4">Times</a> (const IntType &amp;element) const =0</td></tr>
<tr class="memdesc:ace67acbcf4ed67ce68a02e1565159af4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar multiplication - multiply all entries.  <a href="classlbcrypto_1_1ILElement.html#ace67acbcf4ed67ce68a02e1565159af4">More...</a><br /></td></tr>
<tr class="separator:ace67acbcf4ed67ce68a02e1565159af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e8992842f28638c8d4eff26d0fc584"><td class="memItemLeft" align="right" valign="top">virtual Element&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#a34e8992842f28638c8d4eff26d0fc584">Times</a> (bigintnat::NativeInteger::SignedNativeInt element) const =0</td></tr>
<tr class="memdesc:a34e8992842f28638c8d4eff26d0fc584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar multiplication - mulltiply by a signed integer.  <a href="classlbcrypto_1_1ILElement.html#a34e8992842f28638c8d4eff26d0fc584">More...</a><br /></td></tr>
<tr class="separator:a34e8992842f28638c8d4eff26d0fc584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38a6503240f38927f387a628c764b47e"><td class="memItemLeft" align="right" valign="top">virtual Element&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#a38a6503240f38927f387a628c764b47e">Plus</a> (const Element &amp;element) const =0</td></tr>
<tr class="memdesc:a38a6503240f38927f387a628c764b47e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an addition operation and returns the result.  <a href="classlbcrypto_1_1ILElement.html#a38a6503240f38927f387a628c764b47e">More...</a><br /></td></tr>
<tr class="separator:a38a6503240f38927f387a628c764b47e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b308cd85c096a6c150a35a4e8e52970"><td class="memItemLeft" align="right" valign="top">virtual Element&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#a9b308cd85c096a6c150a35a4e8e52970">Minus</a> (const Element &amp;element) const =0</td></tr>
<tr class="memdesc:a9b308cd85c096a6c150a35a4e8e52970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a subtraction operation and returns the result.  <a href="classlbcrypto_1_1ILElement.html#a9b308cd85c096a6c150a35a4e8e52970">More...</a><br /></td></tr>
<tr class="separator:a9b308cd85c096a6c150a35a4e8e52970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87aae40f4589b2e10285495cfda2b492"><td class="memItemLeft" align="right" valign="top">virtual Element&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#a87aae40f4589b2e10285495cfda2b492">Times</a> (const Element &amp;element) const =0</td></tr>
<tr class="memdesc:a87aae40f4589b2e10285495cfda2b492"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a multiplication operation and returns the result.  <a href="classlbcrypto_1_1ILElement.html#a87aae40f4589b2e10285495cfda2b492">More...</a><br /></td></tr>
<tr class="separator:a87aae40f4589b2e10285495cfda2b492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5763872f5ef073a213c3d7564bb1359"><td class="memItemLeft" align="right" valign="top">virtual const Element &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#ad5763872f5ef073a213c3d7564bb1359">operator+=</a> (const IntType &amp;element)=0</td></tr>
<tr class="memdesc:ad5763872f5ef073a213c3d7564bb1359"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs += operation with a BigInteger and returns the result.  <a href="classlbcrypto_1_1ILElement.html#ad5763872f5ef073a213c3d7564bb1359">More...</a><br /></td></tr>
<tr class="separator:ad5763872f5ef073a213c3d7564bb1359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b6b8e3c0fe6e82a736e0697a381856"><td class="memItemLeft" align="right" valign="top">virtual const Element &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#ae7b6b8e3c0fe6e82a736e0697a381856">operator-=</a> (const IntType &amp;element)=0</td></tr>
<tr class="memdesc:ae7b6b8e3c0fe6e82a736e0697a381856"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs -= operation with a BigInteger and returns the result.  <a href="classlbcrypto_1_1ILElement.html#ae7b6b8e3c0fe6e82a736e0697a381856">More...</a><br /></td></tr>
<tr class="separator:ae7b6b8e3c0fe6e82a736e0697a381856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb0670789e94757db373df45ff9067cd"><td class="memItemLeft" align="right" valign="top">virtual const Element &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#abb0670789e94757db373df45ff9067cd">operator*=</a> (const IntType &amp;element)=0</td></tr>
<tr class="memdesc:abb0670789e94757db373df45ff9067cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs *= operation with a BigInteger and returns the result.  <a href="classlbcrypto_1_1ILElement.html#abb0670789e94757db373df45ff9067cd">More...</a><br /></td></tr>
<tr class="separator:abb0670789e94757db373df45ff9067cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2fa2e51c8be146bdc2b739b40f4bf1f"><td class="memItemLeft" align="right" valign="top">virtual const Element &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#ad2fa2e51c8be146bdc2b739b40f4bf1f">operator+=</a> (const Element &amp;element)=0</td></tr>
<tr class="memdesc:ad2fa2e51c8be146bdc2b739b40f4bf1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an addition operation and returns the result.  <a href="classlbcrypto_1_1ILElement.html#ad2fa2e51c8be146bdc2b739b40f4bf1f">More...</a><br /></td></tr>
<tr class="separator:ad2fa2e51c8be146bdc2b739b40f4bf1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16234919ba5cedf710fe8d6dbd071e44"><td class="memItemLeft" align="right" valign="top">virtual const Element &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#a16234919ba5cedf710fe8d6dbd071e44">operator-=</a> (const Element &amp;element)=0</td></tr>
<tr class="memdesc:a16234919ba5cedf710fe8d6dbd071e44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an subtraction operation and returns the result.  <a href="classlbcrypto_1_1ILElement.html#a16234919ba5cedf710fe8d6dbd071e44">More...</a><br /></td></tr>
<tr class="separator:a16234919ba5cedf710fe8d6dbd071e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adecf4245b01406e2a2568fad52434494"><td class="memItemLeft" align="right" valign="top">virtual const Element &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#adecf4245b01406e2a2568fad52434494">operator*=</a> (const Element &amp;element)=0</td></tr>
<tr class="memdesc:adecf4245b01406e2a2568fad52434494"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an multiplication operation and returns the result.  <a href="classlbcrypto_1_1ILElement.html#adecf4245b01406e2a2568fad52434494">More...</a><br /></td></tr>
<tr class="separator:adecf4245b01406e2a2568fad52434494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f7a9ab6c062085297399a40a3dec4b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#a87f7a9ab6c062085297399a40a3dec4b">operator==</a> (const Element &amp;element) const =0</td></tr>
<tr class="memdesc:a87f7a9ab6c062085297399a40a3dec4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator. Compares values of element to be compared to.  <a href="classlbcrypto_1_1ILElement.html#a87f7a9ab6c062085297399a40a3dec4b">More...</a><br /></td></tr>
<tr class="separator:a87f7a9ab6c062085297399a40a3dec4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac59b8d3af7b29f7225ee37dc83214e79"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#ac59b8d3af7b29f7225ee37dc83214e79">operator!=</a> (const Element &amp;element) const</td></tr>
<tr class="memdesc:ac59b8d3af7b29f7225ee37dc83214e79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator. Compares values of element to be compared to.  <a href="classlbcrypto_1_1ILElement.html#ac59b8d3af7b29f7225ee37dc83214e79">More...</a><br /></td></tr>
<tr class="separator:ac59b8d3af7b29f7225ee37dc83214e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad310b89663e77206e931074146be8e16"><td class="memItemLeft" align="right" valign="top"><a id="ad310b89663e77206e931074146be8e16"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#ad310b89663e77206e931074146be8e16">AddILElementOne</a> ()=0</td></tr>
<tr class="memdesc:ad310b89663e77206e931074146be8e16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds one to every entry of the Element, in place. <br /></td></tr>
<tr class="separator:ad310b89663e77206e931074146be8e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5dcc9fbc3a60640bb1722f236b2bdb8"><td class="memItemLeft" align="right" valign="top">virtual Element&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#ac5dcc9fbc3a60640bb1722f236b2bdb8">AutomorphismTransform</a> (const usint &amp;i) const =0</td></tr>
<tr class="memdesc:ac5dcc9fbc3a60640bb1722f236b2bdb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an automorphism transform operation and returns the result.  <a href="classlbcrypto_1_1ILElement.html#ac5dcc9fbc3a60640bb1722f236b2bdb8">More...</a><br /></td></tr>
<tr class="separator:ac5dcc9fbc3a60640bb1722f236b2bdb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc8d59503d85d7ad398b1a287fd86e1c"><td class="memItemLeft" align="right" valign="top">virtual Element&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#afc8d59503d85d7ad398b1a287fd86e1c">AutomorphismTransform</a> (usint i, const std::vector&lt; uint32_t &gt; &amp;map) const =0</td></tr>
<tr class="memdesc:afc8d59503d85d7ad398b1a287fd86e1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an automorphism transform operation using precomputed bit reversal indices.  <a href="classlbcrypto_1_1ILElement.html#afc8d59503d85d7ad398b1a287fd86e1c">More...</a><br /></td></tr>
<tr class="separator:afc8d59503d85d7ad398b1a287fd86e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d781be3bbb1386494f2f60ef4c93927"><td class="memItemLeft" align="right" valign="top">virtual Element&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#a9d781be3bbb1386494f2f60ef4c93927">Transpose</a> () const =0</td></tr>
<tr class="memdesc:a9d781be3bbb1386494f2f60ef4c93927"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose the ring element using the automorphism operation.  <a href="classlbcrypto_1_1ILElement.html#a9d781be3bbb1386494f2f60ef4c93927">More...</a><br /></td></tr>
<tr class="separator:a9d781be3bbb1386494f2f60ef4c93927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04e988bc884a7592cf9bf6f35f5ffca5"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#a04e988bc884a7592cf9bf6f35f5ffca5">BaseDecompose</a> (usint baseBits, bool evalModeAnswer=true) const =0</td></tr>
<tr class="memdesc:a04e988bc884a7592cf9bf6f35f5ffca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the element as <img class="formulaInl" alt="$ \sum\limits{i=0}^{\lfloor {\log q/base} \rfloor} {(base^i u_i)} $" src="form_0.png"/> and return the vector of <img class="formulaInl" alt="$ \left\{u_0, u_1,...,u_{\lfloor {\log q/base} \rfloor} \right\} \in R_{{base}^{\lceil {\log q/base} \rceil}} $" src="form_1.png"/>; This is used as a subroutine in the relinearization procedure.  <a href="classlbcrypto_1_1ILElement.html#a04e988bc884a7592cf9bf6f35f5ffca5">More...</a><br /></td></tr>
<tr class="separator:a04e988bc884a7592cf9bf6f35f5ffca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad335f96c10a85a9c1c969bd8366123"><td class="memItemLeft" align="right" valign="top">virtual Element&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#a7ad335f96c10a85a9c1c969bd8366123">DivideAndRound</a> (const IntType &amp;q) const =0</td></tr>
<tr class="memdesc:a7ad335f96c10a85a9c1c969bd8366123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar division followed by rounding operation - operation on all entries.  <a href="classlbcrypto_1_1ILElement.html#a7ad335f96c10a85a9c1c969bd8366123">More...</a><br /></td></tr>
<tr class="separator:a7ad335f96c10a85a9c1c969bd8366123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a5636cb0f6cfa9ce7ccdb6239f8bba"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#a87a5636cb0f6cfa9ce7ccdb6239f8bba">InverseExists</a> () const =0</td></tr>
<tr class="memdesc:a87a5636cb0f6cfa9ce7ccdb6239f8bba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if inverse exists.  <a href="classlbcrypto_1_1ILElement.html#a87a5636cb0f6cfa9ce7ccdb6239f8bba">More...</a><br /></td></tr>
<tr class="separator:a87a5636cb0f6cfa9ce7ccdb6239f8bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af05d67e38444a81ae0847f50665a17b0"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#af05d67e38444a81ae0847f50665a17b0">Norm</a> () const =0</td></tr>
<tr class="memdesc:af05d67e38444a81ae0847f50665a17b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the infinity norm, basically the largest value in the ring element.  <a href="classlbcrypto_1_1ILElement.html#af05d67e38444a81ae0847f50665a17b0">More...</a><br /></td></tr>
<tr class="separator:af05d67e38444a81ae0847f50665a17b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5da86b5e1c04a91d126f6220824e066c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#a5da86b5e1c04a91d126f6220824e066c">IsEmpty</a> () const =0</td></tr>
<tr class="memdesc:a5da86b5e1c04a91d126f6220824e066c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the vector is empty/ m_values==nullptr.  <a href="classlbcrypto_1_1ILElement.html#a5da86b5e1c04a91d126f6220824e066c">More...</a><br /></td></tr>
<tr class="separator:a5da86b5e1c04a91d126f6220824e066c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a470e37bbdb57df7b3e5a6ebd3d2f0f51"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#a470e37bbdb57df7b3e5a6ebd3d2f0f51">MakeSparse</a> (const uint32_t &amp;wFactor)=0</td></tr>
<tr class="memdesc:a470e37bbdb57df7b3e5a6ebd3d2f0f51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make the element Sparse for SHE KeyGen operations. Sets every index not equal to zero mod the wFactor to zero.  <a href="classlbcrypto_1_1ILElement.html#a470e37bbdb57df7b3e5a6ebd3d2f0f51">More...</a><br /></td></tr>
<tr class="separator:a470e37bbdb57df7b3e5a6ebd3d2f0f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e5fcbb9decceac48d33a94a81cfde6"><td class="memItemLeft" align="right" valign="top">virtual Element&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#a63e5fcbb9decceac48d33a94a81cfde6">ModByTwo</a> () const =0</td></tr>
<tr class="memdesc:a63e5fcbb9decceac48d33a94a81cfde6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate Element mod 2.  <a href="classlbcrypto_1_1ILElement.html#a63e5fcbb9decceac48d33a94a81cfde6">More...</a><br /></td></tr>
<tr class="separator:a63e5fcbb9decceac48d33a94a81cfde6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0feb835a89963a5a761c06d27c59bd6"><td class="memItemLeft" align="right" valign="top">virtual Element&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#ae0feb835a89963a5a761c06d27c59bd6">MultiplicativeInverse</a> () const =0</td></tr>
<tr class="memdesc:ae0feb835a89963a5a761c06d27c59bd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate and return the Multiplicative Inverse of the element.  <a href="classlbcrypto_1_1ILElement.html#ae0feb835a89963a5a761c06d27c59bd6">More...</a><br /></td></tr>
<tr class="separator:ae0feb835a89963a5a761c06d27c59bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ae88a999b925e069bfb4d92c68bfd6"><td class="memItemLeft" align="right" valign="top">virtual Element&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#a40ae88a999b925e069bfb4d92c68bfd6">MultiplyAndRound</a> (const IntType &amp;p, const IntType &amp;q) const =0</td></tr>
<tr class="memdesc:a40ae88a999b925e069bfb4d92c68bfd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar multiplication followed by division and rounding operation - operation on all entries.  <a href="classlbcrypto_1_1ILElement.html#a40ae88a999b925e069bfb4d92c68bfd6">More...</a><br /></td></tr>
<tr class="separator:a40ae88a999b925e069bfb4d92c68bfd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae3735eaf74bc0955519537441c098ba"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#aae3735eaf74bc0955519537441c098ba">PowersOfBase</a> (usint baseBits) const =0</td></tr>
<tr class="memdesc:aae3735eaf74bc0955519537441c098ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a vector of elements by raising the base element to successive powers.  <a href="classlbcrypto_1_1ILElement.html#aae3735eaf74bc0955519537441c098ba">More...</a><br /></td></tr>
<tr class="separator:aae3735eaf74bc0955519537441c098ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a344cbaf3a5cb2119a728d5588446cf5c"><td class="memItemLeft" align="right" valign="top">virtual Element&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#a344cbaf3a5cb2119a728d5588446cf5c">Mod</a> (const IntType &amp;modulus) const =0</td></tr>
<tr class="memdesc:a344cbaf3a5cb2119a728d5588446cf5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mod - perform a modulus operation. Does proper mapping of [-modulus/2, modulus/2) to [0, modulus).  <a href="classlbcrypto_1_1ILElement.html#a344cbaf3a5cb2119a728d5588446cf5c">More...</a><br /></td></tr>
<tr class="separator:a344cbaf3a5cb2119a728d5588446cf5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58eafec82f5f68c4e9efcf37324c0d03"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#a58eafec82f5f68c4e9efcf37324c0d03">SwitchModulus</a> (const IntType &amp;modulus, const IntType &amp;rootOfUnity, const IntType &amp;modulusArb=IntType::ZERO, const IntType &amp;rootOfUnityArb=IntType::ZERO)=0</td></tr>
<tr class="memdesc:a58eafec82f5f68c4e9efcf37324c0d03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switch modulus and adjust the values.  <a href="classlbcrypto_1_1ILElement.html#a58eafec82f5f68c4e9efcf37324c0d03">More...</a><br /></td></tr>
<tr class="separator:a58eafec82f5f68c4e9efcf37324c0d03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a95c1f067428962beeef9ac20f4fefc"><td class="memItemLeft" align="right" valign="top"><a id="a7a95c1f067428962beeef9ac20f4fefc"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#a7a95c1f067428962beeef9ac20f4fefc">SwitchFormat</a> ()=0</td></tr>
<tr class="memdesc:a7a95c1f067428962beeef9ac20f4fefc"><td class="mdescLeft">&#160;</td><td class="mdescRight">onvert from Coefficient to CRT or vice versa; calls FFT and inverse FFT. <br /></td></tr>
<tr class="separator:a7a95c1f067428962beeef9ac20f4fefc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e39b2a1a1ef24df9de8974acad76c43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1ILElement.html#a4e39b2a1a1ef24df9de8974acad76c43">SetFormat</a> (const Format format)</td></tr>
<tr class="memdesc:a4e39b2a1a1ef24df9de8974acad76c43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the format/representation of the element.  <a href="classlbcrypto_1_1ILElement.html#a4e39b2a1a1ef24df9de8974acad76c43">More...</a><br /></td></tr>
<tr class="separator:a4e39b2a1a1ef24df9de8974acad76c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classlbcrypto_1_1Serializable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classlbcrypto_1_1Serializable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classlbcrypto_1_1Serializable.html">lbcrypto::Serializable</a></td></tr>
<tr class="memitem:a1325a7f98c262df15af7aafee05a0368 inherit pub_methods_classlbcrypto_1_1Serializable"><td class="memItemLeft" align="right" valign="top"><a id="a1325a7f98c262df15af7aafee05a0368"></a>
virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><b>SerializedObjectName</b> () const =0</td></tr>
<tr class="separator:a1325a7f98c262df15af7aafee05a0368 inherit pub_methods_classlbcrypto_1_1Serializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Element, typename VecType&gt;<br />
class lbcrypto::ILElement&lt; Element, VecType &gt;</h3>

<p>Interface for ideal lattices. </p>
<p>Every lattice must implement these pure virtuals in order to properly interoperate with PALISADE PKE. Element is the return type for all of these virtual functions. There is no constructor here in the base class; it contains no data to construct. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a359fe4a33cd095b663313d970518c1b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a359fe4a33cd095b663313d970518c1b7">&#9670;&nbsp;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element , typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual IntType&amp; <a class="el" href="classlbcrypto_1_1ILElement.html">lbcrypto::ILElement</a>&lt; Element, VecType &gt;::at </td>
          <td>(</td>
          <td class="paramtype">usint&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the Value in the Element that is At Index and returns it. This is only implemented for some derived classes, so the default implementation throws an exception. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>is the index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>will throw an error. </dd></dl>

<p>Reimplemented in <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a51c801b6fd516206b274d90163dd4bf1">lbcrypto::DCRTPolyInterface&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a51c801b6fd516206b274d90163dd4bf1">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a51c801b6fd516206b274d90163dd4bf1">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; BigVector &gt;, BigVector, NativeVector, PolyImpl &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a3de4e1a07f58874a6f03f9de8cca63c2">lbcrypto::DCRTPolyImpl&lt; VecType &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a3de4e1a07f58874a6f03f9de8cca63c2">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>, <a class="el" href="classlbcrypto_1_1PolyImpl.html#aa400a6cd69cb62adaff8d2beefe1368c">lbcrypto::PolyImpl&lt; VecType &gt;</a>, <a class="el" href="classlbcrypto_1_1PolyImpl.html#aa400a6cd69cb62adaff8d2beefe1368c">lbcrypto::PolyImpl&lt; NativeVector &gt;</a>, and <a class="el" href="classlbcrypto_1_1PolyImpl.html#aa400a6cd69cb62adaff8d2beefe1368c">lbcrypto::PolyImpl&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="ac5dcc9fbc3a60640bb1722f236b2bdb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5dcc9fbc3a60640bb1722f236b2bdb8">&#9670;&nbsp;</a></span>AutomorphismTransform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element , typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Element <a class="el" href="classlbcrypto_1_1ILElement.html">lbcrypto::ILElement</a>&lt; Element, VecType &gt;::AutomorphismTransform </td>
          <td>(</td>
          <td class="paramtype">const usint &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs an automorphism transform operation and returns the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;i</td><td>is the element to perform the automorphism transform with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the automorphism transform. </dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1PolyImpl.html#af963604e83451dbece828d739f08529a">lbcrypto::PolyImpl&lt; VecType &gt;</a>, <a class="el" href="classlbcrypto_1_1PolyImpl.html#af963604e83451dbece828d739f08529a">lbcrypto::PolyImpl&lt; NativeVector &gt;</a>, <a class="el" href="classlbcrypto_1_1PolyImpl.html#af963604e83451dbece828d739f08529a">lbcrypto::PolyImpl&lt; BigVector &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a703db5691aa73e9b2988b07376017219">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a703db5691aa73e9b2988b07376017219">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; BigVector &gt;, BigVector, NativeVector, PolyImpl &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#ae7336e935f2a0cd14d6bcfc8a8a2f373">lbcrypto::DCRTPolyImpl&lt; VecType &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#ae7336e935f2a0cd14d6bcfc8a8a2f373">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>, and <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a703db5691aa73e9b2988b07376017219">lbcrypto::DCRTPolyInterface&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;</a>.</p>

</div>
</div>
<a id="afc8d59503d85d7ad398b1a287fd86e1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc8d59503d85d7ad398b1a287fd86e1c">&#9670;&nbsp;</a></span>AutomorphismTransform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element , typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Element <a class="el" href="classlbcrypto_1_1ILElement.html">lbcrypto::ILElement</a>&lt; Element, VecType &gt;::AutomorphismTransform </td>
          <td>(</td>
          <td class="paramtype">usint&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs an automorphism transform operation using precomputed bit reversal indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;i</td><td>is the element to perform the automorphism transform with. </td></tr>
    <tr><td class="paramname">&amp;map</td><td>a vector with precomputed indices </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the automorphism transform. </dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a5805c88f6af7bb50febbfe8d436298ab">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a5805c88f6af7bb50febbfe8d436298ab">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; BigVector &gt;, BigVector, NativeVector, PolyImpl &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a77f3f1e018b1687961203d6af9b7b1c6">lbcrypto::DCRTPolyImpl&lt; VecType &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a77f3f1e018b1687961203d6af9b7b1c6">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a5805c88f6af7bb50febbfe8d436298ab">lbcrypto::DCRTPolyInterface&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;</a>, <a class="el" href="classlbcrypto_1_1PolyImpl.html#afcf6810e27e35d44ae2d1187626ef3ae">lbcrypto::PolyImpl&lt; VecType &gt;</a>, <a class="el" href="classlbcrypto_1_1PolyImpl.html#afcf6810e27e35d44ae2d1187626ef3ae">lbcrypto::PolyImpl&lt; NativeVector &gt;</a>, and <a class="el" href="classlbcrypto_1_1PolyImpl.html#afcf6810e27e35d44ae2d1187626ef3ae">lbcrypto::PolyImpl&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="a04e988bc884a7592cf9bf6f35f5ffca5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04e988bc884a7592cf9bf6f35f5ffca5">&#9670;&nbsp;</a></span>BaseDecompose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element , typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;Element&gt; <a class="el" href="classlbcrypto_1_1ILElement.html">lbcrypto::ILElement</a>&lt; Element, VecType &gt;::BaseDecompose </td>
          <td>(</td>
          <td class="paramtype">usint&#160;</td>
          <td class="paramname"><em>baseBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>evalModeAnswer</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the element as <img class="formulaInl" alt="$ \sum\limits{i=0}^{\lfloor {\log q/base} \rfloor} {(base^i u_i)} $" src="form_0.png"/> and return the vector of <img class="formulaInl" alt="$ \left\{u_0, u_1,...,u_{\lfloor {\log q/base} \rfloor} \right\} \in R_{{base}^{\lceil {\log q/base} \rceil}} $" src="form_1.png"/>; This is used as a subroutine in the relinearization procedure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseBits</td><td>is the number of bits in the base, i.e., base = 2^baseBits </td></tr>
    <tr><td class="paramname">evalModeAnswer</td><td>- if true, convert the resultant polynomials to evaluation mode </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the pointer where the base decomposition vector is stored </dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#afceb52d627d4e7c5c03efaf5a1144bb3">lbcrypto::DCRTPolyImpl&lt; VecType &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#afceb52d627d4e7c5c03efaf5a1144bb3">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>, <a class="el" href="classlbcrypto_1_1PolyImpl.html#a21ce514c7be1acb1db2f340a6d30fd57">lbcrypto::PolyImpl&lt; VecType &gt;</a>, <a class="el" href="classlbcrypto_1_1PolyImpl.html#a21ce514c7be1acb1db2f340a6d30fd57">lbcrypto::PolyImpl&lt; NativeVector &gt;</a>, <a class="el" href="classlbcrypto_1_1PolyImpl.html#a21ce514c7be1acb1db2f340a6d30fd57">lbcrypto::PolyImpl&lt; BigVector &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#af494504657264b13c00a15bc27810dba">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#af494504657264b13c00a15bc27810dba">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; BigVector &gt;, BigVector, NativeVector, PolyImpl &gt;</a>, and <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#af494504657264b13c00a15bc27810dba">lbcrypto::DCRTPolyInterface&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;</a>.</p>

</div>
</div>
<a id="a70b85d0a6aea66ace2c983618ac8a489"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70b85d0a6aea66ace2c983618ac8a489">&#9670;&nbsp;</a></span>Clone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element , typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Element <a class="el" href="classlbcrypto_1_1ILElement.html">lbcrypto::ILElement</a>&lt; Element, VecType &gt;::Clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clone the object by making a copy of it and returning the copy. </p>
<dl class="section return"><dt>Returns</dt><dd>new Element </dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a1824ade6bc5ba90e9188de3bd2b400c7">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>, <a class="el" href="classlbcrypto_1_1PolyImpl.html#aa80d200080301cb8b64e0628479d5701">lbcrypto::PolyImpl&lt; NativeVector &gt;</a>, and <a class="el" href="classlbcrypto_1_1PolyImpl.html#aa80d200080301cb8b64e0628479d5701">lbcrypto::PolyImpl&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="a0a6b897331d1265eb815e6d50d295037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a6b897331d1265eb815e6d50d295037">&#9670;&nbsp;</a></span>CloneEmpty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element , typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Element <a class="el" href="classlbcrypto_1_1ILElement.html">lbcrypto::ILElement</a>&lt; Element, VecType &gt;::CloneEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clone the object, but have it contain nothing. </p>
<dl class="section return"><dt>Returns</dt><dd>new Element </dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#addb77b8b4292fee64c2eb4bf77d34f7a">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>, <a class="el" href="classlbcrypto_1_1PolyImpl.html#ac0edd50d3ffcdeb99eb1db4a0b15227b">lbcrypto::PolyImpl&lt; NativeVector &gt;</a>, and <a class="el" href="classlbcrypto_1_1PolyImpl.html#ac0edd50d3ffcdeb99eb1db4a0b15227b">lbcrypto::PolyImpl&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="a77a7aeb078733436bf1071b5127f79a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77a7aeb078733436bf1071b5127f79a7">&#9670;&nbsp;</a></span>CloneParametersOnly()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element , typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Element <a class="el" href="classlbcrypto_1_1ILElement.html">lbcrypto::ILElement</a>&lt; Element, VecType &gt;::CloneParametersOnly </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clones the element's parameters, leaves vector initialized to 0. </p>
<dl class="section return"><dt>Returns</dt><dd>new Element </dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a68b76f72afeb1471f7bafe8315059976">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>, <a class="el" href="classlbcrypto_1_1PolyImpl.html#a103ce73f7b7086c10847638afe033ad5">lbcrypto::PolyImpl&lt; NativeVector &gt;</a>, and <a class="el" href="classlbcrypto_1_1PolyImpl.html#a103ce73f7b7086c10847638afe033ad5">lbcrypto::PolyImpl&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="a45e2e2a2bacd65456e0ce82aaf33e23e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45e2e2a2bacd65456e0ce82aaf33e23e">&#9670;&nbsp;</a></span>CloneWithNoise()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element , typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Element <a class="el" href="classlbcrypto_1_1ILElement.html">lbcrypto::ILElement</a>&lt; Element, VecType &gt;::CloneWithNoise </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlbcrypto_1_1DiscreteGaussianGeneratorImpl.html">DiscreteGaussianGeneratorImpl</a>&lt; VecType &gt; &amp;&#160;</td>
          <td class="paramname"><em>dgg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Format&#160;</td>
          <td class="paramname"><em>format</em> = <code>Format::EVALUATION</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clones the element with parameters and with noise for the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dgg</td><td></td></tr>
    <tr><td class="paramname">format</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new Element </dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a4ad0f93665a2538b35dc21982d8f8170">lbcrypto::DCRTPolyImpl&lt; VecType &gt;</a>, <a class="el" href="classlbcrypto_1_1PolyImpl.html#a8ea9829587d5df87526951ad6fecc97d">lbcrypto::PolyImpl&lt; VecType &gt;</a>, <a class="el" href="classlbcrypto_1_1PolyImpl.html#a8ea9829587d5df87526951ad6fecc97d">lbcrypto::PolyImpl&lt; NativeVector &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a4ad0f93665a2538b35dc21982d8f8170">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>, and <a class="el" href="classlbcrypto_1_1PolyImpl.html#a8ea9829587d5df87526951ad6fecc97d">lbcrypto::PolyImpl&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="a7ad335f96c10a85a9c1c969bd8366123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ad335f96c10a85a9c1c969bd8366123">&#9670;&nbsp;</a></span>DivideAndRound()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element , typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Element <a class="el" href="classlbcrypto_1_1ILElement.html">lbcrypto::ILElement</a>&lt; Element, VecType &gt;::DivideAndRound </td>
          <td>(</td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scalar division followed by rounding operation - operation on all entries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;q</td><td>is the element to divide entry-wise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the return value of the divide, followed by rounding operation. </dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1PolyImpl.html#aa475940622a70d982ca6b05051974cf1">lbcrypto::PolyImpl&lt; VecType &gt;</a>, <a class="el" href="classlbcrypto_1_1PolyImpl.html#aa475940622a70d982ca6b05051974cf1">lbcrypto::PolyImpl&lt; NativeVector &gt;</a>, <a class="el" href="classlbcrypto_1_1PolyImpl.html#aa475940622a70d982ca6b05051974cf1">lbcrypto::PolyImpl&lt; BigVector &gt;</a>, and <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a509bf1d5399f63247aa1af0aa1ebd4df">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; BigVector &gt;, BigVector, NativeVector, PolyImpl &gt;</a>.</p>

</div>
</div>
<a id="a7de6762a19c79d5a0be9896a2b69498c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7de6762a19c79d5a0be9896a2b69498c">&#9670;&nbsp;</a></span>GetCyclotomicOrder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element , typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual usint <a class="el" href="classlbcrypto_1_1ILElement.html">lbcrypto::ILElement</a>&lt; Element, VecType &gt;::GetCyclotomicOrder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the cyclotomic order. </p>
<dl class="section return"><dt>Returns</dt><dd>order </dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1PolyImpl.html#a424d69e38a8b7ba5fd8aed56533b5698">lbcrypto::PolyImpl&lt; NativeVector &gt;</a>, <a class="el" href="classlbcrypto_1_1PolyImpl.html#a424d69e38a8b7ba5fd8aed56533b5698">lbcrypto::PolyImpl&lt; BigVector &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a40c59a54a3117891aaf660f5d2f0bea2">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>, and <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a40c59a54a3117891aaf660f5d2f0bea2">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; BigVector &gt;, BigVector, NativeVector, PolyImpl &gt;</a>.</p>

</div>
</div>
<a id="ac7d2c897610e5923b5418f7227393272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7d2c897610e5923b5418f7227393272">&#9670;&nbsp;</a></span>GetFormat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element , typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Format <a class="el" href="classlbcrypto_1_1ILElement.html">lbcrypto::ILElement</a>&lt; Element, VecType &gt;::GetFormat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get format of the element. </p>
<dl class="section return"><dt>Returns</dt><dd>Format is either COEFFICIENT or EVALUATION </dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1PolyImpl.html#a534135aa3d1b58ae71f5460f1ea9efec">lbcrypto::PolyImpl&lt; NativeVector &gt;</a>, <a class="el" href="classlbcrypto_1_1PolyImpl.html#a534135aa3d1b58ae71f5460f1ea9efec">lbcrypto::PolyImpl&lt; BigVector &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a09b5764dee7d4a77f0a8832d94ba37f5">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>, and <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a09b5764dee7d4a77f0a8832d94ba37f5">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; BigVector &gt;, BigVector, NativeVector, PolyImpl &gt;</a>.</p>

</div>
</div>
<a id="af9eeef930f29aa94f77cca1a86fabf6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9eeef930f29aa94f77cca1a86fabf6e">&#9670;&nbsp;</a></span>GetLength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element , typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual usint <a class="el" href="classlbcrypto_1_1ILElement.html">lbcrypto::ILElement</a>&lt; Element, VecType &gt;::GetLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the length of the element. </p>
<dl class="section return"><dt>Returns</dt><dd>length </dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1PolyImpl.html#acb2441e5175b61c7e0628cf75f9661d0">lbcrypto::PolyImpl&lt; NativeVector &gt;</a>, <a class="el" href="classlbcrypto_1_1PolyImpl.html#acb2441e5175b61c7e0628cf75f9661d0">lbcrypto::PolyImpl&lt; BigVector &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#add0c94d87832fec8fa4c2c60aa1fd23e">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>, and <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#add0c94d87832fec8fa4c2c60aa1fd23e">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; BigVector &gt;, BigVector, NativeVector, PolyImpl &gt;</a>.</p>

</div>
</div>
<a id="aacc0cf9d638c8e613fb0c646456be0a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacc0cf9d638c8e613fb0c646456be0a0">&#9670;&nbsp;</a></span>GetModulus()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element , typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const IntType&amp; <a class="el" href="classlbcrypto_1_1ILElement.html">lbcrypto::ILElement</a>&lt; Element, VecType &gt;::GetModulus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get modulus of the element. </p>
<dl class="section return"><dt>Returns</dt><dd>the modulus. </dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1PolyImpl.html#a03bd35b3c56f8ff48c413e0a3ce5e4ac">lbcrypto::PolyImpl&lt; NativeVector &gt;</a>, <a class="el" href="classlbcrypto_1_1PolyImpl.html#a03bd35b3c56f8ff48c413e0a3ce5e4ac">lbcrypto::PolyImpl&lt; BigVector &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a20af925ea09544588f834f8021d68f9a">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>, and <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a20af925ea09544588f834f8021d68f9a">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; BigVector &gt;, BigVector, NativeVector, PolyImpl &gt;</a>.</p>

</div>
</div>
<a id="a474bbec1e55b18ecf1fc52b806d7f186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a474bbec1e55b18ecf1fc52b806d7f186">&#9670;&nbsp;</a></span>GetValues()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element , typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const VecType&amp; <a class="el" href="classlbcrypto_1_1ILElement.html">lbcrypto::ILElement</a>&lt; Element, VecType &gt;::GetValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the values for the element. </p>
<dl class="section return"><dt>Returns</dt><dd>the vector. </dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#af35691c5c689c9804b87ad18e08269ba">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#af35691c5c689c9804b87ad18e08269ba">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; BigVector &gt;, BigVector, NativeVector, PolyImpl &gt;</a>, <a class="el" href="classlbcrypto_1_1PolyImpl.html#ab05345c9b194dd5757a203cc21649c51">lbcrypto::PolyImpl&lt; NativeVector &gt;</a>, and <a class="el" href="classlbcrypto_1_1PolyImpl.html#ab05345c9b194dd5757a203cc21649c51">lbcrypto::PolyImpl&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="a87a5636cb0f6cfa9ce7ccdb6239f8bba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87a5636cb0f6cfa9ce7ccdb6239f8bba">&#9670;&nbsp;</a></span>InverseExists()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element , typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classlbcrypto_1_1ILElement.html">lbcrypto::ILElement</a>&lt; Element, VecType &gt;::InverseExists </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if inverse exists. </p>
<dl class="section return"><dt>Returns</dt><dd>true if there exists a multiplicative inverse. </dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a6d84bf03f20db3d0b46a40efb7d9f746">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a6d84bf03f20db3d0b46a40efb7d9f746">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; BigVector &gt;, BigVector, NativeVector, PolyImpl &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a344d2b7f16a8aa10a4006dfd972a78e1">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>, <a class="el" href="classlbcrypto_1_1PolyImpl.html#ad0baa40846bc835c2e4f7af208159e78">lbcrypto::PolyImpl&lt; NativeVector &gt;</a>, and <a class="el" href="classlbcrypto_1_1PolyImpl.html#ad0baa40846bc835c2e4f7af208159e78">lbcrypto::PolyImpl&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="a5da86b5e1c04a91d126f6220824e066c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5da86b5e1c04a91d126f6220824e066c">&#9670;&nbsp;</a></span>IsEmpty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element , typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classlbcrypto_1_1ILElement.html">lbcrypto::ILElement</a>&lt; Element, VecType &gt;::IsEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the vector is empty/ m_values==nullptr. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the vector is empty and all values nullptr. false otherwise. </dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a278d9399c70da14dd2984df93749d881">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a278d9399c70da14dd2984df93749d881">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; BigVector &gt;, BigVector, NativeVector, PolyImpl &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#abc4b6a822c5551bf0f23b61e1426d26e">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>, <a class="el" href="classlbcrypto_1_1PolyImpl.html#af48c903ba749ff383e648655ef752b43">lbcrypto::PolyImpl&lt; NativeVector &gt;</a>, and <a class="el" href="classlbcrypto_1_1PolyImpl.html#af48c903ba749ff383e648655ef752b43">lbcrypto::PolyImpl&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="a470e37bbdb57df7b3e5a6ebd3d2f0f51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a470e37bbdb57df7b3e5a6ebd3d2f0f51">&#9670;&nbsp;</a></span>MakeSparse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element , typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classlbcrypto_1_1ILElement.html">lbcrypto::ILElement</a>&lt; Element, VecType &gt;::MakeSparse </td>
          <td>(</td>
          <td class="paramtype">const uint32_t &amp;&#160;</td>
          <td class="paramname"><em>wFactor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make the element Sparse for SHE KeyGen operations. Sets every index not equal to zero mod the wFactor to zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;wFactor</td><td>ratio between the original element's ring dimension and the new ring dimension. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a13383a02ee6a007a1c4cf5ea07c3c707">lbcrypto::DCRTPolyImpl&lt; VecType &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a13383a02ee6a007a1c4cf5ea07c3c707">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a4c06761fc369968fe907d8aaea9596fc">lbcrypto::DCRTPolyInterface&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a4c06761fc369968fe907d8aaea9596fc">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a4c06761fc369968fe907d8aaea9596fc">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; BigVector &gt;, BigVector, NativeVector, PolyImpl &gt;</a>, <a class="el" href="classlbcrypto_1_1PolyImpl.html#a0de7ca1e8b61582fe34ae39a30121dd7">lbcrypto::PolyImpl&lt; VecType &gt;</a>, <a class="el" href="classlbcrypto_1_1PolyImpl.html#a0de7ca1e8b61582fe34ae39a30121dd7">lbcrypto::PolyImpl&lt; NativeVector &gt;</a>, and <a class="el" href="classlbcrypto_1_1PolyImpl.html#a0de7ca1e8b61582fe34ae39a30121dd7">lbcrypto::PolyImpl&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="a9b308cd85c096a6c150a35a4e8e52970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b308cd85c096a6c150a35a4e8e52970">&#9670;&nbsp;</a></span>Minus() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element , typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Element <a class="el" href="classlbcrypto_1_1ILElement.html">lbcrypto::ILElement</a>&lt; Element, VecType &gt;::Minus </td>
          <td>(</td>
          <td class="paramtype">const Element &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a subtraction operation and returns the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;element</td><td>is the element to subtract with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the subtraction. </dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1PolyImpl.html#a1399ff352291718f08c89479b0dde3b4">lbcrypto::PolyImpl&lt; VecType &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a3ec584b5d32386e4f3682bb8a386aa6b">lbcrypto::DCRTPolyInterface&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a9094f635ef1078a91ffae5c4520e6615">lbcrypto::DCRTPolyImpl&lt; VecType &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a3ec584b5d32386e4f3682bb8a386aa6b">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>, and <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a3ec584b5d32386e4f3682bb8a386aa6b">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; BigVector &gt;, BigVector, NativeVector, PolyImpl &gt;</a>.</p>

</div>
</div>
<a id="aceb6e03c9b3106a45c13f3488bdaf403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceb6e03c9b3106a45c13f3488bdaf403">&#9670;&nbsp;</a></span>Minus() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element , typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Element <a class="el" href="classlbcrypto_1_1ILElement.html">lbcrypto::ILElement</a>&lt; Element, VecType &gt;::Minus </td>
          <td>(</td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scalar subtraction - subtract an element frp, all entries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;element</td><td>is the element to subtract entry-wise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the return value of the minus operation. </dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#ade9a9e38b6c5b4e0a445f1526bb731d6">lbcrypto::DCRTPolyImpl&lt; VecType &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#ade9a9e38b6c5b4e0a445f1526bb731d6">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>, <a class="el" href="classlbcrypto_1_1PolyImpl.html#add84af7037fbd9af64d30198333d0959">lbcrypto::PolyImpl&lt; VecType &gt;</a>, <a class="el" href="classlbcrypto_1_1PolyImpl.html#add84af7037fbd9af64d30198333d0959">lbcrypto::PolyImpl&lt; NativeVector &gt;</a>, <a class="el" href="classlbcrypto_1_1PolyImpl.html#add84af7037fbd9af64d30198333d0959">lbcrypto::PolyImpl&lt; BigVector &gt;</a>, and <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a1dfadd41ee3fc03df8375b1548e619ec">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; BigVector &gt;, BigVector, NativeVector, PolyImpl &gt;</a>.</p>

</div>
</div>
<a id="a344cbaf3a5cb2119a728d5588446cf5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a344cbaf3a5cb2119a728d5588446cf5c">&#9670;&nbsp;</a></span>Mod()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element , typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Element <a class="el" href="classlbcrypto_1_1ILElement.html">lbcrypto::ILElement</a>&lt; Element, VecType &gt;::Mod </td>
          <td>(</td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>modulus</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mod - perform a modulus operation. Does proper mapping of [-modulus/2, modulus/2) to [0, modulus). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">modulus</td><td>is the modulus to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the return value of the modulus. </dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1PolyImpl.html#a0b3c7f2e197dc884227af66d01ac424b">lbcrypto::PolyImpl&lt; VecType &gt;</a>, <a class="el" href="classlbcrypto_1_1PolyImpl.html#a0b3c7f2e197dc884227af66d01ac424b">lbcrypto::PolyImpl&lt; NativeVector &gt;</a>, <a class="el" href="classlbcrypto_1_1PolyImpl.html#a0b3c7f2e197dc884227af66d01ac424b">lbcrypto::PolyImpl&lt; BigVector &gt;</a>, and <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#ae234c1d7db46ab3ed963d0ef1257d39b">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; BigVector &gt;, BigVector, NativeVector, PolyImpl &gt;</a>.</p>

</div>
</div>
<a id="a63e5fcbb9decceac48d33a94a81cfde6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63e5fcbb9decceac48d33a94a81cfde6">&#9670;&nbsp;</a></span>ModByTwo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element , typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Element <a class="el" href="classlbcrypto_1_1ILElement.html">lbcrypto::ILElement</a>&lt; Element, VecType &gt;::ModByTwo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate Element mod 2. </p>
<dl class="section return"><dt>Returns</dt><dd>result of performing a mod-2 operation on the element. </dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#ad10296261f590b69a2efd23a6b57e698">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#ad10296261f590b69a2efd23a6b57e698">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; BigVector &gt;, BigVector, NativeVector, PolyImpl &gt;</a>, <a class="el" href="classlbcrypto_1_1PolyImpl.html#ac80a2a9dbb58503223d578413a1ac743">lbcrypto::PolyImpl&lt; NativeVector &gt;</a>, and <a class="el" href="classlbcrypto_1_1PolyImpl.html#ac80a2a9dbb58503223d578413a1ac743">lbcrypto::PolyImpl&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="ae0feb835a89963a5a761c06d27c59bd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0feb835a89963a5a761c06d27c59bd6">&#9670;&nbsp;</a></span>MultiplicativeInverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element , typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Element <a class="el" href="classlbcrypto_1_1ILElement.html">lbcrypto::ILElement</a>&lt; Element, VecType &gt;::MultiplicativeInverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate and return the Multiplicative Inverse of the element. </p>
<dl class="section return"><dt>Returns</dt><dd>the multiplicative inverse of the element, if it exists. </dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#aa1426c1b052a5ae4b9ccc1b0d738dec1">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#aa1426c1b052a5ae4b9ccc1b0d738dec1">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; BigVector &gt;, BigVector, NativeVector, PolyImpl &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#acd897dd2c899f77b863fefce1eb8c7eb">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>, <a class="el" href="classlbcrypto_1_1PolyImpl.html#af80793a7c722f9762b82380dd34b655b">lbcrypto::PolyImpl&lt; NativeVector &gt;</a>, and <a class="el" href="classlbcrypto_1_1PolyImpl.html#af80793a7c722f9762b82380dd34b655b">lbcrypto::PolyImpl&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="a40ae88a999b925e069bfb4d92c68bfd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40ae88a999b925e069bfb4d92c68bfd6">&#9670;&nbsp;</a></span>MultiplyAndRound()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element , typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Element <a class="el" href="classlbcrypto_1_1ILElement.html">lbcrypto::ILElement</a>&lt; Element, VecType &gt;::MultiplyAndRound </td>
          <td>(</td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scalar multiplication followed by division and rounding operation - operation on all entries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;p</td><td>is the integer muliplicand. </td></tr>
    <tr><td class="paramname">&amp;q</td><td>is the integer divisor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the return value of the multiply, divide and followed by rounding operation. </dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1PolyImpl.html#a69fcb1cfe8435b022607c69f80ad33bf">lbcrypto::PolyImpl&lt; VecType &gt;</a>, <a class="el" href="classlbcrypto_1_1PolyImpl.html#a69fcb1cfe8435b022607c69f80ad33bf">lbcrypto::PolyImpl&lt; NativeVector &gt;</a>, <a class="el" href="classlbcrypto_1_1PolyImpl.html#a69fcb1cfe8435b022607c69f80ad33bf">lbcrypto::PolyImpl&lt; BigVector &gt;</a>, and <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a9c299cc747f5176cdf79912089e0238d">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; BigVector &gt;, BigVector, NativeVector, PolyImpl &gt;</a>.</p>

</div>
</div>
<a id="af05d67e38444a81ae0847f50665a17b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af05d67e38444a81ae0847f50665a17b0">&#9670;&nbsp;</a></span>Norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element , typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double <a class="el" href="classlbcrypto_1_1ILElement.html">lbcrypto::ILElement</a>&lt; Element, VecType &gt;::Norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the infinity norm, basically the largest value in the ring element. </p>
<dl class="section return"><dt>Returns</dt><dd>the largest value in the ring element. </dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a4dce2c859629115a2453bb8726e8e137">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a4dce2c859629115a2453bb8726e8e137">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; BigVector &gt;, BigVector, NativeVector, PolyImpl &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a214892eae601551e99859e161ddc56eb">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>, <a class="el" href="classlbcrypto_1_1PolyImpl.html#aa5be747e2256651b3e4980fd2963057c">lbcrypto::PolyImpl&lt; NativeVector &gt;</a>, and <a class="el" href="classlbcrypto_1_1PolyImpl.html#aa5be747e2256651b3e4980fd2963057c">lbcrypto::PolyImpl&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="ac59b8d3af7b29f7225ee37dc83214e79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac59b8d3af7b29f7225ee37dc83214e79">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element , typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classlbcrypto_1_1ILElement.html">lbcrypto::ILElement</a>&lt; Element, VecType &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const Element &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality operator. Compares values of element to be compared to. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>the element to compare to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adecf4245b01406e2a2568fad52434494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adecf4245b01406e2a2568fad52434494">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element , typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const Element&amp; <a class="el" href="classlbcrypto_1_1ILElement.html">lbcrypto::ILElement</a>&lt; Element, VecType &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const Element &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs an multiplication operation and returns the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;element</td><td>is the element to multiply by </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the multiplication. </dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1PolyImpl.html#ae75246b20ed59d79ffb48f1aefbef2e3">lbcrypto::PolyImpl&lt; VecType &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#afc908662a421a5f61b9d555cf4feaa51">lbcrypto::DCRTPolyInterface&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#abc02a96815782bfe2dc8562ed5985030">lbcrypto::DCRTPolyImpl&lt; VecType &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#afc908662a421a5f61b9d555cf4feaa51">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>, and <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#afc908662a421a5f61b9d555cf4feaa51">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; BigVector &gt;, BigVector, NativeVector, PolyImpl &gt;</a>.</p>

</div>
</div>
<a id="abb0670789e94757db373df45ff9067cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb0670789e94757db373df45ff9067cd">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element , typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const Element&amp; <a class="el" href="classlbcrypto_1_1ILElement.html">lbcrypto::ILElement</a>&lt; Element, VecType &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs *= operation with a BigInteger and returns the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;element</td><td>is the element to multiply by </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the multiplication. </dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a63a5c2efe731d3835f1cbfcbfde7c0ca">lbcrypto::DCRTPolyImpl&lt; VecType &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a63a5c2efe731d3835f1cbfcbfde7c0ca">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>, <a class="el" href="classlbcrypto_1_1PolyImpl.html#a564a454fcda3474ee8f53c3c4db00e44">lbcrypto::PolyImpl&lt; VecType &gt;</a>, <a class="el" href="classlbcrypto_1_1PolyImpl.html#a564a454fcda3474ee8f53c3c4db00e44">lbcrypto::PolyImpl&lt; NativeVector &gt;</a>, <a class="el" href="classlbcrypto_1_1PolyImpl.html#a564a454fcda3474ee8f53c3c4db00e44">lbcrypto::PolyImpl&lt; BigVector &gt;</a>, and <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a649ce1d2b14105bd41e6a33caf7912a2">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; BigVector &gt;, BigVector, NativeVector, PolyImpl &gt;</a>.</p>

</div>
</div>
<a id="ad2fa2e51c8be146bdc2b739b40f4bf1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2fa2e51c8be146bdc2b739b40f4bf1f">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element , typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const Element&amp; <a class="el" href="classlbcrypto_1_1ILElement.html">lbcrypto::ILElement</a>&lt; Element, VecType &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const Element &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs an addition operation and returns the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;element</td><td>is the element to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the addition. </dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1PolyImpl.html#abc59440b7ca2b8e07c7a7172953c13f6">lbcrypto::PolyImpl&lt; VecType &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a126c7febc3ab3bc45522ef94bf835e7c">lbcrypto::DCRTPolyInterface&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#afccab6ba0d328ddb7edcafe133e5d1dc">lbcrypto::DCRTPolyImpl&lt; VecType &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a126c7febc3ab3bc45522ef94bf835e7c">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>, and <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a126c7febc3ab3bc45522ef94bf835e7c">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; BigVector &gt;, BigVector, NativeVector, PolyImpl &gt;</a>.</p>

</div>
</div>
<a id="ad5763872f5ef073a213c3d7564bb1359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5763872f5ef073a213c3d7564bb1359">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element , typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const Element&amp; <a class="el" href="classlbcrypto_1_1ILElement.html">lbcrypto::ILElement</a>&lt; Element, VecType &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs += operation with a BigInteger and returns the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;element</td><td>is the element to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the addition. </dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#ad5f25491a1471ffb6b028cd06082cd7f">lbcrypto::DCRTPolyImpl&lt; VecType &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#ad5f25491a1471ffb6b028cd06082cd7f">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>, <a class="el" href="classlbcrypto_1_1PolyImpl.html#aa44ed42387d54ee40194e3382d1df049">lbcrypto::PolyImpl&lt; VecType &gt;</a>, <a class="el" href="classlbcrypto_1_1PolyImpl.html#aa44ed42387d54ee40194e3382d1df049">lbcrypto::PolyImpl&lt; NativeVector &gt;</a>, and <a class="el" href="classlbcrypto_1_1PolyImpl.html#aa44ed42387d54ee40194e3382d1df049">lbcrypto::PolyImpl&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="a746f4dd63222b09c45ad989b8045bae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a746f4dd63222b09c45ad989b8045bae7">&#9670;&nbsp;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element , typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Element <a class="el" href="classlbcrypto_1_1ILElement.html">lbcrypto::ILElement</a>&lt; Element, VecType &gt;::operator- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unary negation on a lattice. </p>
<dl class="section return"><dt>Returns</dt><dd>-lattice </dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a98d4c5817cba2c2b2b9188c05870e39f">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a98d4c5817cba2c2b2b9188c05870e39f">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; BigVector &gt;, BigVector, NativeVector, PolyImpl &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a52f5c45054cfb7fa5587e5f2ba961cde">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>, <a class="el" href="classlbcrypto_1_1PolyImpl.html#af1c492bba9dda877984ac6e3bfb93136">lbcrypto::PolyImpl&lt; NativeVector &gt;</a>, and <a class="el" href="classlbcrypto_1_1PolyImpl.html#af1c492bba9dda877984ac6e3bfb93136">lbcrypto::PolyImpl&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="a16234919ba5cedf710fe8d6dbd071e44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16234919ba5cedf710fe8d6dbd071e44">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element , typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const Element&amp; <a class="el" href="classlbcrypto_1_1ILElement.html">lbcrypto::ILElement</a>&lt; Element, VecType &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const Element &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs an subtraction operation and returns the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;element</td><td>is the element to subtract </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the addition. </dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1PolyImpl.html#a4c7698a7c31f4506133cc1098ef3ebb3">lbcrypto::PolyImpl&lt; VecType &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a06ac6a37ad6be0a9055cb9dbedd2a9bc">lbcrypto::DCRTPolyInterface&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#aa965df981061d0f6390293612613b8a1">lbcrypto::DCRTPolyImpl&lt; VecType &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a06ac6a37ad6be0a9055cb9dbedd2a9bc">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>, and <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a06ac6a37ad6be0a9055cb9dbedd2a9bc">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; BigVector &gt;, BigVector, NativeVector, PolyImpl &gt;</a>.</p>

</div>
</div>
<a id="ae7b6b8e3c0fe6e82a736e0697a381856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7b6b8e3c0fe6e82a736e0697a381856">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element , typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const Element&amp; <a class="el" href="classlbcrypto_1_1ILElement.html">lbcrypto::ILElement</a>&lt; Element, VecType &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs -= operation with a BigInteger and returns the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;element</td><td>is the element to subtract </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the addition. </dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#aa0946e79b8bfd1bb65600b0a203b8899">lbcrypto::DCRTPolyImpl&lt; VecType &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#aa0946e79b8bfd1bb65600b0a203b8899">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>, <a class="el" href="classlbcrypto_1_1PolyImpl.html#aebaa5316ab903047255b3a87b2645e9f">lbcrypto::PolyImpl&lt; VecType &gt;</a>, <a class="el" href="classlbcrypto_1_1PolyImpl.html#aebaa5316ab903047255b3a87b2645e9f">lbcrypto::PolyImpl&lt; NativeVector &gt;</a>, <a class="el" href="classlbcrypto_1_1PolyImpl.html#aebaa5316ab903047255b3a87b2645e9f">lbcrypto::PolyImpl&lt; BigVector &gt;</a>, and <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#ae624e9a0fb904bdee4c7b536e12d6808">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; BigVector &gt;, BigVector, NativeVector, PolyImpl &gt;</a>.</p>

</div>
</div>
<a id="aa4c6ccfa8477a16e4f11df540100e847"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4c6ccfa8477a16e4f11df540100e847">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element , typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const Element&amp; <a class="el" href="classlbcrypto_1_1ILElement.html">lbcrypto::ILElement</a>&lt; Element, VecType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const Element &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator that copies elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1PolyImpl.html#a83bfd2cf28d171b050a63d986d24b72f">lbcrypto::PolyImpl&lt; VecType &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a6c3acffd584a927600c188a32626b7c5">lbcrypto::DCRTPolyInterface&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a194ec63fd9ff31e9bde2974268525ba9">lbcrypto::DCRTPolyImpl&lt; VecType &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a6c3acffd584a927600c188a32626b7c5">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>, and <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a6c3acffd584a927600c188a32626b7c5">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; BigVector &gt;, BigVector, NativeVector, PolyImpl &gt;</a>.</p>

</div>
</div>
<a id="a1cc3339607ccbccb15fcfe8deb84b3be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cc3339607ccbccb15fcfe8deb84b3be">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element , typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const Element&amp; <a class="el" href="classlbcrypto_1_1ILElement.html">lbcrypto::ILElement</a>&lt; Element, VecType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">Element &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator that copies elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1PolyImpl.html#a9210553d57605fdab50e7f8a229e4f92">lbcrypto::PolyImpl&lt; VecType &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a7b97ec6ea90493c8c4ef7e77bf7f4800">lbcrypto::DCRTPolyInterface&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#abd56802ffaaabf5f8b8e1ebaec49a529">lbcrypto::DCRTPolyImpl&lt; VecType &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a7b97ec6ea90493c8c4ef7e77bf7f4800">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>, and <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a7b97ec6ea90493c8c4ef7e77bf7f4800">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; BigVector &gt;, BigVector, NativeVector, PolyImpl &gt;</a>.</p>

</div>
</div>
<a id="a7d6c463d45b96bd973af2c5564b62ced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d6c463d45b96bd973af2c5564b62ced">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element , typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const Element&amp; <a class="el" href="classlbcrypto_1_1ILElement.html">lbcrypto::ILElement</a>&lt; Element, VecType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; uint64_t &gt;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator that copies elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a3c21084ea80bc73c22800792f78efa26">lbcrypto::DCRTPolyInterface&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a3c21084ea80bc73c22800792f78efa26">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a3c21084ea80bc73c22800792f78efa26">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; BigVector &gt;, BigVector, NativeVector, PolyImpl &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a2758f06a1075c396b73344ed3a13a734">lbcrypto::DCRTPolyImpl&lt; VecType &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a2758f06a1075c396b73344ed3a13a734">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>, <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html#af5f92cd8de1c2158c048379eb3a7d936">lbcrypto::HexlDCRTPoly&lt; VecType &gt;</a>, <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html#af5f92cd8de1c2158c048379eb3a7d936">lbcrypto::HexlDCRTPoly&lt; BigVector &gt;</a>, <a class="el" href="classlbcrypto_1_1PolyImpl.html#a0c6f9d80eca0a8bb416ed90ff660defe">lbcrypto::PolyImpl&lt; VecType &gt;</a>, <a class="el" href="classlbcrypto_1_1PolyImpl.html#a0c6f9d80eca0a8bb416ed90ff660defe">lbcrypto::PolyImpl&lt; NativeVector &gt;</a>, and <a class="el" href="classlbcrypto_1_1PolyImpl.html#a0c6f9d80eca0a8bb416ed90ff660defe">lbcrypto::PolyImpl&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="a87f7a9ab6c062085297399a40a3dec4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87f7a9ab6c062085297399a40a3dec4b">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element , typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classlbcrypto_1_1ILElement.html">lbcrypto::ILElement</a>&lt; Element, VecType &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const Element &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator. Compares values of element to be compared to. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>the element to compare to. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1PolyImpl.html#a37d4b6e898ac4375c0ef1efca9872dcd">lbcrypto::PolyImpl&lt; VecType &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a845271828e9e902a65840752b3fdcc16">lbcrypto::DCRTPolyInterface&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a38d217014f2f8e5075ab2b7d211ffae9">lbcrypto::DCRTPolyImpl&lt; VecType &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a845271828e9e902a65840752b3fdcc16">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>, and <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a845271828e9e902a65840752b3fdcc16">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; BigVector &gt;, BigVector, NativeVector, PolyImpl &gt;</a>.</p>

</div>
</div>
<a id="a38a6503240f38927f387a628c764b47e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38a6503240f38927f387a628c764b47e">&#9670;&nbsp;</a></span>Plus() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element , typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Element <a class="el" href="classlbcrypto_1_1ILElement.html">lbcrypto::ILElement</a>&lt; Element, VecType &gt;::Plus </td>
          <td>(</td>
          <td class="paramtype">const Element &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs an addition operation and returns the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;element</td><td>is the element to add with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the addition. </dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1PolyImpl.html#a8a58bd80ec65a468c2d02c87db0c1ebe">lbcrypto::PolyImpl&lt; VecType &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a0c1193a99a15b71b7eb3b544b53b827e">lbcrypto::DCRTPolyInterface&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a9a3cea10ad195e8b3408da102f0ec9b7">lbcrypto::DCRTPolyImpl&lt; VecType &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a0c1193a99a15b71b7eb3b544b53b827e">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>, and <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a0c1193a99a15b71b7eb3b544b53b827e">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; BigVector &gt;, BigVector, NativeVector, PolyImpl &gt;</a>.</p>

</div>
</div>
<a id="a07683b181b31fb853a4988a7f35bc776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07683b181b31fb853a4988a7f35bc776">&#9670;&nbsp;</a></span>Plus() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element , typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Element <a class="el" href="classlbcrypto_1_1ILElement.html">lbcrypto::ILElement</a>&lt; Element, VecType &gt;::Plus </td>
          <td>(</td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scalar addition - add an element to the first index only. This operation is only allowed in COEFFICIENT format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;element</td><td>is the element to add entry-wise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the return of the addition operation. </dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#af531265d23d28fc85776bff0789e5205">lbcrypto::DCRTPolyImpl&lt; VecType &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#af531265d23d28fc85776bff0789e5205">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>, <a class="el" href="classlbcrypto_1_1PolyImpl.html#a0d6033450fc8e047de46cd6dfc5ad5ae">lbcrypto::PolyImpl&lt; VecType &gt;</a>, <a class="el" href="classlbcrypto_1_1PolyImpl.html#a0d6033450fc8e047de46cd6dfc5ad5ae">lbcrypto::PolyImpl&lt; NativeVector &gt;</a>, <a class="el" href="classlbcrypto_1_1PolyImpl.html#a0d6033450fc8e047de46cd6dfc5ad5ae">lbcrypto::PolyImpl&lt; BigVector &gt;</a>, and <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#aca7c97cd5997160bf1542c7310b66a01">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; BigVector &gt;, BigVector, NativeVector, PolyImpl &gt;</a>.</p>

</div>
</div>
<a id="aae3735eaf74bc0955519537441c098ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae3735eaf74bc0955519537441c098ba">&#9670;&nbsp;</a></span>PowersOfBase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element , typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;Element&gt; <a class="el" href="classlbcrypto_1_1ILElement.html">lbcrypto::ILElement</a>&lt; Element, VecType &gt;::PowersOfBase </td>
          <td>(</td>
          <td class="paramtype">usint&#160;</td>
          <td class="paramname"><em>baseBits</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate a vector of elements by raising the base element to successive powers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseBits</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a15120f3c80902a9a3e8fa080d23bd484">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a15120f3c80902a9a3e8fa080d23bd484">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; BigVector &gt;, BigVector, NativeVector, PolyImpl &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#af44c8da870103210cc33abb50446f44a">lbcrypto::DCRTPolyImpl&lt; VecType &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#af44c8da870103210cc33abb50446f44a">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a15120f3c80902a9a3e8fa080d23bd484">lbcrypto::DCRTPolyInterface&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;</a>, <a class="el" href="classlbcrypto_1_1PolyImpl.html#a18631b8955b51c44581c05d0a93ac51f">lbcrypto::PolyImpl&lt; VecType &gt;</a>, <a class="el" href="classlbcrypto_1_1PolyImpl.html#a18631b8955b51c44581c05d0a93ac51f">lbcrypto::PolyImpl&lt; NativeVector &gt;</a>, and <a class="el" href="classlbcrypto_1_1PolyImpl.html#a18631b8955b51c44581c05d0a93ac51f">lbcrypto::PolyImpl&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="a4e39b2a1a1ef24df9de8974acad76c43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e39b2a1a1ef24df9de8974acad76c43">&#9670;&nbsp;</a></span>SetFormat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element , typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlbcrypto_1_1ILElement.html">lbcrypto::ILElement</a>&lt; Element, VecType &gt;::SetFormat </td>
          <td>(</td>
          <td class="paramtype">const Format&#160;</td>
          <td class="paramname"><em>format</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the format/representation of the element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>the format/representation to set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a58eafec82f5f68c4e9efcf37324c0d03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58eafec82f5f68c4e9efcf37324c0d03">&#9670;&nbsp;</a></span>SwitchModulus()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element , typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classlbcrypto_1_1ILElement.html">lbcrypto::ILElement</a>&lt; Element, VecType &gt;::SwitchModulus </td>
          <td>(</td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>modulus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>rootOfUnity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>modulusArb</em> = <code>IntType::ZERO</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>rootOfUnityArb</em> = <code>IntType::ZERO</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Switch modulus and adjust the values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;modulus</td><td>is the modulus to be set. </td></tr>
    <tr><td class="paramname">&amp;rootOfUnity</td><td>is the corresponding root of unity for the modulus </td></tr>
    <tr><td class="paramname">&amp;modulusArb</td><td>is the modulus used for arbitrary cyclotomics CRT </td></tr>
    <tr><td class="paramname">&amp;rootOfUnityArb</td><td>is the corresponding root of unity for the modulus ASSUMPTION: This method assumes that the caller provides the correct rootOfUnity for the modulus. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a5760813c7513606ea0cf28015639297e">lbcrypto::DCRTPolyImpl&lt; VecType &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a5760813c7513606ea0cf28015639297e">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>, <a class="el" href="classlbcrypto_1_1PolyImpl.html#a3cf4e4e0162973442df60b10dd3aed81">lbcrypto::PolyImpl&lt; VecType &gt;</a>, <a class="el" href="classlbcrypto_1_1PolyImpl.html#a3cf4e4e0162973442df60b10dd3aed81">lbcrypto::PolyImpl&lt; NativeVector &gt;</a>, <a class="el" href="classlbcrypto_1_1PolyImpl.html#a3cf4e4e0162973442df60b10dd3aed81">lbcrypto::PolyImpl&lt; BigVector &gt;</a>, and <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a0c38037e64d065fd8240883700f25764">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; BigVector &gt;, BigVector, NativeVector, PolyImpl &gt;</a>.</p>

</div>
</div>
<a id="a34e8992842f28638c8d4eff26d0fc584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34e8992842f28638c8d4eff26d0fc584">&#9670;&nbsp;</a></span>Times() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element , typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Element <a class="el" href="classlbcrypto_1_1ILElement.html">lbcrypto::ILElement</a>&lt; Element, VecType &gt;::Times </td>
          <td>(</td>
          <td class="paramtype">bigintnat::NativeInteger::SignedNativeInt&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scalar multiplication - mulltiply by a signed integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;element</td><td>is the element to multiply entry-wise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the return value of the times operation. </dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#acee8bc36b405189c3be42b0ef2417625">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#acee8bc36b405189c3be42b0ef2417625">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; BigVector &gt;, BigVector, NativeVector, PolyImpl &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a187ab86229c1ecc9f372fd76886426eb">lbcrypto::DCRTPolyImpl&lt; VecType &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a187ab86229c1ecc9f372fd76886426eb">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#acee8bc36b405189c3be42b0ef2417625">lbcrypto::DCRTPolyInterface&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;</a>, <a class="el" href="classlbcrypto_1_1PolyImpl.html#afc9f778330e78797f0b0d26928b7363a">lbcrypto::PolyImpl&lt; VecType &gt;</a>, <a class="el" href="classlbcrypto_1_1PolyImpl.html#afc9f778330e78797f0b0d26928b7363a">lbcrypto::PolyImpl&lt; NativeVector &gt;</a>, and <a class="el" href="classlbcrypto_1_1PolyImpl.html#afc9f778330e78797f0b0d26928b7363a">lbcrypto::PolyImpl&lt; BigVector &gt;</a>.</p>

</div>
</div>
<a id="a87aae40f4589b2e10285495cfda2b492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87aae40f4589b2e10285495cfda2b492">&#9670;&nbsp;</a></span>Times() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element , typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Element <a class="el" href="classlbcrypto_1_1ILElement.html">lbcrypto::ILElement</a>&lt; Element, VecType &gt;::Times </td>
          <td>(</td>
          <td class="paramtype">const Element &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a multiplication operation and returns the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;element</td><td>is the element to multiply with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the result of the multiplication. </dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1PolyImpl.html#a20f71c0bf798fcc7771f3a775259eb71">lbcrypto::PolyImpl&lt; VecType &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a12e87746e6b870e0e23c7196cd0d6e1d">lbcrypto::DCRTPolyInterface&lt; DerivedType, BigVecType, LilVecType, RNSContainerType &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a90ee91a0f67930426467c8287b86f476">lbcrypto::DCRTPolyImpl&lt; VecType &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a12e87746e6b870e0e23c7196cd0d6e1d">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>, and <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a12e87746e6b870e0e23c7196cd0d6e1d">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; BigVector &gt;, BigVector, NativeVector, PolyImpl &gt;</a>.</p>

</div>
</div>
<a id="ace67acbcf4ed67ce68a02e1565159af4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace67acbcf4ed67ce68a02e1565159af4">&#9670;&nbsp;</a></span>Times() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element , typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Element <a class="el" href="classlbcrypto_1_1ILElement.html">lbcrypto::ILElement</a>&lt; Element, VecType &gt;::Times </td>
          <td>(</td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scalar multiplication - multiply all entries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;element</td><td>is the element to multiply entry-wise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is the return value of the times operation. </dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a90ef011a1f427c25add508227dcdda34">lbcrypto::DCRTPolyImpl&lt; VecType &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a90ef011a1f427c25add508227dcdda34">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>, <a class="el" href="classlbcrypto_1_1PolyImpl.html#ab08dd2824bc3f8c005acab8c506420fd">lbcrypto::PolyImpl&lt; VecType &gt;</a>, <a class="el" href="classlbcrypto_1_1PolyImpl.html#ab08dd2824bc3f8c005acab8c506420fd">lbcrypto::PolyImpl&lt; NativeVector &gt;</a>, <a class="el" href="classlbcrypto_1_1PolyImpl.html#ab08dd2824bc3f8c005acab8c506420fd">lbcrypto::PolyImpl&lt; BigVector &gt;</a>, and <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#abe20fce440768599da3a2edeb27ced9f">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; BigVector &gt;, BigVector, NativeVector, PolyImpl &gt;</a>.</p>

</div>
</div>
<a id="a9d781be3bbb1386494f2f60ef4c93927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d781be3bbb1386494f2f60ef4c93927">&#9670;&nbsp;</a></span>Transpose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element , typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Element <a class="el" href="classlbcrypto_1_1ILElement.html">lbcrypto::ILElement</a>&lt; Element, VecType &gt;::Transpose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transpose the ring element using the automorphism operation. </p>
<dl class="section return"><dt>Returns</dt><dd>is the result of the transposition. </dd></dl>

<p>Implemented in <a class="el" href="classlbcrypto_1_1DCRTPolyImpl.html#a35d2fdfaa1eafe1f0f42e380e5356afd">lbcrypto::DCRTPolyImpl&lt; BigVector &gt;</a>, <a class="el" href="classlbcrypto_1_1PolyImpl.html#a581cd4504bdea20247d2ed4275a55385">lbcrypto::PolyImpl&lt; NativeVector &gt;</a>, <a class="el" href="classlbcrypto_1_1PolyImpl.html#a581cd4504bdea20247d2ed4275a55385">lbcrypto::PolyImpl&lt; BigVector &gt;</a>, <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a77fa4c8b73acda9b59dc034519d592db">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; VecType &gt;, VecType, NativeVector, PolyImpl &gt;</a>, and <a class="el" href="classlbcrypto_1_1DCRTPolyInterface.html#a77fa4c8b73acda9b59dc034519d592db">lbcrypto::DCRTPolyInterface&lt; DCRTPolyImpl&lt; BigVector &gt;, BigVector, NativeVector, PolyImpl &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/core/include/lattice/<a class="el" href="ilelement_8h_source.html">ilelement.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jan 19 2022 20:29:34 for PALISADE Lattice Crypto Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
