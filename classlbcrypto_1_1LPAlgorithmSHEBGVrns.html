<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PALISADE Lattice Crypto Library: lbcrypto::LPAlgorithmSHEBGVrns&lt; Element &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PALISADE Lattice Crypto Library
   &#160;<span id="projectnumber">1.11.5</span>
   </div>
   <div id="projectbrief">A lattice crypto library for software engineers by software engineers.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelbcrypto.html">lbcrypto</a></li><li class="navelem"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html">LPAlgorithmSHEBGVrns</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classlbcrypto_1_1LPAlgorithmSHEBGVrns-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">lbcrypto::LPAlgorithmSHEBGVrns&lt; Element &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="bgvrns_8h_source.html">bgvrns.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for lbcrypto::LPAlgorithmSHEBGVrns&lt; Element &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classlbcrypto_1_1LPAlgorithmSHEBGVrns__inherit__graph.png" border="0" usemap="#lbcrypto_1_1LPAlgorithmSHEBGVrns_3_01Element_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="lbcrypto_1_1LPAlgorithmSHEBGVrns_3_01Element_01_4_inherit__map" id="lbcrypto_1_1LPAlgorithmSHEBGVrns_3_01Element_01_4_inherit__map">
<area shape="rect" title=" " alt="" coords="5,95,240,136"/>
<area shape="rect" href="classlbcrypto_1_1LPSHEAlgorithm.html" title="Abstract interface class for LBC SHE algorithms." alt="" coords="29,5,217,47"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for lbcrypto::LPAlgorithmSHEBGVrns&lt; Element &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classlbcrypto_1_1LPAlgorithmSHEBGVrns__coll__graph.png" border="0" usemap="#lbcrypto_1_1LPAlgorithmSHEBGVrns_3_01Element_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="lbcrypto_1_1LPAlgorithmSHEBGVrns_3_01Element_01_4_coll__map" id="lbcrypto_1_1LPAlgorithmSHEBGVrns_3_01Element_01_4_coll__map">
<area shape="rect" title=" " alt="" coords="5,95,240,136"/>
<area shape="rect" href="classlbcrypto_1_1LPSHEAlgorithm.html" title="Abstract interface class for LBC SHE algorithms." alt="" coords="29,5,217,47"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a656217d76fa4f932078699581552d308"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html#a656217d76fa4f932078699581552d308">LPAlgorithmSHEBGVrns</a> ()</td></tr>
<tr class="separator:a656217d76fa4f932078699581552d308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e523a1a3a4b80ec407627a5021fc4e"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html#ac0e523a1a3a4b80ec407627a5021fc4e">~LPAlgorithmSHEBGVrns</a> ()</td></tr>
<tr class="separator:ac0e523a1a3a4b80ec407627a5021fc4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2089b66add5dca746866fdbf1c05033"><td class="memItemLeft" align="right" valign="top">vector&lt; shared_ptr&lt; ConstCiphertext&lt; Element &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html#ab2089b66add5dca746866fdbf1c05033">AdjustLevels</a> (ConstCiphertext&lt; Element &gt; ciphertext1, ConstCiphertext&lt; Element &gt; ciphertext2) const</td></tr>
<tr class="separator:ab2089b66add5dca746866fdbf1c05033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7bf91898afeda8b339caf9aa3e416d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html#aa7bf91898afeda8b339caf9aa3e416d1">AdjustLevelsEq</a> (Ciphertext&lt; Element &gt; &amp;ciphertext1, Ciphertext&lt; Element &gt; &amp;ciphertext2) const</td></tr>
<tr class="separator:aa7bf91898afeda8b339caf9aa3e416d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91e62a871a02eca0fe763a2108f853cf"><td class="memItemLeft" align="right" valign="top">std::pair&lt; shared_ptr&lt; ConstCiphertext&lt; Element &gt; &gt;, Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html#a91e62a871a02eca0fe763a2108f853cf">AdjustLevels</a> (ConstCiphertext&lt; Element &gt; ciphertext, ConstPlaintext plaintext) const</td></tr>
<tr class="separator:a91e62a871a02eca0fe763a2108f853cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a838800e0033a01879c0d8168f4ab52df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html#a838800e0033a01879c0d8168f4ab52df">AdjustLevelsEq</a> (Ciphertext&lt; Element &gt; &amp;ciphertext, Plaintext plaintext) const</td></tr>
<tr class="separator:a838800e0033a01879c0d8168f4ab52df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9306b26fa0ca0090291bb3bdf04d55fa"><td class="memItemLeft" align="right" valign="top">Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html#a9306b26fa0ca0090291bb3bdf04d55fa">EvalAddCore</a> (ConstCiphertext&lt; Element &gt; ciphertext1, ConstCiphertext&lt; Element &gt; ciphertext2) const</td></tr>
<tr class="separator:a9306b26fa0ca0090291bb3bdf04d55fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12982cd011bd39110ed2e5145b5873f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html#ad12982cd011bd39110ed2e5145b5873f">EvalAddCoreInPlace</a> (Ciphertext&lt; Element &gt; &amp;ciphertext1, ConstCiphertext&lt; Element &gt; ciphertext2) const</td></tr>
<tr class="separator:ad12982cd011bd39110ed2e5145b5873f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addc4789c52f052da41992969cc9aa77a"><td class="memItemLeft" align="right" valign="top">virtual Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html#addc4789c52f052da41992969cc9aa77a">EvalAddMutable</a> (Ciphertext&lt; Element &gt; &amp;ciphertext1, Ciphertext&lt; Element &gt; &amp;ciphertext2) const override</td></tr>
<tr class="separator:addc4789c52f052da41992969cc9aa77a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ab6b8779b8244160923d23b0c84630"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html#ac1ab6b8779b8244160923d23b0c84630">EvalAddInPlace</a> (Ciphertext&lt; Element &gt; &amp;ciphertext1, ConstCiphertext&lt; Element &gt; ciphertext2) const override</td></tr>
<tr class="separator:ac1ab6b8779b8244160923d23b0c84630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b506bce3c365cb4e445211b73aae51"><td class="memItemLeft" align="right" valign="top">Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html#a20b506bce3c365cb4e445211b73aae51">EvalAddCore</a> (ConstCiphertext&lt; Element &gt; ciphertext, Element ptElement) const</td></tr>
<tr class="separator:a20b506bce3c365cb4e445211b73aae51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5395cfef391f93f9ff3c827144510b96"><td class="memItemLeft" align="right" valign="top">Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html#a5395cfef391f93f9ff3c827144510b96">EvalAdd</a> (ConstCiphertext&lt; Element &gt; ciphertext, ConstPlaintext plaintext) const override</td></tr>
<tr class="separator:a5395cfef391f93f9ff3c827144510b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d007dfccd3a205cf4ea580710c7279"><td class="memItemLeft" align="right" valign="top">virtual Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html#aa6d007dfccd3a205cf4ea580710c7279">EvalAddMutable</a> (Ciphertext&lt; Element &gt; &amp;ciphertext, Plaintext plaintext) const override</td></tr>
<tr class="separator:aa6d007dfccd3a205cf4ea580710c7279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a701de6460ada896913839f27a7ac9ccd"><td class="memItemLeft" align="right" valign="top">virtual Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html#a701de6460ada896913839f27a7ac9ccd">EvalLinearWSum</a> (vector&lt; Ciphertext&lt; Element &gt;&gt; ciphertexts, vector&lt; double &gt; constants) const override</td></tr>
<tr class="separator:a701de6460ada896913839f27a7ac9ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76f85a21e0c8f105dd680e4b115eeba9"><td class="memItemLeft" align="right" valign="top">virtual Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html#a76f85a21e0c8f105dd680e4b115eeba9">EvalLinearWSumMutable</a> (vector&lt; Ciphertext&lt; Element &gt;&gt; ciphertexts, vector&lt; double &gt; constants) const override</td></tr>
<tr class="separator:a76f85a21e0c8f105dd680e4b115eeba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16a101c441c448fb8791efc2303624da"><td class="memItemLeft" align="right" valign="top">Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html#a16a101c441c448fb8791efc2303624da">EvalSubCore</a> (ConstCiphertext&lt; Element &gt; ciphertext1, ConstCiphertext&lt; Element &gt; ciphertext2) const</td></tr>
<tr class="separator:a16a101c441c448fb8791efc2303624da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd25a3fc7474bfd18a004229ab94ee9b"><td class="memItemLeft" align="right" valign="top">Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html#afd25a3fc7474bfd18a004229ab94ee9b">EvalSub</a> (ConstCiphertext&lt; Element &gt; ciphertext1, ConstCiphertext&lt; Element &gt; ciphertext2) const override</td></tr>
<tr class="separator:afd25a3fc7474bfd18a004229ab94ee9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b75737f8d3eef816005c4b44b413a0"><td class="memItemLeft" align="right" valign="top">virtual Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html#aa3b75737f8d3eef816005c4b44b413a0">EvalSubMutable</a> (Ciphertext&lt; Element &gt; &amp;ciphertext1, Ciphertext&lt; Element &gt; &amp;ciphertext2) const override</td></tr>
<tr class="separator:aa3b75737f8d3eef816005c4b44b413a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a433d6b463e15e37d04bda3b360e91"><td class="memItemLeft" align="right" valign="top">Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html#ab8a433d6b463e15e37d04bda3b360e91">EvalSubCore</a> (ConstCiphertext&lt; Element &gt; ciphertext, Element ptElement) const</td></tr>
<tr class="separator:ab8a433d6b463e15e37d04bda3b360e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33c2f6e788537907b5f7b24ce572b201"><td class="memItemLeft" align="right" valign="top">Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html#a33c2f6e788537907b5f7b24ce572b201">EvalSub</a> (ConstCiphertext&lt; Element &gt; ciphertext1, ConstPlaintext plaintext) const override</td></tr>
<tr class="separator:a33c2f6e788537907b5f7b24ce572b201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff359d4e8a638f1d4e80b4a76f6673db"><td class="memItemLeft" align="right" valign="top">virtual Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html#aff359d4e8a638f1d4e80b4a76f6673db">EvalSubMutable</a> (Ciphertext&lt; Element &gt; &amp;ciphertext1, Plaintext plaintext) const override</td></tr>
<tr class="separator:aff359d4e8a638f1d4e80b4a76f6673db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affbbaee3aa18e3b7c42e7a2cb612d6bf"><td class="memItemLeft" align="right" valign="top">Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html#affbbaee3aa18e3b7c42e7a2cb612d6bf">EvalMultCore</a> (ConstCiphertext&lt; Element &gt; ciphertext1, ConstCiphertext&lt; Element &gt; ciphertext2) const</td></tr>
<tr class="separator:affbbaee3aa18e3b7c42e7a2cb612d6bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9948b43493d58a83fdd55671fe1c4ab"><td class="memItemLeft" align="right" valign="top">Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html#ad9948b43493d58a83fdd55671fe1c4ab">EvalMult</a> (ConstCiphertext&lt; Element &gt; ciphertext1, ConstCiphertext&lt; Element &gt; ciphertext2) const override</td></tr>
<tr class="separator:ad9948b43493d58a83fdd55671fe1c4ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f10dfa807c693f949b848902a824b2"><td class="memItemLeft" align="right" valign="top">virtual Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html#ac6f10dfa807c693f949b848902a824b2">EvalMultMutable</a> (Ciphertext&lt; Element &gt; &amp;ciphertext1, Ciphertext&lt; Element &gt; &amp;ciphertext2) const override</td></tr>
<tr class="separator:ac6f10dfa807c693f949b848902a824b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a325a67b17980770194ad684a70bcc066"><td class="memItemLeft" align="right" valign="top">Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html#a325a67b17980770194ad684a70bcc066">EvalMultCore</a> (ConstCiphertext&lt; Element &gt; ciphertext, Element ptxt) const</td></tr>
<tr class="separator:a325a67b17980770194ad684a70bcc066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee5b063ab50bb3bc6ab86c7c2ba89739"><td class="memItemLeft" align="right" valign="top">Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html#aee5b063ab50bb3bc6ab86c7c2ba89739">EvalMult</a> (ConstCiphertext&lt; Element &gt; ciphertext, ConstPlaintext plaintext) const override</td></tr>
<tr class="separator:aee5b063ab50bb3bc6ab86c7c2ba89739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae69d36b7fe817e1a3803c79a6aca0c55"><td class="memItemLeft" align="right" valign="top">virtual Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html#ae69d36b7fe817e1a3803c79a6aca0c55">EvalMultMutable</a> (Ciphertext&lt; Element &gt; &amp;ciphertext, Plaintext plaintext) const override</td></tr>
<tr class="separator:ae69d36b7fe817e1a3803c79a6aca0c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad052e2e8a27e722a1d98c9889f38e90b"><td class="memItemLeft" align="right" valign="top">Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html#ad052e2e8a27e722a1d98c9889f38e90b">EvalMult</a> (ConstCiphertext&lt; Element &gt; ciphertext1, ConstCiphertext&lt; Element &gt; ciphertext2, const LPEvalKey&lt; Element &gt; ek) const override</td></tr>
<tr class="separator:ad052e2e8a27e722a1d98c9889f38e90b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f531a799de265a7da503faf6e53b1d"><td class="memItemLeft" align="right" valign="top">Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html#ac5f531a799de265a7da503faf6e53b1d">EvalMultMutable</a> (Ciphertext&lt; Element &gt; &amp;ciphertext1, Ciphertext&lt; Element &gt; &amp;ciphertext2, const LPEvalKey&lt; Element &gt; ek) const override</td></tr>
<tr class="separator:ac5f531a799de265a7da503faf6e53b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb3899ae0ee1c59def38bb98ef2f41ec"><td class="memItemLeft" align="right" valign="top">Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html#acb3899ae0ee1c59def38bb98ef2f41ec">EvalMultAndRelinearize</a> (ConstCiphertext&lt; Element &gt; ciphertext1, ConstCiphertext&lt; Element &gt; ciphertext2, const vector&lt; LPEvalKey&lt; Element &gt;&gt; &amp;ek) const override</td></tr>
<tr class="separator:acb3899ae0ee1c59def38bb98ef2f41ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae752b1b569ee7e320ec74882e6524864"><td class="memItemLeft" align="right" valign="top">Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html#ae752b1b569ee7e320ec74882e6524864">Relinearize</a> (ConstCiphertext&lt; Element &gt; ciphertext, const vector&lt; LPEvalKey&lt; Element &gt;&gt; &amp;ek) const override</td></tr>
<tr class="separator:ae752b1b569ee7e320ec74882e6524864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5da404412186e933e8c9f99810a8feb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html#ae5da404412186e933e8c9f99810a8feb">RelinearizeInPlace</a> (Ciphertext&lt; Element &gt; &amp;ciphertext, const vector&lt; LPEvalKey&lt; Element &gt;&gt; &amp;ek) const override</td></tr>
<tr class="separator:ae5da404412186e933e8c9f99810a8feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0f9c925b6dcad41274b41caa115f3a5"><td class="memItemLeft" align="right" valign="top">Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html#aa0f9c925b6dcad41274b41caa115f3a5">EvalNegate</a> (ConstCiphertext&lt; Element &gt; ct) const override</td></tr>
<tr class="separator:aa0f9c925b6dcad41274b41caa115f3a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae752d203d94dea87f89c7e4900a4b7df"><td class="memItemLeft" align="right" valign="top">LPEvalKey&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html#ae752d203d94dea87f89c7e4900a4b7df">KeySwitchHybridGen</a> (const LPPrivateKey&lt; Element &gt; oldKey, const LPPrivateKey&lt; Element &gt; newKey, const LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ek=nullptr) const</td></tr>
<tr class="separator:ae752d203d94dea87f89c7e4900a4b7df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1da2a453ba4b06945bfd07493d8d6efa"><td class="memItemLeft" align="right" valign="top"><a id="a1da2a453ba4b06945bfd07493d8d6efa"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>KeySwitchHybridInPlace</b> (const LPEvalKey&lt; Element &gt; keySwitchHint, Ciphertext&lt; Element &gt; &amp;ciphertext) const</td></tr>
<tr class="separator:a1da2a453ba4b06945bfd07493d8d6efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b279e3e48046654fb5289ebd03e6e92"><td class="memItemLeft" align="right" valign="top">LPEvalKey&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html#a5b279e3e48046654fb5289ebd03e6e92">KeySwitchGHSGen</a> (const LPPrivateKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; oldKey, const LPPrivateKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; newKey, const LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ek=nullptr) const</td></tr>
<tr class="separator:a5b279e3e48046654fb5289ebd03e6e92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ea0ce01e86a1b4977876929aa1d097f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html#a1ea0ce01e86a1b4977876929aa1d097f">KeySwitchGHSInPlace</a> (const LPEvalKey&lt; Element &gt; keySwitchHint, Ciphertext&lt; Element &gt; &amp;ciphertext) const</td></tr>
<tr class="separator:a1ea0ce01e86a1b4977876929aa1d097f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e3300c56c89fb406283b8177bf6ad8"><td class="memItemLeft" align="right" valign="top">LPEvalKey&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html#a06e3300c56c89fb406283b8177bf6ad8">KeySwitchBVGen</a> (const LPPrivateKey&lt; Element &gt; oldKey, const LPPrivateKey&lt; Element &gt; newKey, const LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ek=nullptr) const</td></tr>
<tr class="separator:a06e3300c56c89fb406283b8177bf6ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89e95f498f1ce65e6769210a466cbbf1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html#a89e95f498f1ce65e6769210a466cbbf1">KeySwitchBVInPlace</a> (const LPEvalKey&lt; Element &gt; keySwitchHint, Ciphertext&lt; Element &gt; &amp;ciphertext) const</td></tr>
<tr class="separator:a89e95f498f1ce65e6769210a466cbbf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a577d9cfed0596e5ab0b42bbc939c4372"><td class="memItemLeft" align="right" valign="top">virtual LPEvalKey&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html#a577d9cfed0596e5ab0b42bbc939c4372">KeySwitchGen</a> (const LPPrivateKey&lt; Element &gt; oldKey, const LPPrivateKey&lt; Element &gt; newKey) const override</td></tr>
<tr class="separator:a577d9cfed0596e5ab0b42bbc939c4372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c101e026ddb531cb7079194fb8fae96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html#a2c101e026ddb531cb7079194fb8fae96">KeySwitchInPlace</a> (const LPEvalKey&lt; Element &gt; keySwitchHint, Ciphertext&lt; Element &gt; &amp;ciphertext) const override</td></tr>
<tr class="separator:a2c101e026ddb531cb7079194fb8fae96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d6ad52a218926c115395d086ec4dc50"><td class="memItemLeft" align="right" valign="top">LPEvalKey&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html#a5d6ad52a218926c115395d086ec4dc50">EvalMultKeyGen</a> (const LPPrivateKey&lt; Element &gt; privateKey) const override</td></tr>
<tr class="separator:a5d6ad52a218926c115395d086ec4dc50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88293351fc571b9d3aa00aac630335a9"><td class="memItemLeft" align="right" valign="top">vector&lt; LPEvalKey&lt; Element &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html#a88293351fc571b9d3aa00aac630335a9">EvalMultKeysGen</a> (const LPPrivateKey&lt; Element &gt; privateKey) const override</td></tr>
<tr class="separator:a88293351fc571b9d3aa00aac630335a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cdacc9e278c988020ac6d4c485c46bb"><td class="memItemLeft" align="right" valign="top">Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html#a4cdacc9e278c988020ac6d4c485c46bb">EvalAutomorphism</a> (ConstCiphertext&lt; Element &gt; ciphertext, usint i, const std::map&lt; usint, LPEvalKey&lt; Element &gt;&gt; &amp;evalKeys, CALLER_INFO_ARGS_HDR) const override</td></tr>
<tr class="separator:a4cdacc9e278c988020ac6d4c485c46bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3c3c25ad5ebe968dc002abc3b174170"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; std::map&lt; usint, LPEvalKey&lt; Element &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html#ad3c3c25ad5ebe968dc002abc3b174170">EvalAutomorphismKeyGen</a> (const LPPrivateKey&lt; Element &gt; privateKey, const std::vector&lt; usint &gt; &amp;indexList) const override</td></tr>
<tr class="separator:ad3c3c25ad5ebe968dc002abc3b174170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe05cd8df5cf7d8051334f3102e43cd"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; std::map&lt; usint, LPEvalKey&lt; Element &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html#abfe05cd8df5cf7d8051334f3102e43cd">EvalAutomorphismKeyGen</a> (const LPPublicKey&lt; Element &gt; publicKey, const LPPrivateKey&lt; Element &gt; privateKey, const std::vector&lt; usint &gt; &amp;indexList) const override</td></tr>
<tr class="separator:abfe05cd8df5cf7d8051334f3102e43cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb9d3d6c626d3c3ab163b4847ecb5a3c"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; vector&lt; Element &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html#abb9d3d6c626d3c3ab163b4847ecb5a3c">EvalFastRotationPrecompute</a> (ConstCiphertext&lt; Element &gt; ciphertext) const override</td></tr>
<tr class="separator:abb9d3d6c626d3c3ab163b4847ecb5a3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa08487f40c840c2169b7846a0a6b13e6"><td class="memItemLeft" align="right" valign="top">Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html#aa08487f40c840c2169b7846a0a6b13e6">EvalFastRotation</a> (ConstCiphertext&lt; Element &gt; ciphertext, const usint index, const usint m, const shared_ptr&lt; vector&lt; Element &gt;&gt; precomp) const override</td></tr>
<tr class="separator:aa08487f40c840c2169b7846a0a6b13e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19007dcaf0a7c0b447423c5e8188dc5a"><td class="memTemplParams" colspan="2"><a id="a19007dcaf0a7c0b447423c5e8188dc5a"></a>
template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a19007dcaf0a7c0b447423c5e8188dc5a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>save</b> (Archive &amp;ar) const</td></tr>
<tr class="separator:a19007dcaf0a7c0b447423c5e8188dc5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30dce05de5e07f5ccc668c29dfb01f38"><td class="memTemplParams" colspan="2"><a id="a30dce05de5e07f5ccc668c29dfb01f38"></a>
template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a30dce05de5e07f5ccc668c29dfb01f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>load</b> (Archive &amp;ar)</td></tr>
<tr class="separator:a30dce05de5e07f5ccc668c29dfb01f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd5001a7aac0224522c785ee5219f42"><td class="memItemLeft" align="right" valign="top"><a id="a9bd5001a7aac0224522c785ee5219f42"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>SerializedObjectName</b> () const</td></tr>
<tr class="separator:a9bd5001a7aac0224522c785ee5219f42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e1a8013298d5ed07fa481c1cc07eae3"><td class="memItemLeft" align="right" valign="top"><a id="a7e1a8013298d5ed07fa481c1cc07eae3"></a>
LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">Poly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>KeySwitchBVGen</b> (const LPPrivateKey&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">Poly</a> &gt; oldKey, const LPPrivateKey&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">Poly</a> &gt; newKey, const LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ek) const</td></tr>
<tr class="separator:a7e1a8013298d5ed07fa481c1cc07eae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ac13e919acda772a11c27c824ec1ea9"><td class="memItemLeft" align="right" valign="top"><a id="a3ac13e919acda772a11c27c824ec1ea9"></a>
LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">NativePoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>KeySwitchBVGen</b> (const LPPrivateKey&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">NativePoly</a> &gt; oldKey, const LPPrivateKey&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">NativePoly</a> &gt; newKey, const LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ek) const</td></tr>
<tr class="separator:a3ac13e919acda772a11c27c824ec1ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ab81c5c6973eaa73071027744f02244"><td class="memItemLeft" align="right" valign="top"><a id="a6ab81c5c6973eaa73071027744f02244"></a>
LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>KeySwitchBVGen</b> (const LPPrivateKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; oldKey, const LPPrivateKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; newKey, const LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ekPrev) const</td></tr>
<tr class="separator:a6ab81c5c6973eaa73071027744f02244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e2e706e6a31739cb7fbf6edd30ea754"><td class="memItemLeft" align="right" valign="top"><a id="a3e2e706e6a31739cb7fbf6edd30ea754"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>KeySwitchBVInPlace</b> (const LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">Poly</a> &gt; ek, Ciphertext&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">Poly</a> &gt; &amp;ciphertext) const</td></tr>
<tr class="separator:a3e2e706e6a31739cb7fbf6edd30ea754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ff8c6f041f37164de2eca3cc025107"><td class="memItemLeft" align="right" valign="top"><a id="ad4ff8c6f041f37164de2eca3cc025107"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>KeySwitchBVInPlace</b> (const LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">NativePoly</a> &gt; ek, Ciphertext&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">NativePoly</a> &gt; &amp;ciphertext) const</td></tr>
<tr class="separator:ad4ff8c6f041f37164de2eca3cc025107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7889cc044ecff54c6d66750d2cfc1692"><td class="memItemLeft" align="right" valign="top"><a id="a7889cc044ecff54c6d66750d2cfc1692"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>KeySwitchBVInPlace</b> (const LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ek, Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; &amp;ciphertext) const</td></tr>
<tr class="separator:a7889cc044ecff54c6d66750d2cfc1692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0204b3a63d14897a84ad55af6637776c"><td class="memItemLeft" align="right" valign="top"><a id="a0204b3a63d14897a84ad55af6637776c"></a>
LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">Poly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>KeySwitchGHSGen</b> (const LPPrivateKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; oldKey, const LPPrivateKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; newKey, const LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ekPrev) const</td></tr>
<tr class="separator:a0204b3a63d14897a84ad55af6637776c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23db4dc9aa1e883e2daf40a2a3f09564"><td class="memItemLeft" align="right" valign="top"><a id="a23db4dc9aa1e883e2daf40a2a3f09564"></a>
LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">NativePoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>KeySwitchGHSGen</b> (const LPPrivateKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; oldKey, const LPPrivateKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; newKey, const LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ekPrev) const</td></tr>
<tr class="separator:a23db4dc9aa1e883e2daf40a2a3f09564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a146d58616970b680a086f8f05cdfe7f5"><td class="memItemLeft" align="right" valign="top"><a id="a146d58616970b680a086f8f05cdfe7f5"></a>
LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>KeySwitchGHSGen</b> (const LPPrivateKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; oldKey, const LPPrivateKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; newKey, const LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ekPrev) const</td></tr>
<tr class="separator:a146d58616970b680a086f8f05cdfe7f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8976b90fe21311972a061bb60990792"><td class="memItemLeft" align="right" valign="top"><a id="ac8976b90fe21311972a061bb60990792"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>KeySwitchGHSInPlace</b> (const LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">Poly</a> &gt; ek, Ciphertext&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">Poly</a> &gt; &amp;ciphertext) const</td></tr>
<tr class="separator:ac8976b90fe21311972a061bb60990792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d307cc0bfa910bb946761185c4afd49"><td class="memItemLeft" align="right" valign="top"><a id="a2d307cc0bfa910bb946761185c4afd49"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>KeySwitchGHSInPlace</b> (const LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">NativePoly</a> &gt; ek, Ciphertext&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">NativePoly</a> &gt; &amp;ciphertext) const</td></tr>
<tr class="separator:a2d307cc0bfa910bb946761185c4afd49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0940fc0a5e94d65f96a387cac4020e8d"><td class="memItemLeft" align="right" valign="top"><a id="a0940fc0a5e94d65f96a387cac4020e8d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>KeySwitchGHSInPlace</b> (const LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ek, Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; &amp;ciphertext) const</td></tr>
<tr class="separator:a0940fc0a5e94d65f96a387cac4020e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2430b56771255691ad7a80aced2423e6"><td class="memItemLeft" align="right" valign="top"><a id="a2430b56771255691ad7a80aced2423e6"></a>
LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">Poly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>KeySwitchHybridGen</b> (const LPPrivateKey&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">Poly</a> &gt; oldKey, const LPPrivateKey&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">Poly</a> &gt; newKey, const LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ekPrev) const</td></tr>
<tr class="separator:a2430b56771255691ad7a80aced2423e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e3e15fea7846a9f8517d013e8738ddf"><td class="memItemLeft" align="right" valign="top"><a id="a1e3e15fea7846a9f8517d013e8738ddf"></a>
LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">NativePoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>KeySwitchHybridGen</b> (const LPPrivateKey&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">NativePoly</a> &gt; oldKey, const LPPrivateKey&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">NativePoly</a> &gt; newKey, const LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ekPrev) const</td></tr>
<tr class="separator:a1e3e15fea7846a9f8517d013e8738ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a650b8b78339a7ff5e35525621faedc91"><td class="memItemLeft" align="right" valign="top"><a id="a650b8b78339a7ff5e35525621faedc91"></a>
LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>KeySwitchHybridGen</b> (const LPPrivateKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; oldKey, const LPPrivateKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; newKey, const LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ekPrev) const</td></tr>
<tr class="separator:a650b8b78339a7ff5e35525621faedc91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a173120f57eaf75188dab0429a6ef324a"><td class="memItemLeft" align="right" valign="top"><a id="a173120f57eaf75188dab0429a6ef324a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>KeySwitchHybridInPlace</b> (const LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">Poly</a> &gt; ek, Ciphertext&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">Poly</a> &gt; &amp;ciphertext) const</td></tr>
<tr class="separator:a173120f57eaf75188dab0429a6ef324a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b4b6ee010ca3d5aa01f816582c269a9"><td class="memItemLeft" align="right" valign="top"><a id="a9b4b6ee010ca3d5aa01f816582c269a9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>KeySwitchHybridInPlace</b> (const LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">NativePoly</a> &gt; ek, Ciphertext&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">NativePoly</a> &gt; &amp;ciphertext) const</td></tr>
<tr class="separator:a9b4b6ee010ca3d5aa01f816582c269a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8d638d7a27861b096670ae119e9cff4"><td class="memItemLeft" align="right" valign="top"><a id="ae8d638d7a27861b096670ae119e9cff4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>KeySwitchHybridInPlace</b> (const LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ek, Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; &amp;ciphertext) const</td></tr>
<tr class="separator:ae8d638d7a27861b096670ae119e9cff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace469b0aa6dd76745e738363027c96de"><td class="memItemLeft" align="right" valign="top"><a id="ace469b0aa6dd76745e738363027c96de"></a>
LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">Poly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>KeySwitchGen</b> (const LPPrivateKey&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">Poly</a> &gt; oldKey, const LPPrivateKey&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">Poly</a> &gt; newKey) const</td></tr>
<tr class="separator:ace469b0aa6dd76745e738363027c96de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00bc283b5122a4a57d519e021163753f"><td class="memItemLeft" align="right" valign="top"><a id="a00bc283b5122a4a57d519e021163753f"></a>
LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">NativePoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>KeySwitchGen</b> (const LPPrivateKey&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">NativePoly</a> &gt; oldKey, const LPPrivateKey&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">NativePoly</a> &gt; newKey) const</td></tr>
<tr class="separator:a00bc283b5122a4a57d519e021163753f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7d2d9f278fb49faf758cd324aec4504"><td class="memItemLeft" align="right" valign="top"><a id="ae7d2d9f278fb49faf758cd324aec4504"></a>
LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>KeySwitchGen</b> (const LPPrivateKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; oldKey, const LPPrivateKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; newKey) const</td></tr>
<tr class="separator:ae7d2d9f278fb49faf758cd324aec4504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66c6bf081cbff9c7830a74c5dadc0a67"><td class="memItemLeft" align="right" valign="top"><a id="a66c6bf081cbff9c7830a74c5dadc0a67"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>KeySwitchInPlace</b> (const LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">Poly</a> &gt; ek, Ciphertext&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">Poly</a> &gt; &amp;ciphertext) const</td></tr>
<tr class="separator:a66c6bf081cbff9c7830a74c5dadc0a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02a63d301989dff4c386c68bf776d00c"><td class="memItemLeft" align="right" valign="top"><a id="a02a63d301989dff4c386c68bf776d00c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>KeySwitchInPlace</b> (const LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">NativePoly</a> &gt; ek, Ciphertext&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">NativePoly</a> &gt; &amp;ciphertext) const</td></tr>
<tr class="separator:a02a63d301989dff4c386c68bf776d00c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c829f193d63593d651b8f93690bca96"><td class="memItemLeft" align="right" valign="top"><a id="a1c829f193d63593d651b8f93690bca96"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>KeySwitchInPlace</b> (const LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ek, Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; &amp;ciphertext) const</td></tr>
<tr class="separator:a1c829f193d63593d651b8f93690bca96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2e820dd4dfc7859231ea459be30bae5"><td class="memItemLeft" align="right" valign="top"><a id="ae2e820dd4dfc7859231ea459be30bae5"></a>
vector&lt; shared_ptr&lt; ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>AdjustLevels</b> (ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ciphertext1, ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ciphertext2) const</td></tr>
<tr class="separator:ae2e820dd4dfc7859231ea459be30bae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d204f6675fb7289f3bab8c21bff39f1"><td class="memItemLeft" align="right" valign="top"><a id="a8d204f6675fb7289f3bab8c21bff39f1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>AdjustLevelsEq</b> (Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; &amp;ciphertext1, Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; &amp;ciphertext2) const</td></tr>
<tr class="separator:a8d204f6675fb7289f3bab8c21bff39f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e36aa274a0884626856c4abd81dee70"><td class="memItemLeft" align="right" valign="top"><a id="a1e36aa274a0884626856c4abd81dee70"></a>
std::pair&lt; shared_ptr&lt; ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; &gt;, <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>AdjustLevels</b> (ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ciphertext, ConstPlaintext plaintext) const</td></tr>
<tr class="separator:a1e36aa274a0884626856c4abd81dee70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6dc667c3b57151d2614de424a69aa9f"><td class="memItemLeft" align="right" valign="top"><a id="ae6dc667c3b57151d2614de424a69aa9f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>AdjustLevelsEq</b> (Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; &amp;ciphertext, Plaintext plaintext) const</td></tr>
<tr class="separator:ae6dc667c3b57151d2614de424a69aa9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17ff7fa28feb77ee02e00feb2d3f71e2"><td class="memItemLeft" align="right" valign="top"><a id="a17ff7fa28feb77ee02e00feb2d3f71e2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EvalAddInPlace</b> (Ciphertext&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">Poly</a> &gt; &amp;ciphertext1, ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">Poly</a> &gt; ciphertext2) const</td></tr>
<tr class="separator:a17ff7fa28feb77ee02e00feb2d3f71e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8729434465cc5e098eeaf95593e6a6ba"><td class="memItemLeft" align="right" valign="top"><a id="a8729434465cc5e098eeaf95593e6a6ba"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EvalAddInPlace</b> (Ciphertext&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">NativePoly</a> &gt; &amp;ciphertext1, ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">NativePoly</a> &gt; ciphertext2) const</td></tr>
<tr class="separator:a8729434465cc5e098eeaf95593e6a6ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a721eef444a7c830fc6e06c137526fee7"><td class="memItemLeft" align="right" valign="top"><a id="a721eef444a7c830fc6e06c137526fee7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EvalAddInPlace</b> (Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; &amp;ciphertext1, ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ciphertext2) const</td></tr>
<tr class="separator:a721eef444a7c830fc6e06c137526fee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe07f89d74a0f5d70db3ad3e10e06e9"><td class="memItemLeft" align="right" valign="top"><a id="aafe07f89d74a0f5d70db3ad3e10e06e9"></a>
Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalAddMutable</b> (Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; &amp;ciphertext1, Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; &amp;ciphertext2) const</td></tr>
<tr class="separator:aafe07f89d74a0f5d70db3ad3e10e06e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a010acd8e25a42b725be6b05974bcfa73"><td class="memItemLeft" align="right" valign="top"><a id="a010acd8e25a42b725be6b05974bcfa73"></a>
Ciphertext&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">Poly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalAdd</b> (ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">Poly</a> &gt; ciphertext, ConstPlaintext plaintext) const</td></tr>
<tr class="separator:a010acd8e25a42b725be6b05974bcfa73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c91b47ac2350d8a2248817ac3a30e7e"><td class="memItemLeft" align="right" valign="top"><a id="a1c91b47ac2350d8a2248817ac3a30e7e"></a>
Ciphertext&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">NativePoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalAdd</b> (ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">NativePoly</a> &gt; ciphertext, ConstPlaintext plaintext) const</td></tr>
<tr class="separator:a1c91b47ac2350d8a2248817ac3a30e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e99462539497736959e602fbd330205"><td class="memItemLeft" align="right" valign="top"><a id="a4e99462539497736959e602fbd330205"></a>
Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalAdd</b> (ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ciphertext, ConstPlaintext plaintext) const</td></tr>
<tr class="separator:a4e99462539497736959e602fbd330205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7a249ba2ec3e538f9361a69dbe2dff2"><td class="memItemLeft" align="right" valign="top"><a id="ab7a249ba2ec3e538f9361a69dbe2dff2"></a>
Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalAddMutable</b> (Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; &amp;ciphertext, Plaintext plaintext) const</td></tr>
<tr class="separator:ab7a249ba2ec3e538f9361a69dbe2dff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab042c31884df2467a5d05b860b8874a4"><td class="memItemLeft" align="right" valign="top"><a id="ab042c31884df2467a5d05b860b8874a4"></a>
Ciphertext&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">Poly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalSub</b> (ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">Poly</a> &gt; ciphertext1, ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">Poly</a> &gt; ciphertext2) const</td></tr>
<tr class="separator:ab042c31884df2467a5d05b860b8874a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a539a2940dee1508073fd24a32cede09c"><td class="memItemLeft" align="right" valign="top"><a id="a539a2940dee1508073fd24a32cede09c"></a>
Ciphertext&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">NativePoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalSub</b> (ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">NativePoly</a> &gt; ciphertext1, ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">NativePoly</a> &gt; ciphertext2) const</td></tr>
<tr class="separator:a539a2940dee1508073fd24a32cede09c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c7d2f28b56dc308b0a148eedcc792fe"><td class="memItemLeft" align="right" valign="top"><a id="a1c7d2f28b56dc308b0a148eedcc792fe"></a>
Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalSub</b> (ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ciphertext1, ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ciphertext2) const</td></tr>
<tr class="separator:a1c7d2f28b56dc308b0a148eedcc792fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39dc33c37b762cf2dcaa80d96797766c"><td class="memItemLeft" align="right" valign="top"><a id="a39dc33c37b762cf2dcaa80d96797766c"></a>
Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalSubMutable</b> (Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; &amp;ciphertext1, Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; &amp;ciphertext2) const</td></tr>
<tr class="separator:a39dc33c37b762cf2dcaa80d96797766c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb2d2db123566a238c9a001935169ed0"><td class="memItemLeft" align="right" valign="top"><a id="adb2d2db123566a238c9a001935169ed0"></a>
Ciphertext&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">Poly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalSub</b> (ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">Poly</a> &gt; ciphertext, ConstPlaintext plaintext) const</td></tr>
<tr class="separator:adb2d2db123566a238c9a001935169ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3768a0a33b8fcc17db6ef04fd1e01c18"><td class="memItemLeft" align="right" valign="top"><a id="a3768a0a33b8fcc17db6ef04fd1e01c18"></a>
Ciphertext&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">NativePoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalSub</b> (ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">NativePoly</a> &gt; ciphertext, ConstPlaintext plaintext) const</td></tr>
<tr class="separator:a3768a0a33b8fcc17db6ef04fd1e01c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72eeb6571425098750d81927ed2b3a10"><td class="memItemLeft" align="right" valign="top"><a id="a72eeb6571425098750d81927ed2b3a10"></a>
Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalSub</b> (ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ciphertext, ConstPlaintext plaintext) const</td></tr>
<tr class="separator:a72eeb6571425098750d81927ed2b3a10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaca8c6a8f0bf3c0f3e65b9f16f77518"><td class="memItemLeft" align="right" valign="top"><a id="afaca8c6a8f0bf3c0f3e65b9f16f77518"></a>
Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalSubMutable</b> (Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; &amp;ciphertext, Plaintext plaintext) const</td></tr>
<tr class="separator:afaca8c6a8f0bf3c0f3e65b9f16f77518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a588defc54d49b9028f15331e42f44a0a"><td class="memItemLeft" align="right" valign="top"><a id="a588defc54d49b9028f15331e42f44a0a"></a>
Ciphertext&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">Poly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalMult</b> (ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">Poly</a> &gt; ciphertext1, ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">Poly</a> &gt; ciphertext2) const</td></tr>
<tr class="separator:a588defc54d49b9028f15331e42f44a0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc93d315b2a54ab28079f50dd2af7e3f"><td class="memItemLeft" align="right" valign="top"><a id="adc93d315b2a54ab28079f50dd2af7e3f"></a>
Ciphertext&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">NativePoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalMult</b> (ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">NativePoly</a> &gt; ciphertext1, ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">NativePoly</a> &gt; ciphertext2) const</td></tr>
<tr class="separator:adc93d315b2a54ab28079f50dd2af7e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f0e0c090b40a9093b9d3f1b10e3479f"><td class="memItemLeft" align="right" valign="top"><a id="a9f0e0c090b40a9093b9d3f1b10e3479f"></a>
Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalMult</b> (ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ciphertext1, ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ciphertext2) const</td></tr>
<tr class="separator:a9f0e0c090b40a9093b9d3f1b10e3479f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab754372ffe8be969696fce38f04d1097"><td class="memItemLeft" align="right" valign="top"><a id="ab754372ffe8be969696fce38f04d1097"></a>
Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalMultMutable</b> (Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; &amp;ciphertext1, Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; &amp;ciphertext2) const</td></tr>
<tr class="separator:ab754372ffe8be969696fce38f04d1097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f6080079a2ea7c620f48c50e3cb7071"><td class="memItemLeft" align="right" valign="top"><a id="a1f6080079a2ea7c620f48c50e3cb7071"></a>
Ciphertext&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">Poly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalMult</b> (ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">Poly</a> &gt; ciphertext, ConstPlaintext plaintext) const</td></tr>
<tr class="separator:a1f6080079a2ea7c620f48c50e3cb7071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec5f6149a321ff9ee4a31d3b3d02f29f"><td class="memItemLeft" align="right" valign="top"><a id="aec5f6149a321ff9ee4a31d3b3d02f29f"></a>
Ciphertext&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">NativePoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalMult</b> (ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">NativePoly</a> &gt; ciphertext, ConstPlaintext plaintext) const</td></tr>
<tr class="separator:aec5f6149a321ff9ee4a31d3b3d02f29f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd349c8beb7203200f2e62098eadb69f"><td class="memItemLeft" align="right" valign="top"><a id="abd349c8beb7203200f2e62098eadb69f"></a>
Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalMult</b> (ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ciphertext, ConstPlaintext plaintext) const</td></tr>
<tr class="separator:abd349c8beb7203200f2e62098eadb69f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a04038a0ad57ea708062d869518cd5c"><td class="memItemLeft" align="right" valign="top"><a id="a6a04038a0ad57ea708062d869518cd5c"></a>
Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalMultMutable</b> (Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; &amp;ciphertext, Plaintext plaintext) const</td></tr>
<tr class="separator:a6a04038a0ad57ea708062d869518cd5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb0f8b1d9c1c7d394cb3f68d74c83aa"><td class="memItemLeft" align="right" valign="top"><a id="a5fb0f8b1d9c1c7d394cb3f68d74c83aa"></a>
Ciphertext&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">Poly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalMultAndRelinearize</b> (ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">Poly</a> &gt; ciphertext1, ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">Poly</a> &gt; ciphertext2, const vector&lt; LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">Poly</a> &gt;&gt; &amp;ek) const</td></tr>
<tr class="separator:a5fb0f8b1d9c1c7d394cb3f68d74c83aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9642eab3e17cd2c1cf50e53047546b04"><td class="memItemLeft" align="right" valign="top"><a id="a9642eab3e17cd2c1cf50e53047546b04"></a>
Ciphertext&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">NativePoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalMultAndRelinearize</b> (ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">NativePoly</a> &gt; ciphertext1, ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">NativePoly</a> &gt; ciphertext2, const vector&lt; LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">NativePoly</a> &gt;&gt; &amp;ek) const</td></tr>
<tr class="separator:a9642eab3e17cd2c1cf50e53047546b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27dd027cc276ce45c8d8b4770d8b2acd"><td class="memItemLeft" align="right" valign="top"><a id="a27dd027cc276ce45c8d8b4770d8b2acd"></a>
Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalMultAndRelinearize</b> (ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ciphertext1, ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ciphertext2, const vector&lt; LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&gt; &amp;ek) const</td></tr>
<tr class="separator:a27dd027cc276ce45c8d8b4770d8b2acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7140df46df2e44336ac3e8a1d22f70b9"><td class="memItemLeft" align="right" valign="top"><a id="a7140df46df2e44336ac3e8a1d22f70b9"></a>
Ciphertext&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">Poly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Relinearize</b> (ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">Poly</a> &gt; ciphertext, const vector&lt; LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">Poly</a> &gt;&gt; &amp;ek) const</td></tr>
<tr class="separator:a7140df46df2e44336ac3e8a1d22f70b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affa687a93847e0cf0327f6751000d8f9"><td class="memItemLeft" align="right" valign="top"><a id="affa687a93847e0cf0327f6751000d8f9"></a>
Ciphertext&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">NativePoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Relinearize</b> (ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">NativePoly</a> &gt; ciphertext, const vector&lt; LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">NativePoly</a> &gt;&gt; &amp;ek) const</td></tr>
<tr class="separator:affa687a93847e0cf0327f6751000d8f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b4909b7b36cd4408a7ddcea05c58fb6"><td class="memItemLeft" align="right" valign="top"><a id="a2b4909b7b36cd4408a7ddcea05c58fb6"></a>
Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Relinearize</b> (ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ciphertext, const vector&lt; LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&gt; &amp;ek) const</td></tr>
<tr class="separator:a2b4909b7b36cd4408a7ddcea05c58fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f1d2af1c373b8ec235829bcc0aeb8c3"><td class="memItemLeft" align="right" valign="top"><a id="a2f1d2af1c373b8ec235829bcc0aeb8c3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>RelinearizeInPlace</b> (Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; &amp;ciphertext, const vector&lt; LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&gt; &amp;ek) const</td></tr>
<tr class="separator:a2f1d2af1c373b8ec235829bcc0aeb8c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad842f94d8691fe9c2f5362a3a884560b"><td class="memItemLeft" align="right" valign="top"><a id="ad842f94d8691fe9c2f5362a3a884560b"></a>
shared_ptr&lt; vector&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">Poly</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalFastRotationPrecompute</b> (ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">Poly</a> &gt; ciphertext) const</td></tr>
<tr class="separator:ad842f94d8691fe9c2f5362a3a884560b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c959787dc542f0c121aca7eef71510d"><td class="memItemLeft" align="right" valign="top"><a id="a5c959787dc542f0c121aca7eef71510d"></a>
shared_ptr&lt; vector&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">NativePoly</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalFastRotationPrecompute</b> (ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">NativePoly</a> &gt; ciphertext) const</td></tr>
<tr class="separator:a5c959787dc542f0c121aca7eef71510d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c3e4977f887f1f6dfa8498d75078b99"><td class="memItemLeft" align="right" valign="top"><a id="a1c3e4977f887f1f6dfa8498d75078b99"></a>
shared_ptr&lt; vector&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalFastRotationPrecompute</b> (ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ciphertext) const</td></tr>
<tr class="separator:a1c3e4977f887f1f6dfa8498d75078b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c43f35b1a8427eb7ce8e5fecee52548"><td class="memItemLeft" align="right" valign="top"><a id="a8c43f35b1a8427eb7ce8e5fecee52548"></a>
Ciphertext&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">Poly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalFastRotation</b> (ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">Poly</a> &gt; ciphertext, const usint index, const usint m, const shared_ptr&lt; vector&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">Poly</a> &gt;&gt; precomp) const</td></tr>
<tr class="separator:a8c43f35b1a8427eb7ce8e5fecee52548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b2af47df952c3988f6388968d40c6e"><td class="memItemLeft" align="right" valign="top"><a id="a25b2af47df952c3988f6388968d40c6e"></a>
Ciphertext&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">NativePoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalFastRotation</b> (ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">NativePoly</a> &gt; ciphertext, const usint index, const usint m, const shared_ptr&lt; vector&lt; <a class="el" href="classlbcrypto_1_1PolyImpl.html">NativePoly</a> &gt;&gt; precomp) const</td></tr>
<tr class="separator:a25b2af47df952c3988f6388968d40c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59316a1462759a4d8ce992452c49c65a"><td class="memItemLeft" align="right" valign="top"><a id="a59316a1462759a4d8ce992452c49c65a"></a>
Ciphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EvalFastRotation</b> (ConstCiphertext&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt; ciphertext, const usint index, const usint m, const shared_ptr&lt; vector&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&gt; precomp) const</td></tr>
<tr class="separator:a59316a1462759a4d8ce992452c49c65a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classlbcrypto_1_1LPSHEAlgorithm')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html">lbcrypto::LPSHEAlgorithm&lt; Element &gt;</a></td></tr>
<tr class="memitem:a4a866542a6a9d06b6a2285aec677ea8e inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memItemLeft" align="right" valign="top">virtual Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a4a866542a6a9d06b6a2285aec677ea8e">EvalAdd</a> (ConstCiphertext&lt; Element &gt; ciphertext1, ConstCiphertext&lt; Element &gt; ciphertext2) const</td></tr>
<tr class="separator:a4a866542a6a9d06b6a2285aec677ea8e inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c7df21f729e892880fb63ef8fbfe47b inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memItemLeft" align="right" valign="top">virtual Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a1c7df21f729e892880fb63ef8fbfe47b">EvalAdd</a> (ConstCiphertext&lt; Element &gt; ciphertext, double constant) const</td></tr>
<tr class="separator:a1c7df21f729e892880fb63ef8fbfe47b inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8e724b97c7b847ea070b384ee89ee2d inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memItemLeft" align="right" valign="top">virtual Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#af8e724b97c7b847ea070b384ee89ee2d">EvalSub</a> (ConstCiphertext&lt; Element &gt; ciphertext, double constant) const</td></tr>
<tr class="separator:af8e724b97c7b847ea070b384ee89ee2d inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0350070067a4e946aeef13e4319c4a5f inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memItemLeft" align="right" valign="top">virtual Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a0350070067a4e946aeef13e4319c4a5f">EvalMult</a> (ConstCiphertext&lt; Element &gt; ciphertext, double constant) const</td></tr>
<tr class="separator:a0350070067a4e946aeef13e4319c4a5f inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1f131758ff8c65224c81e271be9b322 inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memItemLeft" align="right" valign="top">virtual Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#ab1f131758ff8c65224c81e271be9b322">EvalMultMutable</a> (Ciphertext&lt; Element &gt; &amp;ciphertext, double constant) const</td></tr>
<tr class="separator:ab1f131758ff8c65224c81e271be9b322 inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e810519bc50ed1c9123a19952d54ef inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memItemLeft" align="right" valign="top">virtual Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a43e810519bc50ed1c9123a19952d54ef">EvalAddMany</a> (const vector&lt; Ciphertext&lt; Element &gt;&gt; &amp;ctList) const</td></tr>
<tr class="separator:a43e810519bc50ed1c9123a19952d54ef inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdea40a81c38f194e4c8df12b509e684 inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memItemLeft" align="right" valign="top">virtual Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#afdea40a81c38f194e4c8df12b509e684">EvalAddManyInPlace</a> (vector&lt; Ciphertext&lt; Element &gt;&gt; &amp;ctList) const</td></tr>
<tr class="separator:afdea40a81c38f194e4c8df12b509e684 inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4d52f775cfa969542664b2a225e687b inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memItemLeft" align="right" valign="top">virtual Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#ac4d52f775cfa969542664b2a225e687b">AddRandomNoise</a> (ConstCiphertext&lt; Element &gt; ciphertext) const</td></tr>
<tr class="separator:ac4d52f775cfa969542664b2a225e687b inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ac0c879a96a9c701a70029940342914 inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memItemLeft" align="right" valign="top"><a id="a0ac0c879a96a9c701a70029940342914"></a>
virtual Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>KeySwitch</b> (const LPEvalKey&lt; Element &gt; keySwitchHint, ConstCiphertext&lt; Element &gt; cipherText) const</td></tr>
<tr class="separator:a0ac0c879a96a9c701a70029940342914 inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add44ec08a434ab87a239261b9bc363c5 inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memItemLeft" align="right" valign="top">virtual shared_ptr&lt; std::map&lt; usint, LPEvalKey&lt; Element &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#add44ec08a434ab87a239261b9bc363c5">EvalAtIndexKeyGen</a> (const LPPublicKey&lt; Element &gt; publicKey, const LPPrivateKey&lt; Element &gt; origPrivateKey, const std::vector&lt; int32_t &gt; &amp;indexList) const</td></tr>
<tr class="separator:add44ec08a434ab87a239261b9bc363c5 inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7853f777ce62fcd145cca9ac05eabfab inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memItemLeft" align="right" valign="top">virtual Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a7853f777ce62fcd145cca9ac05eabfab">EvalAtIndex</a> (ConstCiphertext&lt; Element &gt; ciphertext, int32_t index, const std::map&lt; usint, LPEvalKey&lt; Element &gt;&gt; &amp;evalAtIndexKeys) const</td></tr>
<tr class="separator:a7853f777ce62fcd145cca9ac05eabfab inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1588b0268068bd450eecc449026f32c9 inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memItemLeft" align="right" valign="top">virtual shared_ptr&lt; std::map&lt; usint, LPEvalKey&lt; Element &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a1588b0268068bd450eecc449026f32c9">EvalSumKeyGen</a> (const LPPrivateKey&lt; Element &gt; privateKey, const LPPublicKey&lt; Element &gt; publicKey) const</td></tr>
<tr class="separator:a1588b0268068bd450eecc449026f32c9 inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17c4f3e667fb6450121250ea6b731de7 inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memItemLeft" align="right" valign="top">virtual shared_ptr&lt; std::map&lt; usint, LPEvalKey&lt; Element &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a17c4f3e667fb6450121250ea6b731de7">EvalSumRowsKeyGen</a> (const LPPrivateKey&lt; Element &gt; privateKey, const LPPublicKey&lt; Element &gt; publicKey, usint rowSize, usint subringDim=0) const</td></tr>
<tr class="separator:a17c4f3e667fb6450121250ea6b731de7 inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a536f096af43190927ed98f4e29795ab4 inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memItemLeft" align="right" valign="top">virtual shared_ptr&lt; std::map&lt; usint, LPEvalKey&lt; Element &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a536f096af43190927ed98f4e29795ab4">EvalSumColsKeyGen</a> (const LPPrivateKey&lt; Element &gt; privateKey, const LPPublicKey&lt; Element &gt; publicKey) const</td></tr>
<tr class="separator:a536f096af43190927ed98f4e29795ab4 inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bf74e67ff749ee150f67bb9b3ee23c3 inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memItemLeft" align="right" valign="top">virtual Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a0bf74e67ff749ee150f67bb9b3ee23c3">EvalSum</a> (ConstCiphertext&lt; Element &gt; ciphertext, usint batchSize, const std::map&lt; usint, LPEvalKey&lt; Element &gt;&gt; &amp;evalKeys) const</td></tr>
<tr class="separator:a0bf74e67ff749ee150f67bb9b3ee23c3 inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ed0dc4a202110d971e9ddddae234cbb inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memItemLeft" align="right" valign="top">virtual Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a3ed0dc4a202110d971e9ddddae234cbb">EvalSumRows</a> (ConstCiphertext&lt; Element &gt; ciphertext, usint rowSize, const std::map&lt; usint, LPEvalKey&lt; Element &gt;&gt; &amp;evalKeys, usint subringDim=0) const</td></tr>
<tr class="separator:a3ed0dc4a202110d971e9ddddae234cbb inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87075af82796b5eecd647c643f6efd73 inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memItemLeft" align="right" valign="top">virtual Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a87075af82796b5eecd647c643f6efd73">EvalSumCols</a> (ConstCiphertext&lt; Element &gt; ciphertext, usint batchSize, const std::map&lt; usint, LPEvalKey&lt; Element &gt;&gt; &amp;evalKeys, const std::map&lt; usint, LPEvalKey&lt; Element &gt;&gt; &amp;rightEvalKeys) const</td></tr>
<tr class="separator:a87075af82796b5eecd647c643f6efd73 inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20e0f28ffdf6ee1b69d9c353198ca249 inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memItemLeft" align="right" valign="top">virtual Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a20e0f28ffdf6ee1b69d9c353198ca249">EvalInnerProduct</a> (ConstCiphertext&lt; Element &gt; ciphertext1, ConstCiphertext&lt; Element &gt; ciphertext2, usint batchSize, const std::map&lt; usint, LPEvalKey&lt; Element &gt;&gt; &amp;evalSumKeys, const LPEvalKey&lt; Element &gt; evalMultKey) const</td></tr>
<tr class="separator:a20e0f28ffdf6ee1b69d9c353198ca249 inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6958a75718823cea8a5f9f9407fa875f inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memItemLeft" align="right" valign="top">virtual Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a6958a75718823cea8a5f9f9407fa875f">EvalInnerProduct</a> (ConstCiphertext&lt; Element &gt; ciphertext1, ConstPlaintext plaintext, usint batchSize, const std::map&lt; usint, LPEvalKey&lt; Element &gt;&gt; &amp;evalSumKeys) const</td></tr>
<tr class="separator:a6958a75718823cea8a5f9f9407fa875f inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bc33751c5140ccc40c1ad8791ff9fab inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memItemLeft" align="right" valign="top">virtual Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a1bc33751c5140ccc40c1ad8791ff9fab">EvalMerge</a> (const vector&lt; Ciphertext&lt; Element &gt;&gt; &amp;ciphertextVector, const std::map&lt; usint, LPEvalKey&lt; Element &gt;&gt; &amp;evalKeys) const</td></tr>
<tr class="separator:a1bc33751c5140ccc40c1ad8791ff9fab inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0edfc599ad82c9f2ce6084ffa0bf4d9c inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memItemLeft" align="right" valign="top"><a id="a0edfc599ad82c9f2ce6084ffa0bf4d9c"></a>
virtual Ciphertext&lt; Element &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>AdjustLevelWithRescale</b> (Ciphertext&lt; Element &gt; &amp;c1, uint32_t targetLevel) const</td></tr>
<tr class="separator:a0edfc599ad82c9f2ce6084ffa0bf4d9c inherit pub_methods_classlbcrypto_1_1LPSHEAlgorithm"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class Element&gt;<br />
class lbcrypto::LPAlgorithmSHEBGVrns&lt; Element &gt;</h3>

<p>Class for evaluation of somewhat homomorphic operations.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Element</td><td>a ring element. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a656217d76fa4f932078699581552d308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a656217d76fa4f932078699581552d308">&#9670;&nbsp;</a></span>LPAlgorithmSHEBGVrns()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html">lbcrypto::LPAlgorithmSHEBGVrns</a>&lt; Element &gt;::<a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html">LPAlgorithmSHEBGVrns</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default constructor </p>

</div>
</div>
<a id="ac0e523a1a3a4b80ec407627a5021fc4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0e523a1a3a4b80ec407627a5021fc4e">&#9670;&nbsp;</a></span>~LPAlgorithmSHEBGVrns()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html">lbcrypto::LPAlgorithmSHEBGVrns</a>&lt; Element &gt;::~<a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html">LPAlgorithmSHEBGVrns</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a91e62a871a02eca0fe763a2108f853cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91e62a871a02eca0fe763a2108f853cf">&#9670;&nbsp;</a></span>AdjustLevels() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;shared_ptr&lt;ConstCiphertext&lt;Element&gt; &gt;, Element&gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html">lbcrypto::LPAlgorithmSHEBGVrns</a>&lt; Element &gt;::AdjustLevels </td>
          <td>(</td>
          <td class="paramtype">ConstCiphertext&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>ciphertext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstPlaintext&#160;</td>
          <td class="paramname"><em>plaintext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Internal function to automatically level-reduce a ciphertext and a plaintext.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext1</td><td>input ciphertext. </td></tr>
    <tr><td class="paramname">plaintext</td><td>input plaintext. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector containing two ciphertexts of the same level. </dd></dl>

</div>
</div>
<a id="ab2089b66add5dca746866fdbf1c05033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2089b66add5dca746866fdbf1c05033">&#9670;&nbsp;</a></span>AdjustLevels() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;shared_ptr&lt;ConstCiphertext&lt;Element&gt; &gt; &gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html">lbcrypto::LPAlgorithmSHEBGVrns</a>&lt; Element &gt;::AdjustLevels </td>
          <td>(</td>
          <td class="paramtype">ConstCiphertext&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>ciphertext1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstCiphertext&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>ciphertext2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Internal function to automatically level-reduce a pair of ciphertexts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext1</td><td>first input ciphertext. </td></tr>
    <tr><td class="paramname">ciphertext2</td><td>second input ciphertext. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector containing two ciphertexts of the same level. </dd></dl>

</div>
</div>
<a id="a838800e0033a01879c0d8168f4ab52df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a838800e0033a01879c0d8168f4ab52df">&#9670;&nbsp;</a></span>AdjustLevelsEq() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html">lbcrypto::LPAlgorithmSHEBGVrns</a>&lt; Element &gt;::AdjustLevelsEq </td>
          <td>(</td>
          <td class="paramtype">Ciphertext&lt; Element &gt; &amp;&#160;</td>
          <td class="paramname"><em>ciphertext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Plaintext&#160;</td>
          <td class="paramname"><em>plaintext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Internal function to automatically level-reduce a ciphertext and a plaintext.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext1</td><td>input ciphertext. </td></tr>
    <tr><td class="paramname">plaintext</td><td>input plaintext. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector containing two ciphertexts of the same level. </dd></dl>

</div>
</div>
<a id="aa7bf91898afeda8b339caf9aa3e416d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7bf91898afeda8b339caf9aa3e416d1">&#9670;&nbsp;</a></span>AdjustLevelsEq() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html">lbcrypto::LPAlgorithmSHEBGVrns</a>&lt; Element &gt;::AdjustLevelsEq </td>
          <td>(</td>
          <td class="paramtype">Ciphertext&lt; Element &gt; &amp;&#160;</td>
          <td class="paramname"><em>ciphertext1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ciphertext&lt; Element &gt; &amp;&#160;</td>
          <td class="paramname"><em>ciphertext2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Internal function to automatically level-reduce a pair of ciphertexts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext1</td><td>first input ciphertext. </td></tr>
    <tr><td class="paramname">ciphertext2</td><td>second input ciphertext. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5395cfef391f93f9ff3c827144510b96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5395cfef391f93f9ff3c827144510b96">&#9670;&nbsp;</a></span>EvalAdd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ciphertext&lt;Element&gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html">lbcrypto::LPAlgorithmSHEBGVrns</a>&lt; Element &gt;::EvalAdd </td>
          <td>(</td>
          <td class="paramtype">ConstCiphertext&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>ciphertext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstPlaintext&#160;</td>
          <td class="paramname"><em>plaintext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function for homomorphic addition of ciphertexts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext</td><td>input ciphertext. </td></tr>
    <tr><td class="paramname">plaintext</td><td>input plaintext. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result of homomorphic addition of input ciphertexts. </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a521645ed0ef899672cef94a600fbeb00">lbcrypto::LPSHEAlgorithm&lt; Element &gt;</a>.</p>

</div>
</div>
<a id="a20b506bce3c365cb4e445211b73aae51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20b506bce3c365cb4e445211b73aae51">&#9670;&nbsp;</a></span>EvalAddCore() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Ciphertext&lt; Element &gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html">lbcrypto::LPAlgorithmSHEBGVrns</a>&lt; Element &gt;::EvalAddCore </td>
          <td>(</td>
          <td class="paramtype">ConstCiphertext&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>ciphertext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Element&#160;</td>
          <td class="paramname"><em>ptElement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Internal function for homomorphic addition of ciphertext and plaintext. This method does not check whether input ciphertexts are at the same level.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext</td><td>input ciphertext. </td></tr>
    <tr><td class="paramname">ptElement</td><td>the Element corresponding to the input plaintext. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result of homomorphic addition of inputs. </dd></dl>

</div>
</div>
<a id="a9306b26fa0ca0090291bb3bdf04d55fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9306b26fa0ca0090291bb3bdf04d55fa">&#9670;&nbsp;</a></span>EvalAddCore() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Ciphertext&lt; Element &gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html">lbcrypto::LPAlgorithmSHEBGVrns</a>&lt; Element &gt;::EvalAddCore </td>
          <td>(</td>
          <td class="paramtype">ConstCiphertext&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>ciphertext1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstCiphertext&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>ciphertext2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Internal function for homomorphic addition of ciphertexts. This method does not check whether input ciphertexts are at the same level.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext1</td><td>first input ciphertext. </td></tr>
    <tr><td class="paramname">ciphertext2</td><td>second input ciphertext. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result of homomorphic addition of input ciphertexts. </dd></dl>

</div>
</div>
<a id="ad12982cd011bd39110ed2e5145b5873f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad12982cd011bd39110ed2e5145b5873f">&#9670;&nbsp;</a></span>EvalAddCoreInPlace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html">lbcrypto::LPAlgorithmSHEBGVrns</a>&lt; Element &gt;::EvalAddCoreInPlace </td>
          <td>(</td>
          <td class="paramtype">Ciphertext&lt; Element &gt; &amp;&#160;</td>
          <td class="paramname"><em>ciphertext1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstCiphertext&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>ciphertext2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Internal function for in-place homomorphic addition of ciphertexts. This method does not check whether input ciphertexts are at the same level.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext1</td><td>first input/output ciphertext. </td></tr>
    <tr><td class="paramname">ciphertext2</td><td>second input ciphertext.</td></tr>
  </table>
  </dd>
</dl>
<p><code>ciphertext1</code> stores the result of <code>ciphertext1</code> + <code>ciphertext2</code> </p>

</div>
</div>
<a id="ac1ab6b8779b8244160923d23b0c84630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1ab6b8779b8244160923d23b0c84630">&#9670;&nbsp;</a></span>EvalAddInPlace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html">lbcrypto::LPAlgorithmSHEBGVrns</a>&lt; Element &gt;::EvalAddInPlace </td>
          <td>(</td>
          <td class="paramtype">Ciphertext&lt; Element &gt; &amp;&#160;</td>
          <td class="paramname"><em>ciphertext1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstCiphertext&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>ciphertext2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function for in-place homomorphic addition of ciphertexts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ct1</td><td>first input/output ciphertext. </td></tr>
    <tr><td class="paramname">ct2</td><td>second input ciphertext.</td></tr>
  </table>
  </dd>
</dl>
<p><code>ct1</code> stores the result of <code>ct1</code> + <code>ct2</code> </p>

<p>Implements <a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#af37df4903e293cbfa6296ea523b4cfed">lbcrypto::LPSHEAlgorithm&lt; Element &gt;</a>.</p>

</div>
</div>
<a id="aa6d007dfccd3a205cf4ea580710c7279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6d007dfccd3a205cf4ea580710c7279">&#9670;&nbsp;</a></span>EvalAddMutable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Ciphertext&lt;Element&gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html">lbcrypto::LPAlgorithmSHEBGVrns</a>&lt; Element &gt;::EvalAddMutable </td>
          <td>(</td>
          <td class="paramtype">Ciphertext&lt; Element &gt; &amp;&#160;</td>
          <td class="paramname"><em>ciphertext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Plaintext&#160;</td>
          <td class="paramname"><em>plaintext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function for homomorphic addition of ciphertexts. Mutable version - input ciphertexts may get rescaled/level-reduced.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext</td><td>input ciphertext. </td></tr>
    <tr><td class="paramname">plaintext</td><td>input plaintext. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result of homomorphic addition of input ciphertexts. </dd></dl>

<p>Reimplemented from <a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a97da21c25a0ba8c0c25ffaa3436f9cde">lbcrypto::LPSHEAlgorithm&lt; Element &gt;</a>.</p>

</div>
</div>
<a id="addc4789c52f052da41992969cc9aa77a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addc4789c52f052da41992969cc9aa77a">&#9670;&nbsp;</a></span>EvalAddMutable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Ciphertext&lt;Element&gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html">lbcrypto::LPAlgorithmSHEBGVrns</a>&lt; Element &gt;::EvalAddMutable </td>
          <td>(</td>
          <td class="paramtype">Ciphertext&lt; Element &gt; &amp;&#160;</td>
          <td class="paramname"><em>ciphertext1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ciphertext&lt; Element &gt; &amp;&#160;</td>
          <td class="paramname"><em>ciphertext2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function for homomorphic addition of ciphertexts. Mutable version - input ciphertexts may get rescaled/level-reduced.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext1</td><td>first input ciphertext. </td></tr>
    <tr><td class="paramname">ciphertext2</td><td>second input ciphertext. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result of homomorphic addition of input ciphertexts. </dd></dl>

<p>Reimplemented from <a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a148a8b5015277696e1a3648dcc60d609">lbcrypto::LPSHEAlgorithm&lt; Element &gt;</a>.</p>

</div>
</div>
<a id="a4cdacc9e278c988020ac6d4c485c46bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cdacc9e278c988020ac6d4c485c46bb">&#9670;&nbsp;</a></span>EvalAutomorphism()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ciphertext&lt; Element &gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html">lbcrypto::LPAlgorithmSHEBGVrns</a>&lt; Element &gt;::EvalAutomorphism </td>
          <td>(</td>
          <td class="paramtype">ConstCiphertext&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>ciphertext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">usint&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; usint, LPEvalKey&lt; Element &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>evalKeys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CALLER_INFO_ARGS_HDR&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function for evaluating automorphism of ciphertext at index i</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext</td><td>the input ciphertext. </td></tr>
    <tr><td class="paramname">i</td><td>automorphism index </td></tr>
    <tr><td class="paramname">&amp;evalKeys</td><td>- reference to the map of evaluation keys generated by EvalAutomorphismKeyGen. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>resulting ciphertext </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a82407b88e94e1e64b2f3a915f71e1097">lbcrypto::LPSHEAlgorithm&lt; Element &gt;</a>.</p>

</div>
</div>
<a id="ad3c3c25ad5ebe968dc002abc3b174170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3c3c25ad5ebe968dc002abc3b174170">&#9670;&nbsp;</a></span>EvalAutomorphismKeyGen() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt; std::map&lt; usint, LPEvalKey&lt; Element &gt; &gt; &gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html">lbcrypto::LPAlgorithmSHEBGVrns</a>&lt; Element &gt;::EvalAutomorphismKeyGen </td>
          <td>(</td>
          <td class="paramtype">const LPPrivateKey&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>privateKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; usint &gt; &amp;&#160;</td>
          <td class="paramname"><em>indexList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generate automophism keys for a given private key; Uses the private key for encryption</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">privateKey</td><td>private key. </td></tr>
    <tr><td class="paramname">indexList</td><td>list of automorphism indices to be computed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns the evaluation keys </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#afd0444d50a9343ac6b15297533b442fa">lbcrypto::LPSHEAlgorithm&lt; Element &gt;</a>.</p>

</div>
</div>
<a id="abfe05cd8df5cf7d8051334f3102e43cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfe05cd8df5cf7d8051334f3102e43cd">&#9670;&nbsp;</a></span>EvalAutomorphismKeyGen() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;std::map&lt;usint, LPEvalKey&lt;Element&gt; &gt; &gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html">lbcrypto::LPAlgorithmSHEBGVrns</a>&lt; Element &gt;::EvalAutomorphismKeyGen </td>
          <td>(</td>
          <td class="paramtype">const LPPublicKey&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>publicKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LPPrivateKey&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>privateKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; usint &gt; &amp;&#160;</td>
          <td class="paramname"><em>indexList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generate automophism keys for a given private key; Uses the public key for encryption</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">publicKey</td><td>public key. </td></tr>
    <tr><td class="paramname">privateKey</td><td>private key. </td></tr>
    <tr><td class="paramname">indexList</td><td>list of automorphism indices to be computed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns the evaluation keys </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a0932abb72f5cdde6bbbb2ce97c3d12e0">lbcrypto::LPSHEAlgorithm&lt; Element &gt;</a>.</p>

</div>
</div>
<a id="aa08487f40c840c2169b7846a0a6b13e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa08487f40c840c2169b7846a0a6b13e6">&#9670;&nbsp;</a></span>EvalFastRotation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ciphertext&lt;Element&gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html">lbcrypto::LPAlgorithmSHEBGVrns</a>&lt; Element &gt;::EvalFastRotation </td>
          <td>(</td>
          <td class="paramtype">ConstCiphertext&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>ciphertext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const usint&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const usint&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; vector&lt; Element &gt;&gt;&#160;</td>
          <td class="paramname"><em>precomp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>EvalFastRotation is a wrapper for hoisted automorphism. It decides what version of EvalFastRotation to perform, based on the key switching technique currently used (e.g., BV or GHS key switching).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext</td><td>the input ciphertext to perform the automorphism on </td></tr>
    <tr><td class="paramname">index</td><td>the index of the rotation. Positive indices correspond to left rotations and negative indices correspond to right rotations. </td></tr>
    <tr><td class="paramname">m</td><td>is the cyclotomic order </td></tr>
    <tr><td class="paramname">precomp</td><td>In BV, this is the digit decomposition created by EvalFastRotationPrecomputeBV. In GHS, this is the expanded part of the ciphertext. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a02b3d3037492c7bc5d6102b03e9cc345">lbcrypto::LPSHEAlgorithm&lt; Element &gt;</a>.</p>

</div>
</div>
<a id="abb9d3d6c626d3c3ab163b4847ecb5a3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb9d3d6c626d3c3ab163b4847ecb5a3c">&#9670;&nbsp;</a></span>EvalFastRotationPrecompute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;vector&lt;Element&gt; &gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html">lbcrypto::LPAlgorithmSHEBGVrns</a>&lt; Element &gt;::EvalFastRotationPrecompute </td>
          <td>(</td>
          <td class="paramtype">ConstCiphertext&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>ciphertext</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>EvalFastRotationPrecompute is a wrapper for the hoisted automorphism pre-computation step, in schemes BV, GHS, and Hybrid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext</td><td>the input ciphertext on which to do the precomputation (digit decomposition) </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a726e5f4d7c4d1d41cfa5a9b4762ff6d8">lbcrypto::LPSHEAlgorithm&lt; Element &gt;</a>.</p>

</div>
</div>
<a id="a701de6460ada896913839f27a7ac9ccd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a701de6460ada896913839f27a7ac9ccd">&#9670;&nbsp;</a></span>EvalLinearWSum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Ciphertext&lt;Element&gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html">lbcrypto::LPAlgorithmSHEBGVrns</a>&lt; Element &gt;::EvalLinearWSum </td>
          <td>(</td>
          <td class="paramtype">vector&lt; Ciphertext&lt; Element &gt;&gt;&#160;</td>
          <td class="paramname"><em>ciphertexts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>constants</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function for computing the linear weighted sum of a vector of ciphertexts. It is implemented as a wrapper to EvalLinearWSumMutable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertexts</td><td>vector of input ciphertexts. </td></tr>
    <tr><td class="paramname">constants</td><td>vector containing double weights. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A ciphertext containing the linear weighted sum. </dd></dl>

<p>Reimplemented from <a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#aa75fdb1b75ea93c1122de6a14c8a6d6a">lbcrypto::LPSHEAlgorithm&lt; Element &gt;</a>.</p>

</div>
</div>
<a id="a76f85a21e0c8f105dd680e4b115eeba9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76f85a21e0c8f105dd680e4b115eeba9">&#9670;&nbsp;</a></span>EvalLinearWSumMutable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Ciphertext&lt;Element&gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html">lbcrypto::LPAlgorithmSHEBGVrns</a>&lt; Element &gt;::EvalLinearWSumMutable </td>
          <td>(</td>
          <td class="paramtype">vector&lt; Ciphertext&lt; Element &gt;&gt;&#160;</td>
          <td class="paramname"><em>ciphertexts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>constants</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function for computing the linear weighted sum of a vector of ciphertexts. This is a mutable method, meaning that the level/depth of input ciphertexts may change.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertexts</td><td>vector of input ciphertexts. </td></tr>
    <tr><td class="paramname">constants</td><td>vector containing double weights. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A ciphertext containing the linear weighted sum. </dd></dl>

<p>Reimplemented from <a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a6f31c48c4930e31db2b4f5e282584b08">lbcrypto::LPSHEAlgorithm&lt; Element &gt;</a>.</p>

</div>
</div>
<a id="aee5b063ab50bb3bc6ab86c7c2ba89739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee5b063ab50bb3bc6ab86c7c2ba89739">&#9670;&nbsp;</a></span>EvalMult() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ciphertext&lt;Element&gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html">lbcrypto::LPAlgorithmSHEBGVrns</a>&lt; Element &gt;::EvalMult </td>
          <td>(</td>
          <td class="paramtype">ConstCiphertext&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>ciphertext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstPlaintext&#160;</td>
          <td class="paramname"><em>plaintext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function for multiplying ciphertext by plaintext.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext</td><td>input ciphertext. </td></tr>
    <tr><td class="paramname">plaintext</td><td>input plaintext embedded in the cryptocontext. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result of the multiplication. </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a21718c52f7f42b8e9655d932fa99ff4b">lbcrypto::LPSHEAlgorithm&lt; Element &gt;</a>.</p>

</div>
</div>
<a id="ad9948b43493d58a83fdd55671fe1c4ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9948b43493d58a83fdd55671fe1c4ab">&#9670;&nbsp;</a></span>EvalMult() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ciphertext&lt;Element&gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html">lbcrypto::LPAlgorithmSHEBGVrns</a>&lt; Element &gt;::EvalMult </td>
          <td>(</td>
          <td class="paramtype">ConstCiphertext&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>ciphertext1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstCiphertext&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>ciphertext2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function for homomorphic multiplication of ciphertexts without key switching. Currently it assumes that the input arguments are fresh ciphertexts (of depth 1). Support for the input ciphertexts of higher depths will be added later.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext1</td><td>first input ciphertext. </td></tr>
    <tr><td class="paramname">ciphertext2</td><td>second input ciphertext. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result of homomorphic multiplication of input ciphertexts. </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a9b97098eb1ca1546361184260cc8795f">lbcrypto::LPSHEAlgorithm&lt; Element &gt;</a>.</p>

</div>
</div>
<a id="ad052e2e8a27e722a1d98c9889f38e90b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad052e2e8a27e722a1d98c9889f38e90b">&#9670;&nbsp;</a></span>EvalMult() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ciphertext&lt; Element &gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html">lbcrypto::LPAlgorithmSHEBGVrns</a>&lt; Element &gt;::EvalMult </td>
          <td>(</td>
          <td class="paramtype">ConstCiphertext&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>ciphertext1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstCiphertext&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>ciphertext2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LPEvalKey&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>ek</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function for homomorphic multiplication of ciphertexts followed by key switching operation. Currently it assumes that the input arguments are fresh ciphertexts (of depth 1). Support for the input ciphertexts of higher depths will be added later.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext1</td><td>first input ciphertext. </td></tr>
    <tr><td class="paramname">ciphertext2</td><td>second input ciphertext. </td></tr>
    <tr><td class="paramname">ek</td><td>is the evaluation key to make the newCiphertext decryptable by the same secret key as that of ciphertext1 and ciphertext2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result of homomorphic multiplication of input ciphertexts. </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a8add5c666b7d85b9c64446fc86bfd74d">lbcrypto::LPSHEAlgorithm&lt; Element &gt;</a>.</p>

</div>
</div>
<a id="acb3899ae0ee1c59def38bb98ef2f41ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb3899ae0ee1c59def38bb98ef2f41ec">&#9670;&nbsp;</a></span>EvalMultAndRelinearize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ciphertext&lt;Element&gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html">lbcrypto::LPAlgorithmSHEBGVrns</a>&lt; Element &gt;::EvalMultAndRelinearize </td>
          <td>(</td>
          <td class="paramtype">ConstCiphertext&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>ciphertext1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstCiphertext&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>ciphertext2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; LPEvalKey&lt; Element &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>ek</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unimplemented function to support a multiplication with depth larger than 2 for the BGVrns scheme.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext1</td><td>The first input ciphertext. </td></tr>
    <tr><td class="paramname">ciphertext2</td><td>The second input ciphertext. </td></tr>
    <tr><td class="paramname">ek</td><td>The evaluation key input. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to the ciphertext which is the EvalMult of the two inputs. </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a3b498d9706dba8d30109d3286500cb66">lbcrypto::LPSHEAlgorithm&lt; Element &gt;</a>.</p>

</div>
</div>
<a id="a325a67b17980770194ad684a70bcc066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a325a67b17980770194ad684a70bcc066">&#9670;&nbsp;</a></span>EvalMultCore() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Ciphertext&lt; Element &gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html">lbcrypto::LPAlgorithmSHEBGVrns</a>&lt; Element &gt;::EvalMultCore </td>
          <td>(</td>
          <td class="paramtype">ConstCiphertext&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>ciphertext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Element&#160;</td>
          <td class="paramname"><em>ptxt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Internal function for homomorphic multiplication of ciphertext and plaintext. This method does not check whether input ciphertexts are at the same level.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext</td><td>input ciphertext. </td></tr>
    <tr><td class="paramname">ptxt</td><td>the Element corresponding to the input plaintext. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result of homomorphic subtraction of inputs. </dd></dl>

</div>
</div>
<a id="affbbaee3aa18e3b7c42e7a2cb612d6bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affbbaee3aa18e3b7c42e7a2cb612d6bf">&#9670;&nbsp;</a></span>EvalMultCore() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Ciphertext&lt; Element &gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html">lbcrypto::LPAlgorithmSHEBGVrns</a>&lt; Element &gt;::EvalMultCore </td>
          <td>(</td>
          <td class="paramtype">ConstCiphertext&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>ciphertext1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstCiphertext&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>ciphertext2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Internal function for homomorphic multiplication of ciphertexts. This method does not check whether input ciphertexts are at the same level.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext1</td><td>first input ciphertext. </td></tr>
    <tr><td class="paramname">ciphertext2</td><td>second input ciphertext. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result of homomorphic multiplication of input ciphertexts. </dd></dl>

</div>
</div>
<a id="a5d6ad52a218926c115395d086ec4dc50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d6ad52a218926c115395d086ec4dc50">&#9670;&nbsp;</a></span>EvalMultKeyGen()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LPEvalKey&lt; Element &gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html">lbcrypto::LPAlgorithmSHEBGVrns</a>&lt; Element &gt;::EvalMultKeyGen </td>
          <td>(</td>
          <td class="paramtype">const LPPrivateKey&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>privateKey</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function to generate key switch hint on a ciphertext for depth 2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">privateKey</td><td>is the original private key used for generating ciphertext. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>keySwitchHint generated to switch the ciphertext. </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#aae7b86cdc3fe5d8314ddecea43c4151a">lbcrypto::LPSHEAlgorithm&lt; Element &gt;</a>.</p>

</div>
</div>
<a id="a88293351fc571b9d3aa00aac630335a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88293351fc571b9d3aa00aac630335a9">&#9670;&nbsp;</a></span>EvalMultKeysGen()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; LPEvalKey&lt; Element &gt; &gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html">lbcrypto::LPAlgorithmSHEBGVrns</a>&lt; Element &gt;::EvalMultKeysGen </td>
          <td>(</td>
          <td class="paramtype">const LPPrivateKey&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>privateKey</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function to generate key switch hint on a ciphertext for depth more than 2. Currently this method is not supported for BGVrns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">privateKey</td><td>is the original private key used for generating ciphertext. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>keySwitchHint generated to switch the ciphertext. </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a93e53f262a9425036ad20b6dc51f19f1">lbcrypto::LPSHEAlgorithm&lt; Element &gt;</a>.</p>

</div>
</div>
<a id="ae69d36b7fe817e1a3803c79a6aca0c55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae69d36b7fe817e1a3803c79a6aca0c55">&#9670;&nbsp;</a></span>EvalMultMutable() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Ciphertext&lt;Element&gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html">lbcrypto::LPAlgorithmSHEBGVrns</a>&lt; Element &gt;::EvalMultMutable </td>
          <td>(</td>
          <td class="paramtype">Ciphertext&lt; Element &gt; &amp;&#160;</td>
          <td class="paramname"><em>ciphertext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Plaintext&#160;</td>
          <td class="paramname"><em>plaintext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function for multiplying ciphertext by plaintext. The ciphertext can be changed</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;ciphertext</td><td>input ciphertext. </td></tr>
    <tr><td class="paramname">plaintext</td><td>input plaintext embedded in the cryptocontext. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a07a3b2a149d88352528688002a9e41f2">lbcrypto::LPSHEAlgorithm&lt; Element &gt;</a>.</p>

</div>
</div>
<a id="ac6f10dfa807c693f949b848902a824b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6f10dfa807c693f949b848902a824b2">&#9670;&nbsp;</a></span>EvalMultMutable() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Ciphertext&lt;Element&gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html">lbcrypto::LPAlgorithmSHEBGVrns</a>&lt; Element &gt;::EvalMultMutable </td>
          <td>(</td>
          <td class="paramtype">Ciphertext&lt; Element &gt; &amp;&#160;</td>
          <td class="paramname"><em>ciphertext1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ciphertext&lt; Element &gt; &amp;&#160;</td>
          <td class="paramname"><em>ciphertext2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function for homomorphic multiplication of ciphertexts without key switching. Mutable version - input ciphertexts may get rescaled/level-reduced.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext1</td><td>first input ciphertext. </td></tr>
    <tr><td class="paramname">ciphertext2</td><td>second input ciphertext. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result of homomorphic multiplication of input ciphertexts. </dd></dl>

<p>Reimplemented from <a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#aded587cc01ebe2a4871d1cbe55c0cfca">lbcrypto::LPSHEAlgorithm&lt; Element &gt;</a>.</p>

</div>
</div>
<a id="ac5f531a799de265a7da503faf6e53b1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5f531a799de265a7da503faf6e53b1d">&#9670;&nbsp;</a></span>EvalMultMutable() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ciphertext&lt; Element &gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html">lbcrypto::LPAlgorithmSHEBGVrns</a>&lt; Element &gt;::EvalMultMutable </td>
          <td>(</td>
          <td class="paramtype">Ciphertext&lt; Element &gt; &amp;&#160;</td>
          <td class="paramname"><em>ciphertext1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ciphertext&lt; Element &gt; &amp;&#160;</td>
          <td class="paramname"><em>ciphertext2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LPEvalKey&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>ek</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function for homomorphic multiplication of ciphertexts followed by key switching operation. Mutable version - input ciphertexts may get rescaled/level-reduced.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext1</td><td>first input ciphertext. </td></tr>
    <tr><td class="paramname">ciphertext2</td><td>second input ciphertext. </td></tr>
    <tr><td class="paramname">ek</td><td>is the evaluation key to make the newCiphertext decryptable by the same secret key as that of ciphertext1 and ciphertext2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result of homomorphic multiplication of input ciphertexts. </dd></dl>

<p>Reimplemented from <a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#ab57887f3c759a5ffdb8a2db397b95703">lbcrypto::LPSHEAlgorithm&lt; Element &gt;</a>.</p>

</div>
</div>
<a id="aa0f9c925b6dcad41274b41caa115f3a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0f9c925b6dcad41274b41caa115f3a5">&#9670;&nbsp;</a></span>EvalNegate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ciphertext&lt; Element &gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html">lbcrypto::LPAlgorithmSHEBGVrns</a>&lt; Element &gt;::EvalNegate </td>
          <td>(</td>
          <td class="paramtype">ConstCiphertext&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>ct</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function for homomorphic negation of ciphertexts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ct</td><td>input ciphertext. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new ciphertext. </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a474e102a7dd4dbe3cf62b9231e0528e2">lbcrypto::LPSHEAlgorithm&lt; Element &gt;</a>.</p>

</div>
</div>
<a id="afd25a3fc7474bfd18a004229ab94ee9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd25a3fc7474bfd18a004229ab94ee9b">&#9670;&nbsp;</a></span>EvalSub() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ciphertext&lt;Element&gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html">lbcrypto::LPAlgorithmSHEBGVrns</a>&lt; Element &gt;::EvalSub </td>
          <td>(</td>
          <td class="paramtype">ConstCiphertext&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>ciphertext1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstCiphertext&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>ciphertext2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function for homomorphic subtraction of ciphertexts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext1</td><td>the input ciphertext. </td></tr>
    <tr><td class="paramname">ciphertext2</td><td>the input ciphertext. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result of homomorphic subtraction of input ciphertexts. </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a9a0a68edacc9a85ae5e8316dd888e4c0">lbcrypto::LPSHEAlgorithm&lt; Element &gt;</a>.</p>

</div>
</div>
<a id="a33c2f6e788537907b5f7b24ce572b201"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33c2f6e788537907b5f7b24ce572b201">&#9670;&nbsp;</a></span>EvalSub() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ciphertext&lt;Element&gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html">lbcrypto::LPAlgorithmSHEBGVrns</a>&lt; Element &gt;::EvalSub </td>
          <td>(</td>
          <td class="paramtype">ConstCiphertext&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>ciphertext1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstPlaintext&#160;</td>
          <td class="paramname"><em>plaintext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function for homomorphic subtraction of ciphertexts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext1</td><td>the input ciphertext. </td></tr>
    <tr><td class="paramname">plaintext</td><td>the input plaintext. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result of homomorphic subtraction of input ciphertexts. </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#aad4813fd23d4c2f63a73e4addda5b4a4">lbcrypto::LPSHEAlgorithm&lt; Element &gt;</a>.</p>

</div>
</div>
<a id="ab8a433d6b463e15e37d04bda3b360e91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8a433d6b463e15e37d04bda3b360e91">&#9670;&nbsp;</a></span>EvalSubCore() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Ciphertext&lt; Element &gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html">lbcrypto::LPAlgorithmSHEBGVrns</a>&lt; Element &gt;::EvalSubCore </td>
          <td>(</td>
          <td class="paramtype">ConstCiphertext&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>ciphertext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Element&#160;</td>
          <td class="paramname"><em>ptElement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Internal function for homomorphic subtraction of ciphertext and plaintext. This method does not check whether input ciphertexts are at the same level.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext</td><td>input ciphertext. </td></tr>
    <tr><td class="paramname">ptElement</td><td>the Element corresponding to the input plaintext. </td></tr>
    <tr><td class="paramname">ptDepth</td><td>the scaling factor (depth) of the input plaintext. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result of homomorphic subtraction of inputs. </dd></dl>

</div>
</div>
<a id="a16a101c441c448fb8791efc2303624da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16a101c441c448fb8791efc2303624da">&#9670;&nbsp;</a></span>EvalSubCore() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Ciphertext&lt; Element &gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html">lbcrypto::LPAlgorithmSHEBGVrns</a>&lt; Element &gt;::EvalSubCore </td>
          <td>(</td>
          <td class="paramtype">ConstCiphertext&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>ciphertext1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstCiphertext&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>ciphertext2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Internal function for homomorphic subtraction of ciphertexts. This method does not check whether input ciphertexts are at the same level.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext1</td><td>first input ciphertext. </td></tr>
    <tr><td class="paramname">ciphertext2</td><td>second input ciphertext. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result of homomorphic subtraction of input ciphertexts. </dd></dl>

</div>
</div>
<a id="aa3b75737f8d3eef816005c4b44b413a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3b75737f8d3eef816005c4b44b413a0">&#9670;&nbsp;</a></span>EvalSubMutable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Ciphertext&lt;Element&gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html">lbcrypto::LPAlgorithmSHEBGVrns</a>&lt; Element &gt;::EvalSubMutable </td>
          <td>(</td>
          <td class="paramtype">Ciphertext&lt; Element &gt; &amp;&#160;</td>
          <td class="paramname"><em>ciphertext1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ciphertext&lt; Element &gt; &amp;&#160;</td>
          <td class="paramname"><em>ciphertext2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function for homomorphic subtraction of ciphertexts. Mutable version - input ciphertexts may get rescaled/level-reduced.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext1</td><td>the input ciphertext. </td></tr>
    <tr><td class="paramname">ciphertext2</td><td>the input ciphertext. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result of homomorphic subtraction of input ciphertexts. </dd></dl>

<p>Reimplemented from <a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#add2d781c7631781d0e8c10e9a4abeee1">lbcrypto::LPSHEAlgorithm&lt; Element &gt;</a>.</p>

</div>
</div>
<a id="aff359d4e8a638f1d4e80b4a76f6673db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff359d4e8a638f1d4e80b4a76f6673db">&#9670;&nbsp;</a></span>EvalSubMutable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Ciphertext&lt;Element&gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html">lbcrypto::LPAlgorithmSHEBGVrns</a>&lt; Element &gt;::EvalSubMutable </td>
          <td>(</td>
          <td class="paramtype">Ciphertext&lt; Element &gt; &amp;&#160;</td>
          <td class="paramname"><em>ciphertext1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Plaintext&#160;</td>
          <td class="paramname"><em>plaintext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function for homomorphic subtraction of ciphertexts. Mutable version - input ciphertexts may get rescaled/level-reduced.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext1</td><td>the input ciphertext. </td></tr>
    <tr><td class="paramname">plaintext</td><td>the input plaintext. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result of homomorphic subtraction of input ciphertexts. </dd></dl>

<p>Reimplemented from <a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a927bf565210960bf3e782cb8a8dabfce">lbcrypto::LPSHEAlgorithm&lt; Element &gt;</a>.</p>

</div>
</div>
<a id="a06e3300c56c89fb406283b8177bf6ad8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06e3300c56c89fb406283b8177bf6ad8">&#9670;&nbsp;</a></span>KeySwitchBVGen()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">LPEvalKey&lt;Element&gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html">lbcrypto::LPAlgorithmSHEBGVrns</a>&lt; Element &gt;::KeySwitchBVGen </td>
          <td>(</td>
          <td class="paramtype">const LPPrivateKey&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>oldKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LPPrivateKey&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>newKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td>
          <td class="paramname"><em>ek</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Method for generating a key switch matrix for BV key switching. BV key switching was introduced in Brakerski, et. al., "Efficient
full homomorphic encryption from (standard) LWE". Here, we follow Section 3.2 of "(Leveled) fully homomorphic encryption without
bootstrapping" (BGV paper).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oldKey</td><td>Original private key used for encryption. </td></tr>
    <tr><td class="paramname">newKey</td><td>New private key to generate the keyswitch hint. </td></tr>
    <tr><td class="paramname">ek</td><td>The evaluation key input. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>resulting keySwitchHint. </dd></dl>

</div>
</div>
<a id="a89e95f498f1ce65e6769210a466cbbf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89e95f498f1ce65e6769210a466cbbf1">&#9670;&nbsp;</a></span>KeySwitchBVInPlace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html">lbcrypto::LPAlgorithmSHEBGVrns</a>&lt; Element &gt;::KeySwitchBVInPlace </td>
          <td>(</td>
          <td class="paramtype">const LPEvalKey&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>keySwitchHint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ciphertext&lt; Element &gt; &amp;&#160;</td>
          <td class="paramname"><em>ciphertext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Method for in-place key switching using the BV method introduced in Brakerski, et. al., "Efficient full homomorphic encryption from (standard)
LWE". Here, we follow Section 3.2 of "(Leveled) fully homomorphic
encryption without bootstrapping" (BGV paper).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keySwitchHint</td><td>Hint required to perform the ciphertext switching. </td></tr>
    <tr><td class="paramname">ciphertext</td><td>Original ciphertext to perform in-place key switching on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a577d9cfed0596e5ab0b42bbc939c4372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a577d9cfed0596e5ab0b42bbc939c4372">&#9670;&nbsp;</a></span>KeySwitchGen()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual LPEvalKey&lt;Element&gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html">lbcrypto::LPAlgorithmSHEBGVrns</a>&lt; Element &gt;::KeySwitchGen </td>
          <td>(</td>
          <td class="paramtype">const LPPrivateKey&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>oldKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LPPrivateKey&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>newKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Method for generating a KeySwitchHint using RLWE relinearization</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oldKey</td><td>Original private key used for encryption. </td></tr>
    <tr><td class="paramname">newKey</td><td>New private key to generate the keyswitch hint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>resulting keySwitchHint. </dd></dl>

<p>Implements <a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a959c7121202113e5cdd7a76599ca2560">lbcrypto::LPSHEAlgorithm&lt; Element &gt;</a>.</p>

</div>
</div>
<a id="a5b279e3e48046654fb5289ebd03e6e92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b279e3e48046654fb5289ebd03e6e92">&#9670;&nbsp;</a></span>KeySwitchGHSGen()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">LPEvalKey&lt;Element&gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html">lbcrypto::LPAlgorithmSHEBGVrns</a>&lt; Element &gt;::KeySwitchGHSGen </td>
          <td>(</td>
          <td class="paramtype">const LPPrivateKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td>
          <td class="paramname"><em>oldKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LPPrivateKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td>
          <td class="paramname"><em>newKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td>
          <td class="paramname"><em>ek</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Method for generating a key switch matrix for GHS key switching. GHS key switching was introduced in Gentry, et. al., "Homomorphic
evaluation of the AES circuit (Updated implementation)". Here, we follow the notation of Section 3.2 of "A full RNS variant of
approximate homomorphic encryption" (RNS CKKS paper).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oldKey</td><td>Original private key used for encryption. </td></tr>
    <tr><td class="paramname">newKey</td><td>New private key to generate the keyswitch hint. </td></tr>
    <tr><td class="paramname">ek</td><td>The evaluation key input. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>resulting keySwitchHint. </dd></dl>

</div>
</div>
<a id="a1ea0ce01e86a1b4977876929aa1d097f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ea0ce01e86a1b4977876929aa1d097f">&#9670;&nbsp;</a></span>KeySwitchGHSInPlace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html">lbcrypto::LPAlgorithmSHEBGVrns</a>&lt; Element &gt;::KeySwitchGHSInPlace </td>
          <td>(</td>
          <td class="paramtype">const LPEvalKey&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>keySwitchHint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ciphertext&lt; Element &gt; &amp;&#160;</td>
          <td class="paramname"><em>ciphertext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Method for in-place key switching using the GHS method introduced in Gentry, et. al., "Homomorphic evaluation of the AES circuit (Updated
implementation)". Here, we follow the notation of Section 3.2 of "A full RNS variant of approximate homomorphic encryption" (RNS CKKS paper).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keySwitchHint</td><td>Hint required to perform the ciphertext switching. </td></tr>
    <tr><td class="paramname">ciphertext</td><td>Original ciphertext to perform switching on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae752d203d94dea87f89c7e4900a4b7df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae752d203d94dea87f89c7e4900a4b7df">&#9670;&nbsp;</a></span>KeySwitchHybridGen()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">LPEvalKey&lt;Element&gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html">lbcrypto::LPAlgorithmSHEBGVrns</a>&lt; Element &gt;::KeySwitchHybridGen </td>
          <td>(</td>
          <td class="paramtype">const LPPrivateKey&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>oldKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LPPrivateKey&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>newKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LPEvalKey&lt; <a class="el" href="classlbcrypto_1_1HexlDCRTPoly.html">DCRTPoly</a> &gt;&#160;</td>
          <td class="paramname"><em>ek</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Method for generating a key switch matrix for HYBRID key switching. HYBRID key switching is described in Section 3 of Han, et. al., "Better bootstrapping for approximate homomorphic encryption".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oldKey</td><td>Original private key used for encryption. </td></tr>
    <tr><td class="paramname">newKey</td><td>New private key to generate the keyswitch hint. </td></tr>
    <tr><td class="paramname">ek</td><td>The evaluation key input. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>resulting keySwitchHint. </dd></dl>

</div>
</div>
<a id="a2c101e026ddb531cb7079194fb8fae96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c101e026ddb531cb7079194fb8fae96">&#9670;&nbsp;</a></span>KeySwitchInPlace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html">lbcrypto::LPAlgorithmSHEBGVrns</a>&lt; Element &gt;::KeySwitchInPlace </td>
          <td>(</td>
          <td class="paramtype">const LPEvalKey&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>keySwitchHint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ciphertext&lt; Element &gt; &amp;&#160;</td>
          <td class="paramname"><em>ciphertext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Method for in-place KeySwitching based on a KeySwitchHint - uses the RLWE relinearization</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keySwitchHint</td><td>Hint required to perform the ciphertext switching. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#ac167477b1ce06546209a93c3579302b6">lbcrypto::LPSHEAlgorithm&lt; Element &gt;</a>.</p>

</div>
</div>
<a id="ae752b1b569ee7e320ec74882e6524864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae752b1b569ee7e320ec74882e6524864">&#9670;&nbsp;</a></span>Relinearize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ciphertext&lt;Element&gt; <a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html">lbcrypto::LPAlgorithmSHEBGVrns</a>&lt; Element &gt;::Relinearize </td>
          <td>(</td>
          <td class="paramtype">ConstCiphertext&lt; Element &gt;&#160;</td>
          <td class="paramname"><em>ciphertext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; LPEvalKey&lt; Element &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>ek</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Virtual function to do relinearization</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext</td><td>input ciphertext. </td></tr>
    <tr><td class="paramname">ek</td><td>are the evaluation keys to make the newCiphertext decryptable by the same secret key as that of ciphertext1 and ciphertext2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new resulting ciphertext. </dd></dl>

<p>Reimplemented from <a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#ac627acbd61ff31b65faa3894315e49b2">lbcrypto::LPSHEAlgorithm&lt; Element &gt;</a>.</p>

</div>
</div>
<a id="ae5da404412186e933e8c9f99810a8feb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5da404412186e933e8c9f99810a8feb">&#9670;&nbsp;</a></span>RelinearizeInPlace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlbcrypto_1_1LPAlgorithmSHEBGVrns.html">lbcrypto::LPAlgorithmSHEBGVrns</a>&lt; Element &gt;::RelinearizeInPlace </td>
          <td>(</td>
          <td class="paramtype">Ciphertext&lt; Element &gt; &amp;&#160;</td>
          <td class="paramname"><em>ciphertext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; LPEvalKey&lt; Element &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>ek</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Virtual function to do in-place relinearization</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;ciphertext</td><td>input ciphertext. </td></tr>
    <tr><td class="paramname">ek</td><td>are the evaluation keys </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new resulting ciphertext. </dd></dl>

<p>Reimplemented from <a class="el" href="classlbcrypto_1_1LPSHEAlgorithm.html#a25753c8e6d9cf8598b91e38e9aca7e97">lbcrypto::LPSHEAlgorithm&lt; Element &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/pke/include/scheme/bgvrns/<a class="el" href="bgvrns_8h_source.html">bgvrns.h</a></li>
<li>src/pke/lib/scheme/bgvrns/bgvrns.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Nov 9 2021 14:41:34 for PALISADE Lattice Crypto Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
